#include "nonobtusemc.h"
#include "tribox.h"
#include "utility.h"
#include <cmath>

namespace DUT
{
    ///*
    // modified from base class to give nonobtuse marching cube
    // also in some cases modified from base class to give less triangles
    template <class T>
    const int IsoSurface<T>::iTriTable[256][16] =
    {
        // list of edges the triangle touches
        // -1 denotes end of list
        // special case if first index is -3, -5, -7, -9, -11, -12, -14
        //
        // -3:    Special Case -3
        // {-3, a, b, c, d, e, f, -1, ... }
        // where a,b,c,d forms a quad, and d,e,f,a forms the other quad
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of a,d
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
        //
        // -5:  Special Case 5b
        // {-5, a, b, c, d, e, -1, ... }
        // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of b,e
        // Then, the 5 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, -1}
        //
        // -7:  Special Case -7
        // {-7, a, b, c, d, e, f, i, j, k, -1, ... }
        // where a,b,c,d,e,f forms a hexagon and i,j,k forms a triangle
        // The right hand ordering determines the normals
        // A new point m should be added to the centroid of a,b,c,d,e,f
        // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, i, j, k, -1}
        //
        // -9:  Special Case 9b
        // {-9, a, b, c, d, e, f, -1, ... }
        // where a,b,c,d,e,f forms a hexagon.
        // The right hand ordering determines the normals
        // A new point m should be added to the centroid of a,b,c,d,e,f
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
        //
        // -11: Special Case 11b **** OBSOLETE ****
        // {-11, a, b, c, d, e, f, -1, ... ]
        // where a,b,f forms the triangle that has degree 120 at angle(fab)
        //       b,c,d and d,e,f forms the 2 triangles that have right angle
        //       b,d,f forms the equilateral triangle
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of b,f
        // Then, the 6 new triangles are {a, b, m, b, d, m, c, d, b, d, f, m, e, f, d, f, a, m, -1}
        //
        // -11: Special Case 11c
        // {-11, a, b, c, d, e, f, -1, ... ]
        // where a,b,c,d,e,f forms a bent hexagon.
        //       new point m is added in the center of the cube
        //       b,c,m and e,f,m are right isoscele triangles
        //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
        // The right hand ordering determines the normals
        // A new point m should be added to the center of cube (ie. midpoint of a and d)
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
        //
        // -12: Special Case 12b
        // {-12, a, b, c, d, e, i, j, k, -1, ... }
        // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
        //       and i, j, k forms a seperate triangle
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of b,e
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, a, m, i, j, k, -1}
        //
        // -14: Special Case 14b **** OBSOLETE ****
        // {-14, a, b, c, d, e, f, -1, ... ]
        // where a,b,f forms the triangle that has degree 120 at angle(fab)
        //       b,c,d and d,e,f forms the 2 triangles that have right angle
        //       b,d,f forms the equilateral triangle
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of b,f
        // Then, the 6 new triangles are {a, b, m, b, d, m, c, d, b, d, f, m, e, f, d, f, a, m, -1}
        //
        // -14: Special Case 14c
        // {-11, a, b, c, d, e, f, -1, ... ]
        // where a,b,c,d,e,f forms a bent hexagon.
        //       new point m is added in the center of the cube
        //       b,c,m and e,f,m are right isoscele triangles
        //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
        // The right hand ordering determines the normals
        // A new point m should be added to the center of cube (ie. midpoint of a and d)
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
    
        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},   // 0000 0000; v none    (case 0)
        {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 0001; v 0       (case 1)
        {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 0010; v 1       (case 1)
        {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0000 0011; v 0,1     (case 2)
        {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0000 0100; v 2       (case 1)
        {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0000 0101; v 0,2     (case 3)
        {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0000 0110; v 1,2     (case 2)

        //{2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},        // 0000 0111; v 0,1,2   (case 5)
        {-5, 9, 8, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0000 0111; v 0,1,2   (case 5b)

        {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0000 1000; v 3       (case 1)
        {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0000 1001; v 0,3     (case 2)
        {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0000 1010; v 1,3     (case 3)

        //{1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},       // 0000 1011; v 0,1,3   (case 5)
        {-5, 8, 11, 2, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0000 1011; v 0,1,3   (case 5b)

        {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1100; v 2,3     (case 1)

        //{0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},      // 0000 1101; v 0,2,3   (case 5)
        {-5, 11, 10, 1, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1101; v 0,2,3   (case 5b)

        //{3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},       // 0000 1110; v 1,2,3   (case 5)
        {-5, 10, 9, 0, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1110; v 1,2,3   (case 5b)

        {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1111; v 0,1,2,3 (case 8)
        {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0001 0000; v 4       (case 1)
        {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0001 0001; v 0,4     (case 2)
        {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0001 0010; v 1,4     (case 3)

        //{4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},          // 0001    0011; v 0,1,4(case 5)
        {-5, 3, 1, 9, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001    0011; v 0,1,4(case 5b)

        {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001 0100; v 2,4     (case 4)
        {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},           // 0001 0101; v 0,2,4   (case 6)
        {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},           // 0001 0110; v 1,2,4   (case 6)

        //{2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},            // 0001 0111; v 0,1,2,4 (case 14)
        //{-14, 4, 7, 3, 2, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0001 0111; v 0,1,2,4 (case 14b)
        //{2, 10, 9, 2, 9, 3, 3, 9, 4, 3, 4, 7, -1, -1, -1, -1},            // 0001 0111; v 0,1,2,4 (case 14)
        {-14, 4, 7, 3, 2, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0001 0111; v 0,1,2,4 (case 14c)

        {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001 1000; v 3,4     (case 3)

        //{11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},        // 0001 1001; v 0,3,4   (case 5)
        {-5, 0, 4, 7, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0001 1001; v 0,3,4   (case 5b)

        {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},           // 0001 1010; v 1,3,4   (case 7)

        //{4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},          // 0001 1011; v 0,1,3,4 (case 9)
        {-9, 4, 7, 11, 2, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001 1011; v 0,1,3,4 (case 9b)

        {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},         // 0001 1100; v 2,3,4   (case 6)

        //{1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},         // 0001 1101; v 0,2,3,4 (case 11)
        //{-11, 7, 11, 10, 1, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 0001 1101; v 0,2,3,4 (case 11b)
        //{1, 11, 10, 1, 0, 11, 0, 7, 11, 0, 4, 7, -1, -1, -1, -1},         // 0001 1101; v 0,2,3,4 (case 11)
        {-11, 7, 11, 10, 1, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0001 1101; v 0,2,3,4 (case 11c)

        //{4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},         // 0001 1110; v 1,2,3,4 (case 12)
        {-12, 10, 9, 0, 3, 11, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},        // 0001 1110; v 1,2,3,4 (case 12b)

        //{4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},      // 0001 1111; v -5.-6,-7(case -5)
        {-5, 10, 9, 4, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0001 1111; v -5.-6,-7(case -5b)

        {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0010 0000; v 5       (case 1)
        {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0010 0001; v 0,5     (case 3)
        {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0010 0010; v 1,5     (case 2)

        //{8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},          // 0010 0011; v 0,1,5   (case 5)
        {-5, 1, 5, 4, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 0011; v 0,1,5   (case 5b)

        {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 0100; v 2,5     (case 3)
        {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},           // 0010 0101; v 0,2,5   (case 7)

        //{5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},         // 0010 0110; v 1,2,5   (case 5)
        {-5, 0, 2, 10, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0010 0110; v 1,2,5   (case 5b)

        //{2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},            // 0010 0111; v 0,1,2,5 (case 9)
        {-9, 2, 10, 5, 4, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 0111; v 0,1,2,5 (case 9b)

        {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 1000; v 3,5     (case 4)
        {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},          // 0010 1001; v 0,3,5   (case 6)
        {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},           // 0010 1010; v 1,3,5   (case 6)

        //{2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},            // 0010 1011; v 0,1,3,5 (case 11)
        //{-11, 4, 8, 11, 2, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0010 1011; v 0,1,3,5 (case 11b)
        //{2, 8, 11, 2, 1, 8, 1, 4, 8, 1, 5, 4, -1, -1, -1, -1},            // 0010 1011; v 0,1,3,5 (case 11)
        {-11, 4, 8, 11, 2, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0010 1011; v 0,1,3,5 (case 11c)

        {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},         // 0010 1100; v 2,3,5   (case 6)

        //{4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},          // 0010 1101; v 0,2,3,5 (case 12)
        {-12, 11, 10, 1, 0, 8, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},        // 0010 1101; v 0,2,3,5 (case 12b)

        //{5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},         // 0010 1110; v 1,2,3,5 (case 14)
        //{-14, 3, 11, 10, 5, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 0010 1110; v 1,2,3,5 (case 14b)
        //{5, 4, 0, 5, 0, 10, 10, 0, 3, 10, 3, 11, -1, -1, -1, -1},         // 0010 1110; v 1,2,3,5 (case 14)
        {-14, 3, 11, 10, 5, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0010 1110; v 1,2,3,5 (case 14c)

        //{5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},       // 0010 1111; v -4,-6,-7(case -5)
        {-5, 11, 10, 5, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0010 1111; v -4,-6,-7(case -5b)

        {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0011 0000; v 4,5     (case 2)

        //{9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},          // 0011 0001; v 0,4,5   (case 5)
        {-5, 7, 3, 0, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0011 0001; v 0,4,5   (case 5b)

        //{0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},          // 0011 0010; v 1,4,5   (case 5)
        {-5, 5, 7, 8, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0011 0010; v 1,4,5   (case 5b)

        {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0011 0011; v 0,1,4,5 (case 8)
        {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},           // 0011 0100; v 2,4,5   (case 6)

        //{10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},            // 0011 0101; v 0,2,4,5 (case 12)
        {-12, 7, 3, 0, 9, 5, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},         // 0011 0101; v 0,2,4,5 (case 12b)

        //{8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},            // 0011 0110; v 1,2,4,5 (case 11)
        //{-11, 10, 5, 7, 8, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0011 0110; v 1,2,4,5 (case 11b)
        //{10, 0, 2, 10, 5, 0, 5, 8, 0, 5, 7, 8, -1, -1, -1, -1},           // 0011 0110; v 1,2,4,5 (case 11)
        {-11, 10, 5, 7, 8, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 0110; v 1,2,4,5 (case 11c)

        //{2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},         // 0011 0111; v -3,-6.-7(case -5)
        {-5, 7, 3, 2, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 0111; v -3,-6.-7(case -5b)

        {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},           // 0011 1000; v 3,4,5   (case 6)

        //{9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},            // 0011 1001; v 0,3,4,5 (case 14)
        //{-14, 11, 2, 0, 9, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0011 1001; v 0,3,4,5 (case 14b)
        //{9, 5, 7, 9, 7, 0, 0, 7, 11, 0, 11, 2, -1, -1, -1, -1},           // 0011 1001; v 0,3,4,5 (case 14)
        {-14, 11, 2, 0, 9, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 1001; v 0,3,4,5 (case 14c)

        //{2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},            // 0011 1010; v 1,3,4,5 (case 12)
        {-12, 5, 7, 8, 0, 1, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},         // 0011 1010; v 1,3,4,5 (case 12b)

        //{11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},        // 0011 1011; v -2,-6,-7(case -5)
        {-5, 5, 7, 11, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 1011; v -2,-6,-7(case -5b)

        {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},            // 0011 1100; v 2,3,4,5 (case 10)

        //{5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},            // 0011 1101; v -1,-6.-7(case -6)
        {5, 7, 9, 9, 7, 0, 7, 11, 0, 1, 0, 11, 11, 10, 1, -1},              // 0011 1101; v -1,-6.-7(case -6)

        //{11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},            // 0011 1110; v -0,-6.-7(case -6)
        {11, 10, 3, 3, 10, 0, 10, 5, 0, 8, 0, 5, 5, 7, 8, -1},              // 0011 1110; v -0,-6.-7(case -6)

    // starting from here: only negative cases are checked
        {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0011 1111; v -6,-7   (case -2)
        {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0100 0000; v 6       (case 1)
        {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0001; v 0,6     (case 4)
        {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0010; v 1,6     (case 3)
        {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},           // 0100 0011; v 0,1,6   (case 6)
        {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0100 0100; v 2,6     (case 2)
        {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},            // 0100 0101; v 0,2,6   (case 6)

        //{9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},          // 0100 0110; v 1,2,6   (case 5)
        {-5, 2, 6, 5, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0110; v 1,2,6   (case 5b)

        //{5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},             // 0100 0111; v 0,1,2,6 (case 11)
        //{-11, 3, 2, 6, 5, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0100 0111; v 0,1,2,6 (case 11b)
        //{5, 2, 6, 5, 9, 2, 9, 3, 2, 9, 8, 3, -1, -1, -1, -1},             // 0100 0111; v 0,1,2,6 (case 11)
        {-11, 3, 2, 6, 5, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0111; v 0,1,2,6 (case 11c)

        {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1000; v 3,6     (case 3)
        {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},         // 0100 1001; v 0,3,6   (case 6)
        {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},          // 0100 1010; v 1,3,6   (case 7)

        //{5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},          // 0100 1011; v 0,1,3,6 (case 12)
        {-12, 8, 11, 2, 1, 9, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},        // 0100 1011; v 0,1,3,6 (case 12b)

        //{6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},         // 0100 1100; v 2,3,6   (case 5)
        {-5, 1, 3, 11, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1100; v 2,3,6   (case 5b)

        //{0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},          // 0100 1101; v 0,2,3,6 (case 14)
        //{-14, 6, 5, 1, 0, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0100 1101; v 0,2,3,6 (case 14b)
        //{0, 8, 11, 0, 11, 1, 1, 11, 6, 1, 6, 5, -1, -1, -1, -1},          // 0100 1101; v 0,2,3,6 (case 14)
        {-14, 6, 5, 1, 0, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1101; v 0,2,3,6 (case 14c)

        //{3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},            // 0100 1110; v 1,2,3,6 (case 9)
        {-9, 3, 11, 6, 5, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 1110; v 1,2,3,6 (case 9b)

        //{6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},        // 0100 1111; v -4,-5,-7(case -5)
        {-5, 8, 11, 6, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1111; v -4,-5,-7(case -5b)

        {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0101 0000; v 4,6     (case 3)
        {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},           // 0101 0001; v 0,4,6   (case 6)
        {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},           // 0101 0010; v 1,4,6   (case 7)

        //{10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},            // 0101 0011; v 0,1,4,6 (case 12)
        {-12, 3, 1, 9, 4, 7, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},         // 0101 0011; v 0,1,4,6 (case 12b)

        {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},            // 0101 0100; v 2,4,6   (case 6)
        {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},               // 0101 0101; v 0,2,4,6 (case 10)

        //{8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},             // 0101 0110; v 1,2,4,6 (case 12)
        {-12, 2, 6, 5, 9, 0, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},          // 0101 0110; v 1,2,4,6 (case 12b)

        //{7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},                // 0101 0111; v -3,-5,-7(case -6)
        {7, 3, 4, 4, 3, 9, 3, 2, 9, 5, 9, 2, 2, 6, 5, -1},                  // 0101 0111; v -3,-5,-7(case -6)

         {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},         // 0101 1000; v 3,4,6   (case 7)

        //{5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},           // 0101 1001; v 0,3,4,6 (case 12)
        {-12, 0, 4, 7, 11, 2, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},        // 0101 1001; v 0,3,4,6 (case 12b)

        {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},             // 0101 1010; v 1,3,4,6 (case 13)

        //{9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},            // 0101 1011; v -2,-5,-7(case -7)
        {-7, 9, 4, 7, 11, 2, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1},          // 0101 1011; v -2,-5,-7(case -7)

        //{8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},           // 0101 1100; v 2,3,4,6 (case 12)
        {-12, 1, 3, 11, 6, 5, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},         // 0101 1100; v 2,3,4,6 (case 12b)

        //{5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},           // 0101 1101; v -1,-5,-7(case -6)
        {5, 1, 6, 6, 1, 11, 1, 0, 11, 7, 11, 0, 0, 4, 7, -1},               // 0101 1101; v -1,-5,-7(case -6)

        //{0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},               // 0101 1110; v -0,-5,-7(case -7)
        {-7, 9, 0, 3, 11, 6, 5, 8, 4, 7, -1, -1, -1, -1, -1, -1},           // 0101 1110; v -0,-5,-7(case -7)

        //{6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},           // 0101 1111; v -5,-7   (case -3)
        {-3, 9, 4, 7, 11, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0101 1111; v -5,-7   (case -3)

        {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 0000; v 5,6     (case 2)
        {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},          // 0110 0001; v 0,5,6   (case 6)

        //{10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},        // 0110 0010; v 1,5,6   (case 5)
        {-5, 4, 0, 1, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 0010; v 1,5,6   (case 5b)

        //{8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},            // 0110 0011; v 0,1,5,6 (case 14)
        //{-14, 10, 6, 4, 8, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0110 0011; v 0,1,5,6 (case 14b)
        //{10, 6, 4, 10, 4, 1, 1, 4, 8, 1, 8, 3, -1, -1, -1, -1},           // 0110 0011; v 0,1,5,6 (case 14)
        {-14, 10, 6, 4, 8, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 0011; v 0,1,5,6 (case 14c)

        //{1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},          // 0110 0100; v 2,5,6   (case 5)
        {-5, 6, 4, 9, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0110 0100; v 2,5,6   (case 5b)

        //{3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},             // 0110 0101; v 0,2,5,6 (case 12)
        {-12, 6, 4, 9, 1, 2, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},          // 0110 0101; v 0,2,5,6 (case 12b)

        {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0110 0110; v 1,2,5,6 (case 8)

        //{8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},          // 0110 0111; v -3,-4,-7(case -5)
        {-5, 6, 4, 8, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0110 0111; v -3,-4,-7(case -5b)

        {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},         // 0110 1000; v 3,5,6   (case 6)
        {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},            // 0110 1001; v 0,3,5,6 (case 10)

        //{3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},           // 0110 1010; v 1,3,5,6 (case 12)
        {-12, 4, 0, 1, 10, 6, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},        // 0110 1010; v 1,3,5,6 (case 12b)

        //{6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},             // 0110 1011; v -2,-4,-7(case -6)
        {6, 4, 10, 10, 4, 1, 4, 8, 1, 2, 1, 8, 8, 11, 2, -1},               // 0110 1011; v -2,-4,-7(case -6)

        //{9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},            // 0110 1100; v 2,3,5,6 (case 11)
        //{-11, 11, 6, 4, 9, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0110 1100; v 2,3,5,6 (case 11b)
        //{9, 6, 4, 9, 1, 6, 1, 11, 6, 1, 3, 11, -1, -1, -1, -1},           // 0110 1100; v 2,3,5,6 (case 11)
        {-11, 11, 6, 4, 9, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 1100; v 2,3,5,6 (case 11c)

        //{8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},              // 0110 1101; v -1,-4,-7(case -6)
        {8, 11, 0, 0, 11, 1, 11, 6, 1, 9, 1, 6, 6, 4, 9, -1},               // 0110 1101; v -1,-4,-7(case -6)

        //{3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},         // 0110 1110; v -0,-4,-7(case -5)
        {-5, 4, 0, 3, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 1110; v -0,-4,-7(case -5b)

        {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0110 1111; v -4,-7   (case -2)

        //{7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},       // 0111 0000; v 4,5,6   (case 5)
        {-5, 9, 10, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 0000; v 4,5,6   (case 5b)

        //{0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},          // 0111 0001; v 0,4,5,6 (case 11)
        //{-11, 6, 7, 3, 0, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0111 0001; v 0,4,5,6 (case 11b)
        //{0, 7, 3, 0, 9, 7, 9, 6, 7, 9, 10, 6, -1, -1, -1, -1},            // 0111 0001; v 0,4,5,6 (case 11)
        {-11, 6, 7, 3, 0, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 0001; v 0,4,5,6 (case 11c)

        //{10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},           // 0111 0010; v 1,4,5,6 (case 9)
        {-9, 10, 6, 7, 8, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 0010; v 1,4,5,6 (case 9b)

        //{10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},        // 0111 0011; v -2,-3,-7(case -5)
        {-5, 3, 1, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 0011; v -2,-3,-7(case -5b)

        //{1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},             // 0111 0100; v 2,4,5,6 (case 14)
        //{-14, 7, 8, 9, 1, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0111 0100; v 2,4,5,6 (case 14b)
        //{7, 8, 9, 7, 9, 6, 6, 9, 1, 6, 1, 2, -1, -1, -1, -1},             // 0111 0100; v 2,4,5,6 (case 14)
        {-14, 7, 8, 9, 1, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 0100; v 2,4,5,6 (case 14c)

        //{2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},                // 0111 0101; v -1,-3,-7(case -6)
        {2, 6, 1, 1, 6, 9, 6, 7, 9, 0, 9, 7, 7, 3, 0, -1},                  // 0111 0101; v -1,-3,-7(case -6)

        //{7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},          // 0111 0110; v -0,-3,-7(case -5)
        {-5, 2, 6, 7, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 0110; v -0,-3,-7(case -5b)

        {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0111 0111; v -3,-7   (case -2)

        //{2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},          // 0111 1000; v 3,4,5,6 (case 12)
        {-12, 9, 10, 6, 7, 8, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},        // 0111 1000; v 3,4,5,6 (case 12b)

        //{2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},             // 0111 1001; v -1,-2,-7(case -6)
        {2, 0, 11, 11, 0, 7, 0, 9, 7, 6, 7, 9, 9, 10, 6, -1},               // 0111 1001; v -1,-2,-7(case -6)

        //{1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},             // 0111 1010; v -0,-2,-7(case -7)
        {-7, 0, 1, 10, 6, 7, 8, 2, 3, 11, -1, -1, -1, -1, -1, -1},          // 0111 1010; v -0,-2,-7(case -7)

        //{11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},          // 0111 1011; v -2,-7   (case -3)
        {-3, 1, 10, 6, 7, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 1011; v -2,-7   (case -3)

        //{8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},               // 0111 1100; v -0,-1,-7(case -6)
        {8, 9, 7, 7, 9, 6, 9, 1, 6, 11, 6, 1, 1, 3, 11, -1},                // 0111 1100; v -0,-1,-7(case -6)

        {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 1101; v -1,-7   (case -4)

        //{7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},           // 0111 1110; v -0,-7   (case -3)
        {-3, 0, 3, 11, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 1110; v -0,-7   (case -3)

        {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0111 1111; v -7      (case -1)
        {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1000 0000; v 7       (case 1)
        {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 0001; v 0,7     (case 3)
        {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 0010; v 1,7     (case 4)
        {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},           // 1000 0011; v 0,1,7   (case 6)
        {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 0100; v 2,7     (case 3)
        {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},          // 1000 0101; v 0,2,7   (case 7)
        {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},          // 1000 0110; v 1,2,7   (case 6)

        //{6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},         // 1000 0111; v 0,1,2,7 (case 12)
        {-12, 9, 8, 3, 2, 10, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},        // 1000 0111; v 0,1,2,7 (case 12b)

        {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1000 1000; v 3,7     (case 2)

        //{7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},          // 1000 1001; v 0,3,7   (case 5)
        {-5, 2, 0, 8, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 1001; v 0,3,7   (case 5b)

        {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},            // 1000 1010; v 1,3,7   (case 6)
    
        //{1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},             // 1000 1011; v 0,1,3,7 (case 14)
        //{-14, 1, 9, 8, 7, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1000 1011; v 0,1,3,7 (case 14b)
        //{1, 9, 8, 1, 8, 2, 2, 8, 7, 2, 7, 6, -1, -1, -1, -1},             // 1000 1011; v 0,1,3,7 (case 14)
        {-14, 1, 9, 8, 7, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 1011; v 0,1,3,7 (case 14c)

        //{10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},        // 1000 1100; v 2,3,7   (case 5)
        {-5, 3, 7, 6, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 1100; v 2,3,7   (case 5b)

        //{10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},           // 1000 1101; v 0,2,3,7 (case 9)
        {-9, 7, 6, 10, 1, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 1101; v 0,2,3,7 (case 9b)

        //{0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},          // 1000 1110; v 1,2,3,7 (case 11)
        //{-11, 6, 10, 9, 0, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1000 1110; v 1,2,3,7 (case 11b)
        //{0, 10, 9, 0, 3, 10, 3, 6, 10, 3, 7, 6, -1, -1, -1, -1},          // 1000 1110; v 1,2,3,7 (case 11)
        {-11, 6, 10, 9, 0, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 1110; v 1,2,3,7 (case 11c)

        //{7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},       // 1000 1111; v -4,-5,-6(case -5)
        {-5, 9, 8, 7, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 1111; v -4,-5,-6(case -5b)

        {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1001 0000; v 4,7     (case 2)

        //{3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},         // 1001 0001; v 0,4,7   (case 5)
        {-5, 4, 6, 11, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 0001; v 0,4,7   (case 5b)

        {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},           // 1001 0010; v 1,4,7   (case 6)

        //{9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},            // 1001 0011; v 0,1,4,7 (case 11)
        //{-11, 11, 3, 1, 9, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1001 0011; v 0,1,4,7 (case 11b)
        //{9, 3, 1, 9, 4, 3, 4, 11, 3, 4, 6, 11, -1, -1, -1, -1},           // 1001 0011; v 0,1,4,7 (case 11)
        {-11, 11, 3, 1, 9, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 0011; v 0,1,4,7 (case 11c)

        {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},          // 1001 0100; v 2,4,7   (case 6)

        //{1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},          // 1001 0101; v 0,2,4,7 (case 12)
        {-12, 4, 6, 11, 3, 0, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},        // 1001 0101; v 0,2,4,7 (case 12b)

        {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},            // 1001 0110; v 1,2,4,7        (case 10)

        //{10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},             // 1001 0111; v -3,-5,-6(case -6)
        {10, 9, 2, 2, 9, 3, 9, 4, 3, 11, 3, 4, 4, 6, 11, -1},               // 1001 0111; v -3,-5,-6(case -6)

        //{8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},          // 1001 1000; v 3,4,7   (case 5)
        {-5, 6, 2, 3, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1001 1000; v 3,4,7   (case 5b)

        {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1001 1001; v 0,3,4,7 (case 8)

        //{1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},             // 1001 1010; v 1,3,4,7 (case 12)
        {-12, 6, 2, 3, 8, 4, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},          // 1001 1010; v 1,3,4,7 (case 12b)

        //{1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},          // 1001 1011; v -2,-5,-6(case -5)
        {-5, 6, 2, 1, 9, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1001 1011; v -2,-5,-6(case -5b)

        //{8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},            // 1001 1100; v 2,3,4,7 (case 14)
        //{-14, 10, 1, 3, 8, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1001 1100; v 2,3,4,7 (case 14b)
        //{10, 1, 3, 10, 3, 6, 6, 3, 8, 6, 8, 4, -1, -1, -1, -1},           // 1001 1100; v 2,3,4,7 (case 14)
        {-14, 10, 1, 3, 8, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 1100; v 2,3,4,7 (case 14c)

        //{10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},        // 1001 1101; v -1,-5,-6(case -5)
        {-5, 4, 6, 10, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 1101; v -1,-5,-6(case -5b)

        //{4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},              // 1001 1110; v -0,-5,-6(case -6)
        {4, 6, 8, 8, 6, 3, 6, 10, 3, 0, 3, 10, 10, 9, 0, -1},               // 1001 1110; v -0,-5,-6(case -6)

        {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 1111; v -5,-6   (case -2)
        {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1010 0000; v 5,7     (case 3)
        {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},           // 1010 0001; v 0,5,7   (case 7)
        {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},           // 1010 0010; v 1,5,7   (case 6)

        //{11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},            // 1010 0011; v 0.1.5.7 (case 12)
        {-12, 1, 5, 4, 8, 3, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},         // 1010 0011; v 0.1.5.7 (case 12b)

        {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},          // 1010 0100; v 2,5,7   (case 7)
        {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},             // 1010 0101; v 0,2,5,7 (case 13)

        //{7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},          // 1010 0110; v 1,2,5,7 (case 12)
        {-12, 0, 2, 10, 5, 4, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},        // 1010 0110; v 1,2,5,7 (case 12b)

        //{3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},              // 1010 0111; v -3,-4,-6(case -7)
        {-7, 5, 4, 8, 3, 2, 10, 6, 11, 7, -1, -1, -1, -1, -1, -1},          // 1010 0111; v -3,-4,-6(case -7)

        {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},            // 1010 1000; v 3,5,7   (case 6)

        //{9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},             // 1010 1001; v 0,3,5,7 (case 12)
        {-12, 2, 0, 8, 7, 6, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},          // 1010 1001; v 0,3,5,7 (case 12b)

        {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},               // 1010 1010; v 1,3,5,7 (case 10)

        //{6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},                // 1010 1011; v -2,-4,-6(case -6)
        {6, 2, 7, 7, 6, 8, 2, 1, 8, 4, 8, 1, 1, 5, 4, -1},                  // 1010 1011; v -2,-4,-6(case -6)

        //{9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},            // 1010 1100; v 2,3,5,7 (case 12)
        {-12, 3, 7, 6, 10, 1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},         // 1010 1100; v 2,3,5,7 (case 12b)

        //{1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},               // 1010 1101; v -1,-4,-6(case -7)
        {-7, 1, 0, 8, 7, 6, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1},           // 1010 1101; v -1,-4,-6(case -7)

        //{4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},           // 1010 1110; v -0,-4,-6(case -6)
        {4, 0, 5, 5, 0, 10, 0, 3, 10, 6, 10, 3, 3, 7, 6, -1},               // 1010 1110; v -0,-4,-6(case -6)

        //{7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},         // 1010 1111; v -4,-6   (case -3)
        {-3, 10, 5, 4, 8, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1010 1111; v -4,-6   (case -3)

        //{6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},        // 1011 0000; v 4,5,7   (case 5)
        {-5, 8, 9, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0000; v 4,5,7   (case 5b)

        //{3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},            // 1011 0001; v 0,4,5,7 (case 9)
        {-9, 6, 11, 3, 0, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 0001; v 0,4,5,7 (case 9b)

        //{0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},          // 1011 0010; v 1,4,5,7 (case 14)
        //{-14, 6, 11, 8, 0, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1011 0010; v 1,4,5,7 (case 14b)
        //{0, 1, 5, 0, 5, 8, 8, 5, 6, 8, 6, 11, -1, -1, -1, -1},            // 1011 0010; v 1,4,5,7 (case 14)
        {-14, 6, 11, 8, 0, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0010; v 1,4,5,7 (case 14c)

        //{6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},         // 1011 0011; v -2,-3,-6(case -5)
        {-5, 1, 5, 6, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0011; v -2,-3,-6(case -5b)

        //{1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},         // 1011 0100; v 2,4,5,7 (case 12)
        {-12, 8, 9, 5, 6, 11, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},        // 1011 0100; v 2,4,5,7 (case 12b)

        //{0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},             // 1011 0101; v -1,-3,-6(case -7)
        {-7, 9, 5, 6, 11, 3, 0, 10, 1, 2, -1, -1, -1, -1, -1, -1},          // 1011 0101; v -1,-3,-6(case -7)

        //{11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},             // 1011 0110; v -0,-3,-6(case -6)
        {11, 8, 6, 6, 8, 5, 8, 0, 5, 10, 5, 0, 0, 2, 10, -1},               // 1011 0110; v -0,-3,-6(case -6)

        //{6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},          // 1011 0111; v -3,-6   (case -3)
        {-3, 3, 2, 10, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0111; v -3,-6   (case -3)

        //{5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},             // 1011 1000; v 3,4,5,7 (case 11)
        //{-11, 3, 8, 9, 5, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1011 1000; v 3,4,5,7 (case 11b)
        //{5, 8, 9, 5, 6, 8, 6, 3, 8, 6, 2, 3, -1, -1, -1, -1},             // 1011 1000; v 3,4,5,7 (case 11)
        {-11, 3, 8, 9, 5, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1000; v 3,4,5,7 (case 11c)

        //{9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},          // 1011 1001; v -1,-2,-6(case -5)
        {-5, 2, 0, 9, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1001; v -1,-2,-6(case -5b)

        //{1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},                // 1011 1010; v -0,-2,-6(case -6)
        {1, 5, 0, 0, 5, 8, 5, 6, 8, 3, 8, 6, 6, 2, 3, -1},                  // 1011 1010; v -0,-2,-6(case -6)

        {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1011 1011; v -2,-6   (case -2)

        //{1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},               // 1011 1100; v -0,-1,-6(case -6)
        {1, 3, 10, 10, 3, 6, 3, 8, 6, 5, 6, 8, 8, 9, 5, -1},                // 1011 1100; v -0,-1,-6(case -6)

        //{10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},           // 1011 1101; v -1,-6   (case -3)
        {-3, 0, 9, 5, 6, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1101; v -1,-6   (case -3)

        {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1110; v -0,-6   (case -4)
        {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1011 1111; v -6      (case -1)
        {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1100 0000; v 6,7     (case 2)
        {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},         // 1100 0001; v 0,6,7   (case 6)
        {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},         // 1100 0010; v 1,6,7   (case 6)
        {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},            // 1100 0011; v 0,1,6,7 (case 10)

        //{11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},        // 1100 0100; v 2,6,7   (case 5)
        {-5, 5, 1, 2, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 0100; v 2,6,7   (case 5b)

        //{0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},            // 1100 0101; v 0,2,6,7 (case 12)
        {-12, 5, 1, 2, 11, 7, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},         // 1100 0101; v 0,2,6,7 (case 12b)

        //{9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},            // 1100 0110; v 1,2,6,7 (case 14)
        //{-14, 11, 7, 5, 9, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1100 0110; v 1,2,6,7 (case 14b)
        //{9, 0, 2, 9, 2, 5, 5, 2, 11, 5, 11, 7, -1, -1, -1, -1},           // 1100 0110; v 1,2,6,7 (case 14)
        {-14, 11, 7, 5, 9, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 0110; v 1,2,6,7 (case 14c)

        //{7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},               // 1100 0111; v -3,-4,-5(case -6)
        {7, 5, 11, 11, 5, 2, 5, 9, 2, 3, 2, 9, 9, 8, 3, -1},                // 1100 0111; v -3,-4,-5(case -6)

        //{2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},         // 1100 1000; v 3,6,7   (case 5)
        {-5, 7, 5, 10, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 1000; v 3,6,7   (case 5b)

        //{8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},            // 1100 1001; v 0,3,6,7 (case 11)
        //{-11, 10, 2, 0, 8, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1100 1001; v 0,3,6,7 (case 11b)
        //{10, 7, 5, 10, 2, 7, 2, 8, 7, 2, 0, 8, -1, -1, -1, -1},           // 1100 1001; v 0,3,6,7 (case 11)
        {-11, 10, 2, 0, 8, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 1001; v 0,3,6,7 (case 11c)

        //{9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},           // 1100 1010; v 1,3,6,7 (case 12)
        {-12, 7, 5, 10, 2, 3, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},         // 1100 1010; v 1,3,6,7 (case 12b)

        //{9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},               // 1100 1011; v -2,-4,-5(case -6)
        {9, 8, 1, 1, 8, 2, 8, 7, 2, 10, 2, 7, 7, 5, 10, -1},                // 1100 1011; v -2,-4,-5(case -6)

        {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1100 1100; v 2,3,6,7 (case 8)

        //{0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},          // 1100 1101; v -1,-4,-5(case -5)
        {-5, 5, 1, 0, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1100 1101; v -1,-4,-5(case -5b)

        //{9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},          // 1100 1110; v -0,-4,-5(case -5)
        {-5, 7, 5, 9, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1100 1110; v -0,-4,-5(case -5b)

        {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1100 1111; v -4,-5   (case -2)

        //{5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},       // 1101 0000; v 4,6,7   (case 5)
        {-5, 11, 8, 4, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1101 0000; v 4,6,7   (case 5b)

        //{5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},         // 1101 0001; v 0,4,6,7 (case 14)
        //{-14, 3, 0, 4, 5, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 1101 0001; v 0,4,6,7 (case 14b)
        //{5, 10, 11, 5, 11, 4, 4, 11, 3, 4, 3, 0, -1, -1, -1, -1},         // 1101 0001; v 0,4,6,7 (case 14)
        {-14, 3, 0, 4, 5, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1101 0001; v 0,4,6,7 (case 14c)

        //{0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},         // 1101 0010; v 1,4,6,7 (case 12)
        {-12, 11, 8, 4, 5, 10, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},        // 1101 0010; v 1,4,6,7 (case 12b)

        //{10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},            // 1101 0011; v -2,-3,-5(case -6)
        {10, 11, 5, 5, 11, 4, 11, 3, 4, 9, 4, 3, 3, 1, 9, -1},              // 1101 0011; v -2,-3,-5(case -6)

        //{2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},            // 1101 0100; v 2,4,6,7 (case 11)
        //{-11, 4, 5, 1, 2, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1101 0100; v 2,4,6,7 (case 11b)
        //{4, 11, 8, 4, 5, 11, 5, 2, 11, 5, 1, 2, -1, -1, -1, -1},          // 1101 0100; v 2,4,6,7 (case 11)
        {-11, 4, 5, 1, 2, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1101 0100; v 2,4,6,7 (case 11c)

        //{0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},           // 1101 0101; v -1,-3,-5(case -6)
        {0, 4, 3, 3, 4, 11, 4, 5, 11, 2, 11, 5, 5, 1, 2, -1},               // 1101 0101; v -1,-3,-5(case -6)

        //{0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},              // 1101 0110; v -0,-3,-5(case -6)
        {0, 2, 9, 9, 2, 5, 2, 11, 5, 4, 5, 11, 11, 8, 4, -1},               // 1101 0110; v -0,-3,-5(case -6)

        {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 0111; v -3,-5   (case -4)

        //{2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},            // 1101 1000; v 3,4,6,7 (case 9)
        {-9, 5, 10, 2, 3, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 1000; v 3,4,6,7 (case 9b)

        //{5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},         // 1101 1001; v -1,-2,-5(case -5)
        {-5, 0, 4, 5, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1101 1001; v -1,-2,-5(case -5b)

        //{3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},              // 1101 1010; v -0,-2,-5(case -7)
        {-7, 5, 10, 2, 3, 8, 4, 1, 9, 0, -1, -1, -1, -1, -1, -1},           // 1101 1010; v -0,-2,-5(case -7)

        //{5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},            // 1101 1011; v -2,-5   (case -3)
        {-3, 2, 1, 9, 4, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 1011; v -2,-5   (case -3)

        //{8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},          // 1101 1100; v -0,-1,-5(case -5)
        {-5, 1, 3, 8, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 1100; v -0,-1,-5(case -5b)

        {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1101 1101; v -1,-5   (case -2)

        //{8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},             // 1101 1110; v -0,-5   (case -3)
        {-3, 5, 9, 0, 3, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1101 1110; v -0,-5   (case -3)

        {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1101 1111; v -5      (case -1)

        //{4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},      // 1110 0000; v 5,6,7   (case 5)
        {-5, 10, 11, 7, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1110 0000; v 5,6,7   (case 5b)

        //{0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},          // 1110 0001; v 0,5,6,7 (case 12)
        {-12, 10, 11, 7, 4, 9, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},        // 1110 0001; v 0,5,6,7 (case 12b)

        //{1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},         // 1110 0010; v 1,5,6,7 (case 11)
        //{-11, 7, 4, 0, 1, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 1110 0010; v 1,5,6,7 (case 11b)
        //{7, 10, 11, 7, 4, 10, 4, 1, 10, 4, 0, 1, -1, -1, -1, -1},         // 1110 0010; v 1,5,6,7 (case 11)
        {-11, 7, 4, 0, 1, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1110 0010; v 1,5,6,7 (case 11c)

        //{3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},            // 1110 0011; v -2,-3,-4(case -6)
        {3, 1, 8, 8, 1, 4, 1, 10, 4, 7, 4, 10, 10, 11, 7, -1},              // 1110 0011; v -2,-3,-4(case -6)

        //{4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},          // 1110 0100; v 2,5,6,7 (case 9)
        {-9, 11, 7, 4, 9, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 0100; v 2,5,6,7 (case 9b)

        //{9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},             // 1110 0101; v -1,-3,-4(case -7)
        {-7, 9, 1, 2, 11, 7, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1},           // 1110 0101; v -1,-3,-4(case -7)

        //{11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},        // 1110 0110; v -0,-3,-4(case -5)
        {-5, 0, 2, 11, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1110 0110; v -0,-3,-4(case -5b)

        //{11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},           // 1110 0111; v -3,-4   (case -3)
        {-3, 4, 8, 3, 2, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 0111; v -3,-4   (case -3)

        //{2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},            // 1110 1000; v 3,5,6,7 (case 14)
        //{-14, 4, 9, 10, 2, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1110 1000; v 3,5,6,7 (case 14b)
        //{2, 3, 7, 2, 7, 10, 10, 7, 4, 10, 4, 9, -1, -1, -1, -1},          // 1110 1000; v 3,5,6,7 (case 14)
        {-14, 4, 9, 10, 2, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1110 1000; v 3,5,6,7 (case 14c)

        //{9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},              // 1110 1001; v -1,-2,-4(case -6)
        {9, 10, 4, 4, 10, 7, 10, 2, 7, 8, 7, 2, 2, 0, 8, -1},               // 1110 1001; v -1,-2,-4(case -6)

        //{3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},           // 1110 1010; v -0,-2,-4(case -6)
        {3, 7, 2, 2, 7, 10, 7, 4, 10, 1, 10, 4, 4, 0, 1, -1},               // 1110 1010; v -0,-2,-4(case -6)

        {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 1011; v -2,-4   (case -4)

        //{4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},          // 1110 1100; v -0,-1,-4(case -5)
        {-5, 3, 7, 4, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 1100; v -0,-1,-4(case -5b)

        //{4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},             // 1110 1101; v -1,-4   (case -3)
        {-3, 1, 0, 8, 7, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1110 1101; v -1,-4   (case -3)

        {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1110 1110; v -0,-4   (case -2)
        {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1110 1111; v -4      (case -1)
        {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0000; v 4,5,6,7 (case 8)

        //{3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},       // 1111 0001; v -1,-2,-3(case -5)
        {-5, 10, 11, 3, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0001; v -1,-2,-3(case -5b)

        //{0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},      // 1111 0010; v -0,-2,-3(case -5)
        {-5, 11, 8, 0, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0010; v -0,-2,-3(case -5b)

        {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0011; v -2,-3   (case -2)

        //{1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},       // 1111 0100; v -0,-1,-3(case -5)
        {-5, 8, 9, 1, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1111 0100; v -0,-1,-3(case -5b)

        //{3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},           // 1111 0101; v -1,-3   (case -3)
        {-3, 9, 1, 2, 11, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1111 0101; v -1,-3   (case -3)

        {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1111 0110; v -0,-3   (case -2)
        {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1111 0111; v -3      (case -1)

        //{2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},        // 1111 1000; v -0,-1,-2(case -5)
        {-5, 9, 10, 2, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1111 1000; v -0,-1,-2(case -5b)

        {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1111 1001; v -1,-2   (case -2)

        //{2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},           // 1111 1010; v -0,-2   (case -3)
        {-3, 8, 0, 1, 10, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1111 1010; v -0,-2   (case -3)

        {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1111 1011; v -2      (case -1)
        {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1111 1100; v -0,-1   (case -2)
        {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 1101; v -1      (case -1)
        {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 1110; v -0      (case -1)
        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}    // 1111 1111; all       (case 0)
    };
    //*/

    template <class T>
    NonobtuseMC<T>::NonobtuseMC()
        : IsoSurface<T>::IsoSurface(),
        iAllTableIndex(NULL)
    {
    }

    template <class T>
    NonobtuseMC<T>::~NonobtuseMC()
    {
        this->deleteSurface();
    }

    template <class T>
    void NonobtuseMC<T>::generateSurface(
            const T* scalarField,
            const std::vector<LineMeshIntType>* xIntPtList,
            const std::vector<LineMeshIntType>* yIntPtList,
            const std::vector<LineMeshIntType>* zIntPtList,
            double xOffsets,
            double yOffsets,
            double zOffsets,
            T isoLevel,
            uint cellsX,
            uint cellsY,
            uint cellsZ,
            double cellLengthX,
            double cellLengthY,
            double cellLengthZ,
            uint surfaceType,
            const std::vector<Triangle>& ignoreCubes)
    {
        if(this->iValidSurface)
        {
            this->deleteSurface();
        }
        this->iCellsX = cellsX;
        this->iCellsY = cellsY;
        this->iCellsZ = cellsZ;
        this->iCellLengthX = cellLengthX;
        this->iCellLengthY = cellLengthY;
        this->iCellLengthZ = cellLengthZ;
        this->iScalarField = scalarField;
        this->iIsoLevel = isoLevel;
    
        this->iIntPtList[0] = xIntPtList;
        this->iIntPtList[1] = yIntPtList;
        this->iIntPtList[2] = zIntPtList;
        this->iOffsets[0] = xOffsets;
        this->iOffsets[1] = yOffsets;
        this->iOffsets[2] = zOffsets;

        uint ptsIxDir = this->iCellsX + 1;
        uint ptsInSlice = ptsIxDir*(this->iCellsY + 1);
        this->iAllTableIndex = new uint[cellsX * cellsY * cellsZ];
        uint currentIgnoreCubeIdx = 0;

        // Generate isosurface.
        for(uint z = 0; z < this->iCellsZ; ++z)
        {
            for(uint y = 0; y < this->iCellsY; ++y)
            {
                for(uint x = 0; x < this->iCellsX; ++x)
                {
                    // first check if the cube intersects any of the triangles in exceptTriList
                    // if so, make sure we don't triangulate the cube
                    bool intersects(false);
                    if((ignoreCubes.size() > currentIgnoreCubeIdx) && 
                        (ignoreCubes[currentIgnoreCubeIdx].x == x) &&
                        (ignoreCubes[currentIgnoreCubeIdx].y == y) &&
                        (ignoreCubes[currentIgnoreCubeIdx].z == z))
                    {
                        intersects = true;
                        ++currentIgnoreCubeIdx;
                    }
                    // Calculate table lookup index from those vertices which are below the isolevel.
                    uint tableIndex = 0;
                    //    1----2
                    //   /|  / |
                    // 5----6  |
                    // | /0-|--3
                    // |/   |/
                    // 4----7
                    if(this->iScalarField[z * ptsInSlice + y * ptsIxDir + x] < this->iIsoLevel)
                    {
                        tableIndex |= 1;
                    }
                    if(this->iScalarField[z * ptsInSlice + (y + 1) * ptsIxDir + x] < this->iIsoLevel)
                    {
                        tableIndex |= 2;
                    }
                    if(this->iScalarField[z * ptsInSlice + (y + 1) * ptsIxDir + (x + 1)] < this->iIsoLevel)
                    {
                        tableIndex |= 4;
                    }
                    if(this->iScalarField[z * ptsInSlice + y * ptsIxDir + (x + 1)] < this->iIsoLevel)
                    {
                        tableIndex |= 8;
                    }
                    if(this->iScalarField[(z + 1) * ptsInSlice + y * ptsIxDir + x] < this->iIsoLevel)
                    {
                        tableIndex |= 16;
                    }
                    if(this->iScalarField[(z + 1) * ptsInSlice + (y + 1) * ptsIxDir + x] < this->iIsoLevel)
                    {
                        tableIndex |= 32;
                    }
                    if(this->iScalarField[(z + 1) * ptsInSlice + (y + 1) * ptsIxDir + (x + 1)] < this->iIsoLevel)
                    {
                        tableIndex |= 64;
                    }
                    if(this->iScalarField[(z + 1) * ptsInSlice + y * ptsIxDir + (x + 1)] < this->iIsoLevel)
                    {
                        tableIndex |= 128;
                    }
                
                    this->iAllTableIndex[z * cellsX * cellsY + y * cellsX + x] = tableIndex;
                    
                    // Now create a triangulation of the isosurface in this cell.
                    if(this->iEdgeTable[tableIndex] != 0)
                    {
                        if(this->iEdgeTable[tableIndex] & 8)
                        {
                            Point3dId pt = this->calculateIntersection(x, y, z, 3, surfaceType);
                            pt.iId = 0;
                            uint id = this->getEdgeId(x, y, z, 3);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                        }
                        if(this->iEdgeTable[tableIndex] & 1)
                        {
                            Point3dId pt = this->calculateIntersection(x, y, z, 0, surfaceType);
                            pt.iId = 0;
                            uint id = this->getEdgeId(x, y, z, 0);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                        }
                        if(this->iEdgeTable[tableIndex] & 256)
                        {
                            Point3dId pt = this->calculateIntersection(x, y, z, 8, surfaceType);
                            pt.iId = 0;
                            uint id = this->getEdgeId(x, y, z, 8);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                        }

                        if(x == this->iCellsX - 1)
                        {
                            if(this->iEdgeTable[tableIndex] & 4)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 2, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 2);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                            if(this->iEdgeTable[tableIndex] & 2048)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 11, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 11);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                        }
                        if(y == this->iCellsY - 1)
                        {
                            if(this->iEdgeTable[tableIndex] & 2)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 1, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 1);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                            if(this->iEdgeTable[tableIndex] & 512)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 9, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 9);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                        }
                        if(z == this->iCellsZ - 1)
                        {
                            if(this->iEdgeTable[tableIndex] & 16)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 4, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 4);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                            if(this->iEdgeTable[tableIndex] & 128)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 7, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 7);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                        }
                        if((x == this->iCellsX - 1) && (y == this->iCellsY - 1))
                        {
                            if(this->iEdgeTable[tableIndex] & 1024)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 10, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 10);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                        }
                        if((x == this->iCellsX - 1) && (z == this->iCellsZ - 1))
                        {
                            if(this->iEdgeTable[tableIndex] & 64)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 6, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 6);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                        }
                        if((y == this->iCellsY - 1) && (z == this->iCellsZ - 1))
                        {
                            if(this->iEdgeTable[tableIndex] & 32)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 5, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 5);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                        }

                        if(intersects)
                        {
                            continue;
                        }
                        else if(this->iTriTable[tableIndex][0] == -3)
                        {
                            // -3:    Special Case -3
                            // {-3, a, b, c, d, e, f, -1, ... }
                            // where a,b,c,d forms a quad, and d,e,f,a forms the other quad
                            // The right hand ordering determines the normals
                            // A new point m should be added to the midpoint of a,d
                            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
                        
                            // get point a, d
                            Point3dId pta;
                            Point3dId ptd;
                            if(surfaceType == NONOBTUSE_INTERPOLATE)
                            {
                                pta = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], MIDPOINT);
                                ptd = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], MIDPOINT);
                            }
                            else
                            {
                                pta = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], surfaceType);
                                ptd = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], surfaceType);
                            }

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (pta.iPt + ptd.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 18);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
                        
                            // create triangles
                            for(uint i = 1; i <= 6; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i%6 + 1]);
                                pointId2 = this->getEdgeId(x, y, z, 18);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        else if(this->iTriTable[tableIndex][0] == -5)
                        {
                            // -5:  Special Case 5b
                            // {-5, a, b, c, d, e, -1, ... }
                            // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
                            // The right hand ordering determins the normals
                            // A new point m should be added to the midpoint of b,e
                            // Then, the 5 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, -1}

                            // get point b, e
                            Point3dId ptb;
                            Point3dId pte;
                            if(surfaceType == NONOBTUSE_INTERPOLATE)
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                            }
                            else
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
                            }

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 12);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
            
                            // create triangles
                            for(uint i = 1; i <= 5; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 5 + 1]);
                                pointId2 = this->getEdgeId(x, y, z, 12);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        else if(this->iTriTable[tableIndex][0] == -7)
                        {
                            // -7:  Special Case -7
                            // {-7, a, b, c, d, e, f, i, j, k, -1, ... }
                            // where a,b,c,d,e,f forms a hexagon and i,j,k forms a triangle
                            // The right hand ordering determines the normals
                            // A new point m should be added to the centroid of a,b,c,d,e,f
                            // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, i, j, k, -1}
                        
                        
                            // get point b, e
                            Point3dId ptb;
                            Point3dId pte;
                            if(surfaceType == NONOBTUSE_INTERPOLATE)
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                            }
                            else
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
                            }

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 17);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                            // create triangles
                            for(uint i = 1; i <= 7; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                if(i == 7)
                                {
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 2]);
                                }
                                else
                                {
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, 17);
                                }
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        else if(this->iTriTable[tableIndex][0] == -9)
                        {
                            // -9:  Special Case 9b
                            // {-9, a, b, c, d, e, f, -1, ... }
                            // where a,b,c,d,e,f forms a hexagon.
                            // The right hand ordering determines the normals
                            // A new point m should be added to the centroid of a,b,c,d,e,f
                            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                            // get point b, e
                            Point3dId ptb;
                            Point3dId pte;
                            if(surfaceType == NONOBTUSE_INTERPOLATE)
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                            }
                            else
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
                            }

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 13);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                            // create triangles
                            for(uint i = 1; i <= 6; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                pointId2 = this->getEdgeId(x, y, z, 13);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        /*
                        else if(this->iTriTable[tableIndex][0] == -11)
                        {
                            // -11: Special Case 11b    *** OBSOLETE ***
                            // {-11, a, b, c, d, e, f, -1, ... ]
                            // where a,b,f forms the triangle that has degree 120 at angle(fab)
                            //       b,c,d and d,e,f forms the 2 triangles that have right angle
                            //       b,d,f forms the equilateral triangle
                            // The right hand ordering determines the normals
                            // A new point m should be added to the midpoint of b,f
                            // Then, the 6 new triangles are {a, b, m, b, d, m, c, d, b, d, f, m, e, f, d, f, a, m, -1}

                            // get point b, f
                            Point3dId ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                            Point3dId ptf = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][6], surfaceType);

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (ptb.iPt + ptf.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 14);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                            // create triangles
                            for(uint i = 1; i <= 6; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                uint idx2 = 0, idx3 = 0;
                                switch(i)
                                {
                                case 1:
                                    idx2 = this->iTriTable[tableIndex][2];
                                    idx3 = 14;
                                    break;
                                case 2:
                                    idx2 = this->iTriTable[tableIndex][4];
                                    idx3 = 14;
                                    break;
                                case 3:
                                    idx2 = this->iTriTable[tableIndex][4];
                                    idx3 = this->iTriTable[tableIndex][2];
                                    break;
                                case 4:
                                    idx2 = this->iTriTable[tableIndex][6];
                                    idx3 = 14;
                                    break;
                                case 5:
                                    idx2 = this->iTriTable[tableIndex][6];
                                    idx3 = this->iTriTable[tableIndex][4];
                                    break;
                                case 6:
                                    idx2 = this->iTriTable[tableIndex][1];
                                    idx3 = 14;
                                    break;
                                }
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, idx2);
                                pointId2 = this->getEdgeId(x, y, z, idx3);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        */
                        else if(this->iTriTable[tableIndex][0] == -11)    
                        {
                            // -11: Special Case 11c
                            // {-11, a, b, c, d, e, f, -1, ... ]
                            // where a,b,c,d,e,f forms a bent hexagon.
                            //       new point m is added in the center of the cube
                            //       b,c,m and e,f,m are right isoscele triangles
                            //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
                            // The right hand ordering determines the normals
                            // A new point m should be added to the center of cube (ie. midpoint of a and d)
                            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                            // get point a, d
                            Point3dId pta = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], surfaceType);
                            Point3dId ptd = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], surfaceType);

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (pta.iPt + ptd.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 14);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                            // create triangles
                            for(uint i = 1; i <= 6; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i%6 + 1]);
                                pointId2 = this->getEdgeId(x, y, z, 14);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        else if(this->iTriTable[tableIndex][0] == -12)
                        {
                            // -12: Special Case 12b
                            // {-12, a, b, c, d, e, i, j, k, -1, ... }
                            // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
                            //       and i, j, k forms a seperate triangle
                            // The right hand ordering determines the normals
                            // A new point m should be added to the midpoint of b,e
                            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, a, m, i, j, k, -1}

                            // get point b, e
                            Point3dId ptb;
                            Point3dId pte;
                            if(surfaceType == NONOBTUSE_INTERPOLATE)
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                            }
                            else
                            {
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
                            }

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 15);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                            // create triangles
                            for(uint i = 1; i <= 6; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                uint idx2 = this->iTriTable[tableIndex][i % 5 + 1];
                                uint idx3 = 15;
                                if(i == 6)
                                {
                                    idx2 = this->iTriTable[tableIndex][i+1];
                                    idx3 = this->iTriTable[tableIndex][i+2];
                                }
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, idx2);
                                pointId2 = this->getEdgeId(x, y, z, idx3);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        /*
                        else if(this->iTriTable[tableIndex][0] == -14)
                        {
                            // -14: Special Case 14b    *** OBSOLETE ***
                            // {-14, a, b, c, d, e, f, -1, ... ]
                            // where a,b,f forms the triangle that has degree 120 at angle(fab)
                            //       b,c,d and d,e,f forms the 2 triangles that have right angle
                            //       b,d,f forms the equilateral triangle                          
                            // The right hand ordering determines the normals
                            // A new point m should be added to the midpoint of b,f
                            // Then, the 6 new triangles are {a, b, m, b, d, m, c, d, b, d, f, m, e, f, d, f, a, m, -1}

                            // get point b, f
                            Point3dId ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                            Point3dId ptf = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][6], surfaceType);

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (ptb.iPt + ptf.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 16);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                            // create triangles
                            for(uint i = 1; i <= 6; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                uint idx2 = 0, idx3 = 0;
                                switch(i)
                                {
                                case 1:
                                    idx2 = this->iTriTable[tableIndex][2];
                                    idx3 = 16;
                                    break;
                                case 2:
                                    idx2 = this->iTriTable[tableIndex][4];
                                    idx3 = 16;
                                    break;
                                case 3:
                                    idx2 = this->iTriTable[tableIndex][4];
                                    idx3 = this->iTriTable[tableIndex][2];
                                    break;
                                case 4:
                                    idx2 = this->iTriTable[tableIndex][6];
                                    idx3 = 16;
                                    break;
                                case 5:
                                    idx2 = this->iTriTable[tableIndex][6];
                                    idx3 = this->iTriTable[tableIndex][4];
                                    break;
                                case 6:
                                    idx2 = this->iTriTable[tableIndex][1];
                                    idx3 = 16;
                                    break;
                                }
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, idx2);
                                pointId2 = this->getEdgeId(x, y, z, idx3);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        */
                        else if(this->iTriTable[tableIndex][0] == -14)    
                        {
                            // -14: Special Case 14c
                            // {-14, a, b, c, d, e, f, -1, ... ]
                            // where a,b,c,d,e,f forms a bent hexagon.
                            //       new point m is added in the center of the cube
                            //       b,c,m and e,f,m are right isoscele triangles
                            //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
                            // The right hand ordering determines the normals
                            // A new point m should be added to the center of cube (ie. midpoint of a and d)
                            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                            // get point a, d
                            Point3dId pta = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], surfaceType);
                            Point3dId ptd = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], surfaceType);

                            // calculate midpoint m
                            Point3dId ptm;
                            ptm.iId = 0;
                            ptm.iPt = (pta.iPt + ptd.iPt) * 0.5;

                            // add vertex m
                            uint id = this->getEdgeId(x, y, z, 16);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                            // create triangles
                            for(uint i = 1; i <= 6; ++i)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                pointId2 = this->getEdgeId(x, y, z, 16);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                        else
                        {
                            for(uint i = 0; this->iTriTable[tableIndex][i] != -1; i += 3)
                            {
                                Triangle triangle;
                                uint pointId0, pointId1, pointId2;
                                pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 1]);
                                pointId2 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 2]);
                                triangle.x = pointId0;
                                triangle.y = pointId1;
                                triangle.z = pointId2;
                                this->iTriangleVec.push_back(triangle);
                            }
                        }
                    }
                }
            }
        }

        this->renameVerticesAndTriangles();
        this->calculateNormals();
        this->iValidSurface = true;
    
        delete [] this->iAllTableIndex;
        this->iAllTableIndex = NULL;
    }

    // Generates the isosurface from the scalar field contained in the file scalarFieldFileName
    // Modified from the base class to give nonobtuse marching cube
    // return value (out): true if success
    template <class T>
    bool NonobtuseMC<T>::generateSurface(const char* scalarFieldFileName, T isoLevel, uint surfaceType)
    {
        if(this->iValidSurface)
        {
            this->deleteSurface();
        }
    
        std::ifstream inFile;
        inFile.open(scalarFieldFileName, std::ifstream::in);
    
        if(!inFile.is_open())
        {
            return false;
        }
    
        // get scalar field properties
        uint numScalars(0);
        uint cellsX;
        uint cellsY;
        uint cellsZ;
        double cellLengthX;
        double cellLengthY;
        double cellLengthZ;
        double xOffsets;
        double yOffsets;
        double zOffsets;
        if(inFile.good())
        {
            char tmp[16];
            inFile >> tmp;
            inFile >> numScalars;
        
            inFile >> tmp;
            inFile >> cellsX;
            inFile >> tmp;
            inFile >> cellsY;
            inFile >> tmp;
            inFile >> cellsZ;
        
            inFile >> tmp;
            inFile >> cellLengthX;
            inFile >> tmp;
            inFile >> cellLengthY;
            inFile >> tmp;
            inFile >> cellLengthZ;
        
            inFile >> tmp;
            inFile >> xOffsets;
            inFile >> tmp;
            inFile >> yOffsets;
            inFile >> tmp;
            inFile >> zOffsets;
        }
        else
        {
            return false;
        }

        std::vector<cv::Point3d> exceptTriList;
        uint numExceptTri = 0;
        std::vector<Triangle> ignoreCubes;
        if(inFile.good())
        {
            char tmp[16];
            inFile >> tmp;
            inFile >> numExceptTri;
            if(numExceptTri > 0)
            {
                cv::Point3d point;
                for(uint i = 0; i < numExceptTri; ++i)
                {
                    for(uint j = 0; j < 3; ++j)
                    {
                        inFile >> point.x;
                        inFile >> point.y;
                        inFile >> point.z;
                        exceptTriList.push_back(point);
                    }
                }
                // --- get cubes to ignore
                this->getIgnoreCubes(
                    cellsX, cellsY, cellsZ,
                    cellLengthX, cellLengthY, cellLengthZ,
                    xOffsets, yOffsets, zOffsets,
                    exceptTriList, numExceptTri, ignoreCubes);
            }
        }
        else
        {
            return false;
        }
    
        // get scalar field
        T* scalarField = new T[numScalars];
        for(uint i = 0; i < numScalars && inFile.good(); ++i)
        {    
            inFile >> scalarField[i];
        }
    
        // get intersecting points from x rays
        uint numXRays = (cellsY + 1) * (cellsZ + 1);
        std::vector<LineMeshIntType>* xIntPtList = new std::vector<LineMeshIntType>[numXRays];
        for(uint i = 0; i < numXRays && inFile.good(); ++i)
        {
            uint numIntPts;
            inFile >> numIntPts;
            for(uint j = 0; j < numIntPts && inFile.good(); ++j)
            {
                LineMeshIntType intPt;
                inFile >> intPt.iIntType;
                inFile >> intPt.iPt.x;
                inFile >> intPt.iPt.y;
                inFile >> intPt.iPt.z;
                xIntPtList[i].push_back(intPt);
            }
        }
    
        // get intersecting points from y rays
        uint numYRays = (cellsX + 1) * (cellsZ + 1);
        std::vector<LineMeshIntType>* yIntPtList = new std::vector<LineMeshIntType>[numYRays];
        for(uint i = 0; i < numYRays && inFile.good(); ++i)
        {
            uint numIntPts;
            inFile >> numIntPts;
            for(uint j = 0; j < numIntPts && inFile.good(); ++j)
            {
                LineMeshIntType intPt;
                inFile >> intPt.iIntType;
                inFile >> intPt.iPt.x;
                inFile >> intPt.iPt.y;
                inFile >> intPt.iPt.z;
                yIntPtList[i].push_back(intPt);
            }
        }
    
        // get intersecting points from z rays
        uint numZRays = (cellsX + 1) * (cellsY + 1);
        std::vector<LineMeshIntType>* zIntPtList = new std::vector<LineMeshIntType>[numZRays];
        for(uint i = 0; i < numZRays && inFile.good(); ++i)
        {
            uint numIntPts;
            inFile >> numIntPts;
            for(uint j = 0; j < numIntPts && inFile.good(); ++j)
            {
                LineMeshIntType intPt;
                inFile >> intPt.iIntType;
                inFile >> intPt.iPt.x;
                inFile >> intPt.iPt.y;
                inFile >> intPt.iPt.z;
                zIntPtList[i].push_back(intPt);
            }
        }
    
        this->generateSurface(
            scalarField,
            xIntPtList, yIntPtList, zIntPtList,
            xOffsets, yOffsets, zOffsets,
            isoLevel,
            cellsX, cellsY, cellsZ,
            cellLengthX, cellLengthY, cellLengthZ,
            surfaceType,
            ignoreCubes);
    
        // TODO: commenting this statement is for debug only, uncomment afterwards.
        //delete[] scalarField;
        delete [] xIntPtList;
        delete [] yIntPtList;
        delete [] zIntPtList;
    
        inFile.close();
        std::cout << "\nScalar field successfully loaded from: " << scalarFieldFileName << std::endl;
    
        return true;
    }

    // given a list of triangles, return a list of cubes that intersects these triangles
    template <class T>
    void NonobtuseMC<T>::getIgnoreCubes(
        uint cellsX,
        uint cellsY,
        uint cellsZ,
        double cellLengthX,
        double cellLengthY,
        double cellLengthZ,
        double xOffsets,
        double yOffsets,
        double zOffsets,
        const std::vector<cv::Point3d>& exceptTriList,
        uint numExceptTri, 
        std::vector<Triangle>& ignoreCubes)
    {
        for(uint i = 0; i < numExceptTri; ++i)
        {
            cv::Point3d point = exceptTriList[3 * i];
            // find min x, y, z and max x, y, z
            double minx = point.x;
            double maxx = point.x;
            double miny = point.y;
            double maxy = point.y;
            double minz = point.z;
            double maxz = point.z;

            point = exceptTriList[3 * i + 1];
            if(minx > point.x) minx = point.x;
            if(maxx < point.x) maxx = point.x;
            if(miny > point.y) miny = point.y;
            if(maxy < point.y) maxy = point.y;
            if(minz > point.z) minz = point.z;
            if(maxz < point.z) maxz = point.z;
            
            point = exceptTriList[3 * i + 2];
            if(minx > point.x) minx = point.x;
            if(maxx < point.x) maxx = point.x;
            if(miny > point.y) miny = point.y;
            if(maxy < point.y) maxy = point.y;
            if(minz > point.z) minz = point.z;
            if(maxz < point.z) maxz = point.z;

            uint mixCube = (uint)floor((minx - xOffsets) / cellLengthX);
            uint maxXCube = (uint)ceil((maxx - xOffsets) / cellLengthX);
            uint miyCube = (uint)floor((miny - yOffsets) / cellLengthY);
            uint maxYCube = (uint)ceil((maxy - yOffsets) / cellLengthY);
            uint mizCube = (uint)floor((minz - zOffsets) / cellLengthZ);
            uint maxZCube = (uint)ceil((maxz - zOffsets) / cellLengthZ);

            cv::Point3d boxHalfSize(cellLengthX / 2, cellLengthY / 2, cellLengthZ / 2);
            for(uint z = mizCube; z < maxZCube; ++z)
            {
                for(uint y = miyCube; y < maxYCube; ++y)
                {
                    for(uint x = mixCube; x < maxXCube; ++x)
                    {
                        bool intersects = false;
                        cv::Point3d boxCenter(x * cellLengthX + boxHalfSize.x, y * cellLengthY + boxHalfSize.y, z * cellLengthZ + boxHalfSize.z);
                        cv::Point3d triVerts[3];
                        cv::Point3d point = exceptTriList[3 * i];
                        triVerts[0] = cv::Point3d(point.x - xOffsets, point.y - yOffsets, point.z - zOffsets);
                        point = exceptTriList[3 * i + 1];
                        triVerts[1] = cv::Point3d(point.x - xOffsets, point.y - yOffsets, point.z - zOffsets);
                        point = exceptTriList[3 * i + 2];
                        triVerts[2] = cv::Point3d(point.x - xOffsets, point.y - yOffsets, point.z - zOffsets);
                        intersects = (TriBox::triBoxOverlap(boxCenter, boxHalfSize, triVerts) == 1);
                        if(intersects)
                        {
                            Triangle cubeIdx(x, y, z);
                            if(ignoreCubes.size() == 0)
                            {
                                ignoreCubes.push_back(cubeIdx);
                            }
                            else
                            {
                                std::vector<Triangle>::iterator iter;
                                for(iter = ignoreCubes.begin(); iter != ignoreCubes.end(); iter++)
                                {
                                    if((iter->x == cubeIdx.x) &&
                                        (iter->y == cubeIdx.y) &&
                                        (iter->z == cubeIdx.z))
                                    {
                                        break;
                                    }
                                    else if(iter->z > cubeIdx.z)
                                    {
                                        ignoreCubes.insert(iter, cubeIdx);
                                        break;
                                    }
                                    else if((iter->z == cubeIdx.z) && (iter->y > cubeIdx.y))
                                    {
                                        ignoreCubes.insert(iter, cubeIdx);
                                        break;
                                    }
                                    else if((iter->z == cubeIdx.z) && (iter->y == cubeIdx.y) && (iter->x > cubeIdx.x))
                                    {
                                        ignoreCubes.insert(iter, cubeIdx);
                                        break;
                                    }
                                }
                                if(iter == ignoreCubes.end())
                                {
                                    ignoreCubes.push_back(cubeIdx);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // unused vertices are moved to end of array;
    template <class T>
    void NonobtuseMC<T>::renameVerticesAndTriangles()
    {
        uint nextId = 0;
        std::vector<uint> pointIdList;
        // Rename vertices.
        this->iVertices.clear();
        for(Id2Point3dId::iterator mapIter = this->iId2Point3dId.begin(); mapIter != this->iId2Point3dId.end(); ++mapIter)
        {
            this->iVertices.push_back(mapIter->second.iPt);
            // keep a list of pointID; used for removing unused vertices
            pointIdList.push_back(nextId);
            mapIter->second.iId = nextId;
            ++nextId;
        }
        // Now rename triangles.
        std::vector<uint>* point2Tri = new std::vector<uint>[this->iVertices.size()];
        std::vector<uint>::iterator end = pointIdList.end();
        std::vector<uint>::iterator last = end;
        Triangle triangle;
        this->iTriangleIndices.clear();
        uint i = 0;
        for(TriangleVec::iterator triIter = this->iTriangleVec.begin(); triIter != this->iTriangleVec.end(); ++triIter)
        {
            triangle.x = this->iId2Point3dId[triIter->x].iId;
            triangle.y = this->iId2Point3dId[triIter->y].iId;
            triangle.z = this->iId2Point3dId[triIter->z].iId;
            this->iTriangleIndices.push_back(triangle);
            // add reference for point to triangle
            point2Tri[triangle.x].push_back(i);
            point2Tri[triangle.y].push_back(i);
            point2Tri[triangle.z].push_back(i);
            // remove referenced points from pointIdList
            last = std::remove(pointIdList.begin(), last, triangle.x);
            last = std::remove(pointIdList.begin(), last, triangle.y);
            last = std::remove(pointIdList.begin(), last, triangle.z);
            ++i;
        }
        // remove unreference vertices
        uint numValidPts = end - last;
        uint numUnusedPts = this->iVertices.size() - numValidPts;
        uint numNoVertices = this->iVertices.size();
        for(uint i = 0; i < numUnusedPts; ++i)
        {
            uint vIdx = pointIdList[i];
            uint lastVIdx = numNoVertices - 1;
            // make sure lastVIdx is a valid vertex
            for(uint j = i; j < numUnusedPts; ++j)
            {
                if(pointIdList[j] == lastVIdx)
                {
                    --lastVIdx;
                    break;
                }
            }
            if(vIdx < lastVIdx)
            {
                // swap position with the last vertex
                std::swap(this->iVertices[vIdx], this->iVertices[lastVIdx]);
                // swap vertex-neighbour relationship
                std::swap(point2Tri[vIdx], point2Tri[lastVIdx]);

                // update polyList
                uint numNeighbours = point2Tri[vIdx].size();
                for(uint j = 0; j < numNeighbours; ++j)
                {
                    uint polyIdx = point2Tri[vIdx][j];

                    if(this->iTriangleIndices[polyIdx].x == lastVIdx)
                    {
                        this->iTriangleIndices[polyIdx].x = vIdx;
                    }
                    else if(this->iTriangleIndices[polyIdx].y == lastVIdx)
                    {
                        this->iTriangleIndices[polyIdx].y = vIdx;
                    }
                    else if(this->iTriangleIndices[polyIdx].y == lastVIdx)
                    {
                        this->iTriangleIndices[polyIdx].z = vIdx;
                    }
                }
            }
            // update numNoVertices
            --numNoVertices;
        }
        delete [] point2Tri;
        this->iId2Point3dId.clear();
        this->iTriangleVec.clear();
    }

    // modified from base class
    // edge 12: (b,e) in special case 5b
    // edge 13: (b,e) in special case 9b
    // edge 14: (b,f) in special case 11b ***OBSOLETE***
    // edge 14: (a,d) in special case 11c
    // edge 15: (b,e) in special case 12b
    // edge 16: (b,f) in special case 14b ***OBSOLETE***
    // edge 16: (a,d) in special case 14c
    // edge 17: (b,e) in special case -7
    // edge 18: (a,d) in special case -3
    template <class T>
    uint NonobtuseMC<T>::getEdgeId(uint x, uint y, uint z, uint edgeNo)
    {
        switch(edgeNo)
        {
        case 0:
            return this->getVertexId(x, y, z) + 1;
        case 1:
            return this->getVertexId(x, y + 1, z);
        case 2:
            return this->getVertexId(x + 1, y, z) + 1;
        case 3:
            return this->getVertexId(x, y, z);
        case 4:
            return this->getVertexId(x, y, z + 1) + 1;
        case 5:
            return this->getVertexId(x, y + 1, z + 1);
        case 6:
            return this->getVertexId(x + 1, y, z + 1) + 1;
        case 7:
            return this->getVertexId(x, y, z + 1);
        case 8:
            return this->getVertexId(x, y, z) + 2;
        case 9:
            return this->getVertexId(x, y + 1, z) + 2;
        case 10:
            return this->getVertexId(x + 1, y + 1, z) + 2;
        case 11:
            return this->getVertexId(x + 1, y, z) + 2;
        case 12:
            return this->getVertexId(x, y, z) + 3;
        case 13:
            return this->getVertexId(x, y, z) + 4;
        case 14:                           
            return this->getVertexId(x, y, z) + 5;
        case 15:
            return this->getVertexId(x, y, z) + 6;
        case 16:
            return this->getVertexId(x, y, z) + 7;
        case 17:
            return this->getVertexId(x, y, z) + 8;
        case 18:
            return this->getVertexId(x, y, z) + 9;
        default:
            // Invalid edge no.
            return -1;
        }
    }

    // modified from base class
    // base class: each cube has 3 vertices
    //             1st - on edge 3
    //             2nd - on edge 0
    //             3rd - on edge 8
    //
    // this class: each cube has 8 vertices
    //             1st - on edge 3
    //             2nd - on edge 0
    //             3rd - on edge 8
    //             4th - on edge 12: (b,e) in special case 5b
    //             5th - on edge 13: (b,e) in special case 9b
    //             6th - on edge 14: (b,f) in special case 11b ***OBSOLETE***
    //             6th - on edge 14: (a,d) in special case 11c ***OBSOLETE***
    //             7th - on edge 15: (b,e) in special case 12b
    //             8th - on edge 16: (b,f) in special case 14b ***OBSOLETE***
    //             8th - on edge 16: (a,d) in special case 14c ***OBSOLETE***
    //             9th - on edge 17: (b,e) in special case -7
    //            10th - on edge 18: (a,d) in special case -3
    template <class T>
    uint NonobtuseMC<T>::getVertexId(uint x, uint y, uint z)
    {
        return 10 * (z * (this->iCellsY + 1) * (this->iCellsX + 1) + y * (this->iCellsX + 1) + x);
    }

    template <class T>
    void NonobtuseMC<T>::deleteSurface()
    {
        IsoSurface<T>::deleteSurface();
    
        this->iIntPtList[0] = NULL;
        this->iIntPtList[1] = NULL;
        this->iIntPtList[2] = NULL;
        this->iOffsets[0] = 0.0;
        this->iOffsets[1] = 0.0;
        this->iOffsets[2] = 0.0;
    }

    // compute the intersecting point on the specified edge of the cube
    // modified from base class; uses this->iIntPtList to compute
    template <class T>
    Point3dId NonobtuseMC<T>::calculateIntersection(uint x, uint y, uint z, uint edgeNo, uint surfaceType)
    {
        Point3dId midpoint = IsoSurface<T>::calculateIntersection(x, y, z, edgeNo);
        midpoint.iPt.x += this->iOffsets[0];
        midpoint.iPt.y += this->iOffsets[1];
        midpoint.iPt.z += this->iOffsets[2];
        if(surfaceType == MIDPOINT)
        {
            return midpoint;
        }
        cv::Point3d pt1;
        cv::Point3d pt2;
        uint v1x = x, v1y = y, v1z = z;
        uint v2x = x, v2y = y, v2z = z;
        uint edgeOrientation = 0;
        uint rayIdx = 0;
    
        //    1----2
        //   /|  / |
        // 5----6  |
        // | /0-|--3
        // |/   |/
        // 4----7
    
        switch(edgeNo)
        {
        case 0:
            v2y += 1;
            edgeOrientation = 1;
            rayIdx = z * (this->iCellsX + 1) + x;
            break;
        case 1:
            v1y += 1;
            v2x += 1;
            v2y += 1;
            edgeOrientation = 0;
            rayIdx = z * (this->iCellsY + 1) + (y + 1);
            break;
        case 2:
            v1x += 1;
            v1y += 1;
            v2x += 1;
            edgeOrientation = 1;
            rayIdx = z * (this->iCellsX + 1) + (x+1);
            break;
        case 3:
            v1x += 1;
            edgeOrientation = 0;
            rayIdx = z * (this->iCellsY + 1) + y;
            break;
        case 4:
            v1z += 1;
            v2y += 1;
            v2z += 1;
            edgeOrientation = 1;
            rayIdx = (z + 1) * (this->iCellsX + 1) + x;
            break;
        case 5:
            v1y += 1;
            v1z += 1;
            v2x += 1;
            v2y += 1;
            v2z += 1;
            edgeOrientation = 0;
            rayIdx = (z + 1) * (this->iCellsY + 1) + (y + 1);
            break;
        case 6:
            v1x += 1;
            v1y += 1;
            v1z += 1;
            v2x += 1;
            v2z += 1;
            edgeOrientation = 1;
            rayIdx = (z + 1) * (this->iCellsX + 1) + (x + 1);
            break;
        case 7:
            v1x += 1;
            v1z += 1;
            v2z += 1;
            edgeOrientation = 0;
            rayIdx = (z + 1) * (this->iCellsY + 1) + y;
            break;
        case 8:
            v2z += 1;
            edgeOrientation = 2;
            rayIdx = y * (this->iCellsX + 1) + x;
            break;
        case 9:
            v1y += 1;
            v2y += 1;
            v2z += 1;
            edgeOrientation = 2;
            rayIdx = (y + 1) * (this->iCellsX + 1) + x;
            break;
        case 10:
            v1x += 1;
            v1y += 1;
            v2x += 1;
            v2y += 1;
            v2z += 1;
            edgeOrientation = 2;
            rayIdx = (y + 1) * (this->iCellsX + 1) + (x + 1);
            break;
        case 11:
            v1x += 1;
            v2x += 1;
            v2z += 1;
            edgeOrientation = 2;
            rayIdx = y * (this->iCellsX + 1) + (x + 1);
            break;
        }

        pt1.x = v1x * this->iCellLengthX + this->iOffsets[0];
        pt1.y = v1y * this->iCellLengthY + this->iOffsets[1];
        pt1.z = v1z * this->iCellLengthZ + this->iOffsets[2];
        pt2.x = v2x * this->iCellLengthX + this->iOffsets[0];
        pt2.y = v2y * this->iCellLengthY + this->iOffsets[1];
        pt2.z = v2z * this->iCellLengthZ + this->iOffsets[2];
    
        // find intersecting point
        Point3dId intersection;
        intersection.iId = 0;
        uint numIntPt = this->iIntPtList[edgeOrientation][rayIdx].size();
        for(uint i = 0; i < numIntPt; ++i)
        {
            cv::Point3d intPt = this->iIntPtList[edgeOrientation][rayIdx][i].iPt;
            double v1 = 0;
            double v2 = 0;
            if((edgeNo != 2) && (edgeNo != 3) && (edgeNo != 6) && (edgeNo != 7)) // pt1 is the lower point
            {
                switch(edgeOrientation)
                {
                case 0:
                    v1 = pt1.x;
                    v2 = intPt.x;
                    break;
                case 1:
                    v1 = pt1.y;
                    v2 = intPt.y;
                    break;
                case 2:
                    v1 = pt1.z;
                    v2 = intPt.z;
                    break;
                }
            }
            else
            {
                switch(edgeOrientation)
                {
                case 0:
                    v1 = pt2.x;
                    v2 = intPt.x;
                    break;
                case 1:
                    v1 = pt2.y;
                    v2 = intPt.y;
                    break;
                case 2:
                    v1 = pt2.z;
                    v2 = intPt.z;
                    break;
                }
            }
            if(v1 <= v2)
            {
                intersection.iId = 1;
                intersection.iPt = intPt;
                break;
            }
        }
    
        // TODO: FIX THIS!!! it should find an intersection no matter what!
        //       it seems like this doesn't occur for closed manifolds *phew*
        if(intersection.iId == 0)
        {
            std::cout << "intersection not found" 
                 << " at cube (" << x << ", " << y << ", " << z
                 << ") on edge " << edgeNo << std::endl;
            intersection = midpoint;
        }
    
        if(surfaceType == INTERPOLATE)
        {
            return intersection;
        }
		/*
        cv::Point3d testPoint = midpoint.iPt;
        cv::Point3d lastTestPoint;
        double eps = 0.01;
        if(checkNonobtuse(testPoint, x, y, z, edgeNo))
        {
            while(true)
            {    
                testPoint = (midpoint.iPt + intersection.iPt) * 0.5;
                if(!checkNonobtuse(testPoint, x, y, z, edgeNo))
                {
                    intersection.iPt = testPoint;
                    if(cv::norm(testPoint - lastTestPoint) <= eps)
                    {
                        break;
                    }
                }
                else if(cv::norm(testPoint - lastTestPoint) > eps)
                {
                    midpoint.iPt = testPoint;
                }
                else
                {
                    break;
                }
                lastTestPoint = testPoint;
            } 
        }
        intersection.iPt = testPoint;
		*/
        return intersection;
    }

    // returns xOffsets
    template <class T>
    double NonobtuseMC<T>::getXOffset() const
    {
        return this->iOffsets[0];
    }

    // returns yOffsets
    template <class T>
    double NonobtuseMC<T>::getYOffset() const
    {
        return this->iOffsets[1];
    }

    // returns zOffsets
    template <class T>
    double NonobtuseMC<T>::getZOffset() const
    {
        return this->iOffsets[2];
    }

    // returns true if all angles incident to testPoint is nonobtuse
    template <class T>
    bool NonobtuseMC<T>::checkNonobtuse(const cv::Point3d& testPoint, uint x, uint y, uint z, uint edgeNo)
    {
        // check current cube
        bool result = this->checkNonobtuse_singleCube(testPoint, x, y, z, edgeNo);
        if(result)
        {
            switch(edgeNo)
            {
            case 0:
                if(x - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y, z, 2));
                }
                if(!result)
                {
                    break;
                }
                else if(z - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z - 1, 4));
                }
                if(!result)
                {
                    break;
                }
                else if((x - 1 >= 0) && (z - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y, z - 1, 6));
                }
                break;
            case 1:
                if(z - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z - 1, 5));
                }
                if(!result)
                {
                    break;
                }
                else if(y + 1 < this->iCellsY)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y + 1, z, 3));
                }
                if(!result)
                {
                    break;
                }
                else if((y + 1 < this->iCellsY) && (z - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y + 1, z - 1, 7));
                }
                break;
            case 2:
                if(z - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z - 1, 6));
                }
                if(!result)
                {
                    break;
                }
                else if(x + 1 < this->iCellsX)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y, z, 0));
                }
                if(!result)
                {
                    break;
                }
                else if((x + 1 < this->iCellsX) && (z - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y, z - 1, 4));
                }
                break;
            case 3:
                if(z - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z - 1, 7));
                }
                if(!result)
                {
                    break;
                }
                else if(y - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y - 1, z, 1));
                }
                if(!result)
                {
                    break;
                }
                else if((y - 1 >= 0) && (z - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y - 1, z - 1, 5));
                }
                break;
            case 4:
                if(x - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y, z, 6));
                }
                if(!result)
                {
                    break;
                }
                else if(z + 1 < this->iCellsZ)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z + 1, 0));
                }
                if(!result)
                {
                    break;
                }
                else if((z + 1 < this->iCellsZ) && (x - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y, z + 1, 2));
                }
                break;
            case 5:
                if(z + 1 < this->iCellsZ)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z + 1, 1));
                }
                if(!result)
                {
                    break;
                }
                else if(y + 1 < this->iCellsY)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y + 1, z, 7));
                }
                if(!result)
                {
                    break;
                }
                else if((y + 1 < this->iCellsY) && (z + 1 < this->iCellsZ))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y + 1, z + 1, 3));
                }
                break;
            case 6:
                if(x + 1 < this->iCellsX)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y, z, 4));
                }
                if(!result)
                {
                    break;
                }
                else if(z + 1 < this->iCellsZ)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z + 1, 2));
                }
                if(!result)
                {
                    break;
                }
                else if((z + 1 < this->iCellsZ) && (x + 1 < this->iCellsX))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y, z + 1, 0));
                }
                break;
            case 7:
                if(y - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y - 1, z, 5));
                }
                if(!result)
                {
                    break;
                }
                else if(z + 1 < this->iCellsZ)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y, z + 1, 3));
                }
                if(!result)
                {
                    break;
                }
                else if((z + 1 < this->iCellsZ) && (y - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y - 1, z + 1, 1));
                }
                break;
            case 8:
                if(x - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y, z, 11));
                }
                if(!result)
                {
                    break;
                }
                else if(y - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y - 1, z, 9));
                }
                if(!result)
                {
                    break;
                }
                else if((x - 1 >= 0) && (y - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y - 1, z, 10));
                }
                break;
            case 9:
                if(x - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y, z, 10));
                }
                if(!result)
                {
                    break;
                }
                else if(y + 1 < this->iCellsY)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y+1, z, 8));
                }
                if(!result)
                {
                    break;
                }
                else if((y + 1 < this->iCellsY) && (x - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x - 1, y + 1, z, 11));
                }
                break;
            case 10:
                if(x + 1 < this->iCellsX)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y, z, 9));
                }
                if(!result)
                {
                    break;
                }
                else if(y + 1 < this->iCellsY)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y + 1, z, 11));
                }
                if(!result)
                {
                    break;
                }
                else if((y + 1 < this->iCellsY) && (x + 1 < this->iCellsX))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y + 1, z, 8));
                }
                break;
            case 11:
                if(y - 1 >= 0)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x, y - 1, z, 10));
                }
                if(!result)
                {
                    break;
                }
                else if(x + 1 < this->iCellsX)
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y, z, 8));
                }
                if(!result)
                {
                    break;
                }
                else if((x + 1 < this->iCellsX) && (y - 1 >= 0))
                {
                    result = (result && this->checkNonobtuse_singleCube(testPoint, x + 1, y - 1, z, 9));
                }
                break;
            }
        }
        return result;
    }

    // returns true if all angles in cube x, y, z at edge edgeNo incident to testPoint is nonobtuse
    template <class T>
    bool NonobtuseMC<T>::checkNonobtuse_singleCube(const cv::Point3d& testPoint, uint x, uint y, uint z, uint edgeNo)
    {
        uint cubesInXDir = this->iCellsX;
        uint cubesInSlice = cubesInXDir * this->iCellsY;
        uint tableIndex = this->iAllTableIndex[z * cubesInSlice + y * cubesInXDir + x];
        bool isNonobtuse = true;
        if(this->iTriTable[tableIndex][0] == -3)
        {
            // -3:    Special Case -3
            // {-3, a, b, c, d, e, f, -1, ... }
            // where a,b,c,d forms a quad, and d,e,f,a forms the other quad
            // The right hand ordering determines the normals
            // A new point m should be added to the midpoint of a,d
            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
    
            // find edgeNo in iTriTable entry
            uint edgeIdx = 1;
            for(edgeIdx = 1; edgeIdx <= 6; ++edgeIdx)
            {
                if(this->iTriTable[tableIndex][edgeIdx] == (int)edgeNo)
                {
                    break;
                }
            }
            if((edgeIdx >= 1) && (edgeIdx <= 6))    
            {
                // get location for m
                Point3dId ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], MIDPOINT);
                Point3dId pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], MIDPOINT);
                cv::Point3d m = (ptb.iPt + pte.iPt) * 0.5;
                // find neighbour vertex
                // ie. if checking triangle abm and edgeIdx == 1, then we want to find b
                Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][(edgeIdx % 6) + 1]));
                if(citer != this->iId2Point3dId.end())
                {
                    double angle = Utility::getAngle(testPoint, m, citer->second.iPt);
                    if(angle >= M_PI_2)
                    //if(angle - M_PI_2 >= 0.0001)
                    {
                        isNonobtuse = false;
                    }
                }
                else // can't find vertex; not computed yet
                {
                    // ignore the triangle, and assume it is non-obtuse
                }
            }
            else // this should not be happening
            {
                std::cout << "ERROR in checkNonobtuse_singleCube(): cannot find edge in iTriTable: Case -3\n";
            }
        }
        else if(this->iTriTable[tableIndex][0] == -5)
        {
            // -5:  Special Case 5b
            // {-5, a, b, c, d, e, -1, ... }
            // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
            // The right hand ordering determins the normals
            // A new point m should be added to the midpoint of b,e
            // Then, the 5 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, a, m, -1}
    
            // find edgeNo in iTriTable entry
            uint edgeIdx = 1;
            for(edgeIdx = 1; edgeIdx <= 5; ++edgeIdx)
            {
                if(this->iTriTable[tableIndex][edgeIdx] == (int)edgeNo)
                {
                    break;
                }
            }
            if(edgeIdx >= 1 && edgeIdx <= 5)    
            {
                // get location for m
                Point3dId ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                Point3dId pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                cv::Point3d m = (ptb.iPt + pte.iPt) * 0.5;
                // find neighbour vertex
                // ie. if checking triangle abm and edgeIdx == 1, then we want to find b
                Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][(edgeIdx % 5) + 1]));
                if(citer != this->iId2Point3dId.end())
                {
                    double angle = Utility::getAngle(testPoint, m, citer->second.iPt);
                    if(angle >= M_PI_2)
                    //if(angle - M_PI_2 >= 0.0001)
                        isNonobtuse = false;
                }
                else // can't find vertex; not computed yet
                {
                    // ignore the triangle, and assume it is non-obtuse
                }
            }
            else    // this should not be happening
            {
                std::cout << "ERROR in checkNonobtuse_singleCube(): cannot find edge in iTriTable: Case -5" << std::endl;
            }
        }
        else if(this->iTriTable[tableIndex][0] == -7)
        {
            // -7:  Special Case -7
            // {-7, a, b, c, d, e, f, i, j, k, -1, ... }
            // where a,b,c,d,e,f forms a hexagon and i,j,k forms a triangle
            // The right hand ordering determines the normals
            // A new point m should be added to the centroid of a,b,c,d,e,f
            // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, i, j, k, -1}
        
            // find edgeNo in iTriTable entry
            uint edgeIdx = 1;
            for(edgeIdx = 1; edgeIdx <= 9; ++edgeIdx)
            {
                if(this->iTriTable[tableIndex][edgeIdx] == (int)edgeNo)
                {
                    break;
                }
            }
            if((edgeIdx >= 1) && (edgeIdx <= 6))
            {
                // get location for m
                Point3dId ptb = calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                Point3dId pte = calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                cv::Point3d m = (ptb.iPt + pte.iPt) * 0.5;
                // find neighbour vertex
                // ie. if checking triangle abm and edgeIdx == 1, then we want to find b
                Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][(edgeIdx % 6) + 1]));
                if(citer != this->iId2Point3dId.end())
                {
                    double angle = Utility::getAngle(testPoint, m, citer->second.iPt);
                    if(angle >= M_PI_2)
                    //if(angle - M_PI_2 >= 0.0001)
                    {
                        isNonobtuse = false;
                    }
                }
                else // can't find vertex; not computed yet
                {
                    // ignore the triangle, and assume it is non-obtuse
                }
            }
            else if((edgeIdx >= 7) && (edgeIdx <= 9))
            {
                // find neighbour vertex 1
                Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][((edgeIdx-6) % 3) + 7]));
                if(citer != this->iId2Point3dId.end())
                {
                    // find neighbour vertex 2
                    Id2Point3dId::const_iterator citer2 = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][((edgeIdx - 5) % 3) + 7]));
                    if(citer2 != this->iId2Point3dId.end())
                    {
                        double angle = Utility::getAngle(testPoint, citer->second.iPt, citer2->second.iPt);
                        if(angle >= M_PI_2)
                        //if(angle - M_PI_2 >= 0.0001)
                        {
                            isNonobtuse = false;
                        }
                    }
                    else // can't find vertex; not computed yet
                    {
                        // ignore the triangle, and assume it is non-obtuse
                    }
                }
                else // can't find vertex; not computed yet
                {
                    // ignore the triangle, and assume it is non-obtuse
                }
            }
            else // this should not be happening
            {
                std::cout << "ERROR in checkNonobtuse_singleCube(): cannot find edge in iTriTable: Case -7\n";
            }
        }
        else if(this->iTriTable[tableIndex][0] == -9)
        {
            // -9:  Special Case 9b
            // {-9, a, b, c, d, e, f, -1, ... }
            // where a,b,c,d,e,f forms a hexagon.
            // The right hand ordering determines the normals
            // A new point m should be added to the centroid of a,b,c,d,e,f
            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
        
            // find edgeNo in iTriTable entry
            uint edgeIdx = 1;
            for(edgeIdx = 1; edgeIdx <= 6; ++edgeIdx)
            {
                if(this->iTriTable[tableIndex][edgeIdx] == (int)edgeNo)
                    break;
            }
            if((edgeIdx >= 1) && (edgeIdx <= 6))
            {
                // get location for m
                Point3dId ptb = calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                Point3dId pte = calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                cv::Point3d m = (ptb.iPt + pte.iPt) * 0.5;
                // find neighbour vertex
                // ie. if checking triangle abm and edgeIdx == 1, then we want to find b
                Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][(edgeIdx % 6) + 1]));
                if(citer != this->iId2Point3dId.end())
                {
                    double angle = Utility::getAngle(testPoint, m, citer->second.iPt);
                    if(angle >= M_PI_2)
                    //if(angle - M_PI_2 >= 0.0001)
                    {
                        isNonobtuse = false;
                    }
                }
                else // can't find vertex; not computed yet
                {
                    // ignore the triangle, and assume it is non-obtuse
                }
            }
            else // this should not be happening
            {
                std::cout << "ERROR in checkNonobtuse_singleCube(): cannot find edge in iTriTable: Case -9\n";
            }
        }
        else if(this->iTriTable[tableIndex][0] == -12)
        {
            // -12: Special Case 12b
            // {-12, a, b, c, d, e, i, j, k, -1, ... }
            // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
            //       and i, j, k forms a seperate triangle
            // The right hand ordering determines the normals
            // A new point m should be added to the midpoint of b,e
            // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, a, m, i, j, k, -1}
    
            // find edgeNo in iTriTable entry
            uint edgeIdx = 1;
            for(edgeIdx = 1; edgeIdx <= 8; ++edgeIdx)
            {
                if(this->iTriTable[tableIndex][edgeIdx] == (int)edgeNo)
                {
                    break;
                }
            }
            if((edgeIdx >= 1) && (edgeIdx <= 5))
            {
                // get location for m
                Point3dId ptb = calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], MIDPOINT);
                Point3dId pte = calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], MIDPOINT);
                cv::Point3d m = (ptb.iPt + pte.iPt) * 0.5;
                // find neighbour vertex
                // ie. if checking triangle abm and edgeIdx == 1, then we want to find b
                Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][(edgeIdx % 5) + 1]));
                if(citer != this->iId2Point3dId.end())
                {
                    double angle = Utility::getAngle(testPoint, m, citer->second.iPt);
                    if(angle >= M_PI_2)
                    //if(angle - M_PI_2 >= 0.0001)
                    {
                        isNonobtuse = false;
                    }
                }
                else // can't find vertex; not computed yet
                {
                    // ignore the triangle, and assume it is non-obtuse
                }
            }
            else if((edgeIdx >= 6) && (edgeIdx <= 8))
            {
                // find neighbour vertex 1
                Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][((edgeIdx - 5) % 3) + 6]));
                if(citer != this->iId2Point3dId.end())
                {
                    // find neighbour vertex 2
                    Id2Point3dId::const_iterator citer2 = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][((edgeIdx - 4) % 3) + 6]));
                    if(citer2 != this->iId2Point3dId.end())
                    {
                        double angle = Utility::getAngle(testPoint, citer->second.iPt, citer2->second.iPt);
                        if(angle >= M_PI_2)
                        //if(angle - M_PI_2 >= 0.0001)
                        {
                            isNonobtuse = false;
                        }
                    }
                    else // can't find vertex; not computed yet
                    {
                        // ignore the triangle, and assume it is non-obtuse
                    }
                }
                else // can't find vertex; not computed yet
                {
                    // ignore the triangle, and assume it is non-obtuse
                }
            }
            else // this should not be happening
            {
                std::cout << "ERROR in checkNonobtuse_singleCube(): cannot find edge in iTriTable: Case -12\n";
            }
        }
        else // general marching cube cases
        {
            // find edgeNo in iTriTable entry
            uint edgeIdx = 0;
            while(edgeIdx < 16)
            {
                if(this->iTriTable[tableIndex][edgeIdx] == (int)edgeNo)
                {
                    uint triInList = edgeIdx / 3; // start counting from 0
                    uint nbIdx1 = 3 * triInList + (((edgeIdx % 3) + 1) % 3);
                    uint nbIdx2 = 3 * triInList + (((edgeIdx % 3) + 2) % 3);
                    // find neighbour vertex 1
                    Id2Point3dId::const_iterator citer = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][nbIdx1]));
                    if(citer != this->iId2Point3dId.end())
                    {
                        // find neighbour vertex 2
                        Id2Point3dId::const_iterator citer2 = this->iId2Point3dId.find(this->getEdgeId(x, y, z, this->iTriTable[tableIndex][nbIdx2]));
                        if(citer2 != this->iId2Point3dId.end())
                        {
                            double angle = Utility::getAngle(testPoint, citer->second.iPt, citer2->second.iPt);
                            if(angle >= M_PI_2)
                            //if(angle - M_PI_2 >= 0.0001)
                            {
                                isNonobtuse = false;
                            }
                        }
                        else // can't find vertex; not computed yet
                        {
                            // ignore the triangle, and assume it is non-obtuse
                        }
                    }
                    else // can't find vertex; not computed yet
                    {
                        // ignore the triangle, and assume it is non-obtuse
                    }
                }
                else if(this->iTriTable[tableIndex][edgeIdx] == -1)
                {
                    break;
                }
                ++edgeIdx;
            }
        }
        return isNonobtuse;
    }

    template class NonobtuseMC<short>;
    template class NonobtuseMC<unsigned short>;
    template class NonobtuseMC<int>;
    template class NonobtuseMC<unsigned int>;
    template class NonobtuseMC<float>;
    template class NonobtuseMC<double>;
}

