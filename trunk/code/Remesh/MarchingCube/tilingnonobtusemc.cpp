#include "tilingnonobtusemc.h"

namespace DUT
{
    // modified from parent class to make 1 as outside, 0 as inside
    template <class T>
    const int IsoSurface<T>::iTriTable[256][16] =
    {
        //
        // list of edges the triangle touches
        // -1 denotes end of list
        // special case if first index is -3, -5, -7, -9, -11, -12, -14
        //
        // -3:    Special Case -3
        // {-3, a, b, c, d, e, f, -1, ... }
        // where a,b,c,d forms a quad, and d,e,f,a forms the other quad
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of a,d
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
        //
        // -5:  Special Case 5b
        // {-5, a, b, c, d, e, -1, ... }
        // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of b,e
        // Then, the 5 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, -1}
        //
        // -6:    Special Case -6
        // {-6, a, b, c, d, e, f, g, -1, ... }
        // where a,b,c,d,e,f,g forms a seven-agon
        // The right hand ordering determines the normals
        // A new point m should be added to the center of cube
        // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, g, m, g, a, m, -1}
        //
        // -7:  Special Case -7
        // {-7, a, b, c, d, e, f, i, j, k, -1, ... }
        // where a,b,c,d,e,f forms a hexagon and i,j,k forms a triangle
        // The right hand ordering determines the normals
        // A new point m should be added to the centroid of a,b,c,d,e,f
        // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, i, j, k, -1}
        //
        // -9:  Special Case 9b
        // {-9, a, b, c, d, e, f, -1, ... }
        // where a,b,c,d,e,f forms a hexagon.
        // The right hand ordering determines the normals
        // A new point m should be added to the centroid of a,b,c,d,e,f
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
        //
        // -11: Special Case 11c
        // {-11, a, b, c, d, e, f, -1, ... ]
        // where a,b,c,d,e,f forms a bent hexagon.
        //       new point m is added in the center of the cube
        //       b,c,m and e,f,m are right isoscele triangles
        //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
        // The right hand ordering determines the normals
        // A new point m should be added to the center of cube (ie. midpoint of a and d)
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
        //
        // -12: Special Case 12b
        // {-12, a, b, c, d, e, i, j, k, -1, ... }
        // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
        //       and i, j, k forms a seperate triangle
        // The right hand ordering determines the normals
        // A new point m should be added to the midpoint of b,e
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, a, m, i, j, k, -1}
        //
        // -14: Special Case 14c
        // {-11, a, b, c, d, e, f, -1, ... ]
        // where a,b,c,d,e,f forms a bent hexagon.
        //       new point m is added in the center of the cube
        //       b,c,m and e,f,m are right isoscele triangles
        //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
        // The right hand ordering determines the normals
        // A new point m should be added to the center of cube (ie. midpoint of a and d)
        // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
    
        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},   // 0000 0000; v none    (case 0)
        {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 0001; v 0       (case 1)
        {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 0010; v 1       (case 1)
        {8, 1, 3, 8, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0000 0011; v 0,1     (case 2)
        {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0000 0100; v 2       (case 1)
        {0, 3, 8, 2, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0000 0101; v 0,2     (case 3)
        {2, 9, 10, 2, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0000 0110; v 1,2     (case 2)
        {-5, 9, 10, 2, 3, 8,-1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0000 0111; v 0,1,2   (case 5b)
        {11, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0000 1000; v 3       (case 1)
        {0, 2, 11, 11, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0000 1001; v 0,3     (case 2)
        {9, 1, 0, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0000 1010; v 1,3     (case 3)
        {-5, 8, 9, 1, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0000 1011; v 0,1,3   (case 5b)
        {3, 1, 10, 10, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1100; v 2,3     (case 1)
        {-5, 11, 8, 0, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1101; v 0,2,3   (case 5b)
        {-5, 10, 11, 3, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1110; v 1,2,3   (case 5b)
        {8, 9, 10, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0000 1111; v 0,1,2,3 (case 8)
        {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0001 0000; v 4       (case 1)
        {3, 4, 0, 3, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0001 0001; v 0,4     (case 2)
        {1, 0, 9, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0001 0010; v 1,4     (case 3)
        {-5, 3, 7, 4, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001 0011; v 0,1,4   (case 5b)
        {2, 1, 10, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001 0100; v 2,4     (case 4)
        {4, 3, 7, 0, 3, 4, 2, 1, 10, -1, -1, -1, -1, -1, -1, -1},           // 0001 0101; v 0,2,4   (case 6)
        {2, 9, 10, 0, 9, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1},           // 0001 0110; v 1,2,4   (case 6)
        {-14, 4, 9, 10, 2, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0001 0111; v 0,1,2,4 (case 14c)
        {4, 8, 7, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001 1000; v 3,4     (case 3)
        {-5, 0, 2, 11, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0001 1001; v 0,3,4   (case 5b)
        {0, 9, 1, 4, 8, 7, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1},           // 0001 1010; v 1,3,4   (case 7)
        {-9, 4, 9, 1, 2, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0001 1011; v 0,1,3,4 (case 9b)
        {10, 3, 1, 11, 3, 10, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1},         // 0001 1100; v 2,3,4   (case 6)
        {-11, 7, 4, 0, 1, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0001 1101; v 0,2,3,4 (case 11c)
        {-12, 10, 11, 3, 0, 9, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1},        // 0001 1110; v 1,2,3,4 (case 12b)
        {-5, 10, 11, 7, 4, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0001 1111; v -5.-6,-7(case -5b)
        {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0010 0000; v 5       (case 1)
        {9, 4, 5, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0010 0001; v 0,5     (case 3)
        {0, 4, 5, 5, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0010 0010; v 1,5     (case 2)
        {-5, 1, 3, 8, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 0011; v 0,1,5   (case 5b)
        {2, 1, 10, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 0100; v 2,5     (case 3)
        {0, 3, 8, 2, 1, 10, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1},           // 0010 0101; v 0,2,5   (case 7)
        {-5, 0, 4, 5, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0010 0110; v 1,2,5   (case 5b)
        {-9, 2, 3, 8, 4, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 0111; v 0,1,2,5 (case 9b)
        {9, 4, 5, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0010 1000; v 3,5     (case 4)
        {11, 0, 2, 8, 0, 11, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1},          // 0010 1001; v 0,3,5   (case 6)
        {0, 4, 5, 1, 0, 5, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1},           // 0010 1010; v 1,3,5   (case 6)
        {-11, 4, 5, 1, 2, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0010 1011; v 0,1,3,5 (case 11c)
        {10, 11, 3, 1, 10, 3, 5, 9, 4, -1, -1, -1, -1, -1, -1, -1},         // 0010 1100; v 2,3,5   (case 6)
        {-12, 11, 8, 0, 1, 10, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1},        // 0010 1101; v 0,2,3,5 (case 12b)
        {-14, 3, 0, 4, 5, 10, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0010 1110; v 1,2,3,5 (case 14c)
        {-5, 11, 8, 4, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0010 1111; v -4,-6,-7(case -5b)
        {9, 8, 7, 7, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0011 0000; v 4,5     (case 2)
        {-5, 7, 5, 9, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0011 0001; v 0,4,5   (case 5b)
        {-5, 5, 1, 0, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0011 0010; v 1,4,5   (case 5b)
        {5, 1, 3, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0011 0011; v 0,1,4,5 (case 8)
        {9, 8, 7, 5, 9, 7, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1},           // 0011 0100; v 2,4,5   (case 6)
        {-12, 7, 5, 9, 0, 3, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1},         // 0011 0101; v 0,2,4,5 (case 12b)
        {-11, 10, 2, 0, 8, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 0110; v 1,2,4,5 (case 11c)
        {-5, 7, 5, 10, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 0111; v -3,-6.-7(case -5b)
        {7, 5, 9, 7, 9, 8, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1},           // 0011 1000; v 3,4,5   (case 6)
        {-14, 11, 7, 5, 9, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 1001; v 0,3,4,5 (case 14c)
        {-12, 5, 1, 0, 8, 7, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1},         // 0011 1010; v 1,3,4,5 (case 12b)
        {-5, 5, 1, 2, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0011 1011; v -2,-6,-7(case -5b)
        {5, 9, 8, 5, 8, 7, 1, 10, 3, 3, 10, 11, -1, -1, -1, -1},            // 0011 1100; v 2,3,4,5 (case 10)
        //{7, 5, 9, 7, 9, 0, 11, 7, 0, 0, 1, 11, 10, 11, 1, -1},            // 0011 1101; v -1,-6.-7(case -6)
        {-6, 0, 1, 10, 11, 7, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1},        // 0011 1101; v -1,-6.-7(case -6)
        //{10, 11, 3, 3, 0, 10, 10, 0, 5, 0, 8, 5, 5, 8, 7, -1},            // 0011 1110; v -0,-6.-7(case -6)
        {-6, 0, 8, 7, 5, 10, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1},        // 0011 1110; v -0,-6.-7(case -6)
        {10, 11, 5, 11, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 0011 1111; v -6,-7   (case -2)
        {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0100 0000; v 6       (case 1)
        {0, 3, 8, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0001; v 0,6     (case 4)
        {9, 1, 0, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0010; v 1,6     (case 3)
        {1, 3, 8, 1, 8, 9, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1},           // 0100 0011; v 0,1,6   (case 6)
        {6, 1, 5, 6, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0100 0100; v 2,6     (case 2)
        {1, 5, 6, 2, 1, 6, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1},            // 0100 0101; v 0,2,6   (case 6)
        {-5, 2, 0, 9, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0110; v 1,2,6   (case 5b)
        {-11, 3, 8, 9, 5, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 0111; v 0,1,2,6 (case 11c)
        {3, 2, 11, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1000; v 3,6     (case 3)
        {11, 8, 0, 11, 0, 2, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1},         // 0100 1001; v 0,3,6   (case 6)
        {1, 0, 9, 3, 2, 11, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1},          // 0100 1010; v 1,3,6   (case 7)
        {-12, 8, 9, 1, 2, 11, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1},        // 0100 1011; v 0,1,3,6 (case 12b)
        {-5, 1, 5, 6, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1100; v 2,3,6   (case 5b)
        {-14, 6, 11, 8, 0, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1101; v 0,2,3,6 (case 14c)
        {-9, 3, 0, 9, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0100 1110; v 1,2,3,6 (case 9b)
        {-5, 8, 9, 5, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0100 1111; v -4,-5,-7(case -5b)
        {10, 5, 6, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0101 0000; v 4,6     (case 3)
        {3, 4, 0, 7, 4, 3, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1},           // 0101 0001; v 0,4,6   (case 6)
        {9, 1, 0, 10, 5, 6, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1},           // 0101 0010; v 1,4,6   (case 7)
        {-12, 3, 7, 4, 9, 1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1},         // 0101 0011; v 0,1,4,6 (case 12b)
        {6, 2, 1, 5, 6, 1, 7, 4, 8, -1, -1, -1, -1, -1, -1, -1},            // 0101 0100; v 2,4,6   (case 6)
        {2, 1, 5, 2, 5, 6, 0, 3, 4, 4, 3, 7, -1, -1, -1, -1},               // 0101 0101; v 0,2,4,6 (case 10)
        {-12, 2, 0, 9, 5, 6, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1},          // 0101 0110; v 1,2,4,6 (case 12b)
        //{7, 4, 3, 3, 4, 9, 2, 3, 9, 9, 5, 2, 2, 5, 6, -1},                // 0101 0111; v -3,-5,-7(case -6)
        {-6, 9, 5, 6, 2, 3, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1},          // 0101 0111; v -3,-5,-7(case -6)
         {11, 3, 2, 8, 7, 4, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1},         // 0101 1000; v 3,4,6   (case 7)
        {-12, 0, 2, 11, 7, 4, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1},        // 0101 1001; v 0,3,4,6 (case 12b)
        {1, 0, 9, 7, 4, 8, 3, 2, 11, 10, 5, 6, -1, -1, -1, -1},             // 0101 1010; v 1,3,4,6 (case 13)
        {-7, 9, 1, 2, 11, 7, 4, 10, 5, 6, -1, -1, -1, -1, -1, -1},          // 0101 1011; v -2,-5,-7(case -7)
        {-12, 1, 5, 6, 11, 3, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1},         // 0101 1100; v 2,3,4,6 (case 12b)
        //{1, 5, 6, 1, 6, 11, 0, 1, 11, 11, 7, 0, 4, 0, 7, -1},             // 0101 1101; v -1,-5,-7(case -6)
        {-6, 11, 7, 4, 0, 1, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1},         // 0101 1101; v -1,-5,-7(case -6)
        {-7, 9, 5, 6, 11, 3, 0, 4, 8, 7, -1, -1, -1, -1, -1, -1},           // 0101 1110; v -0,-5,-7(case -7)
        {-3, 9, 5, 6, 11, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0101 1111; v -5,-7   (case -3)
        {10, 9, 4, 4, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 0000; v 5,6     (case 2)
        {10, 4, 6, 9, 4, 10, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1},          // 0110 0001; v 0,5,6   (case 6)
        {-5, 4, 6, 10, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 0010; v 1,5,6   (case 5b)
        {-14, 10, 1, 3, 8, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 0011; v 0,1,5,6 (case 14c)
        {-5, 6, 2, 1, 9, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0110 0100; v 2,5,6   (case 5b)
        {-12, 6, 2, 1, 9, 4, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1},          // 0110 0101; v 0,2,5,6 (case 12b)
        {0, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0110 0110; v 1,2,5,6 (case 8)
        {-5, 6, 2, 3, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0110 0111; v -3,-4,-7(case -5b)
        {4, 10, 9, 10, 4, 6, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1},         // 0110 1000; v 3,5,6   (case 6)
        {0, 2, 8, 8, 2, 11, 9, 4, 10, 10, 4, 6, -1, -1, -1, -1},            // 0110 1001; v 0,3,5,6 (case 10)
        {-12, 4, 6, 10, 1, 0, 11, 3, 2, -1, -1, -1, -1, -1, -1, -1},        // 0110 1010; v 1,3,5,6 (case 12b)
        //{4, 6, 10, 10, 1, 4, 8, 4, 1, 1, 2, 8, 11, 8, 2, -1},             // 0110 1011; v -2,-4,-7(case -6)
        {-6, 1, 2, 11, 8, 4, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1},        // 0110 1011; v -2,-4,-7(case -6)
        {-11, 11, 3, 1, 9, 4, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 1100; v 2,3,5,6 (case 11c)
        //{11, 8, 0, 11, 0, 1, 6, 11, 1, 1, 9, 6, 4, 6, 9, -1},             // 0110 1101; v -1,-4,-7(case -6)
        {-6, 1, 9, 4, 6, 11, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1},         // 0110 1101; v -1,-4,-7(case -6)
        {-5, 4, 6, 11, 3, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0110 1110; v -0,-4,-7(case -5b)
        {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0110 1111; v -4,-7   (case -2)
        {-5, 9, 8, 7, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 0000; v 4,5,6   (case 5b)
        {-11, 6, 10, 9, 0, 3, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 0001; v 0,4,5,6 (case 11c)
        {-9, 10, 1, 0, 8, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 0010; v 1,4,5,6 (case 9b)
        {-5, 3, 7, 6, 10, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 0011; v -2,-3,-7(case -5b)
        {-14, 7, 6, 2, 1, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 0100; v 2,4,5,6 (case 14c)
        //{6, 2, 1, 6, 1, 9, 7, 6, 9, 9, 0, 7, 3, 7, 0, -1},                // 0111 0101; v -1,-3,-7(case -6)
        {-6, 9, 0, 3, 7, 6, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1},          // 0111 0101; v -1,-3,-7(case -6)
        {-5, 2, 0, 8, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 0110; v -0,-3,-7(case -5b)
        {7, 2, 3, 7, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 0111 0111; v -3,-7   (case -2)
        {-12, 9, 8, 7, 6, 10, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1},        // 0111 1000; v 3,4,5,6 (case 12b)
        //{0, 2, 11, 0, 11, 7, 9, 0, 7, 7, 6, 9, 10, 9, 6, -1},             // 0111 1001; v -1,-2,-7(case -6)
        {-6, 7, 6, 10, 9, 0, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 1001; v -1,-2,-7(case -6)
        {-7, 0, 8, 7, 6, 10, 1, 3, 2, 11, -1, -1, -1, -1, -1, -1},          // 0111 1010; v -0,-2,-7(case -7)
        {-3, 1, 2, 11, 7, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 0111 1011; v -2,-7   (case -3)
        //{9, 8, 7, 9, 7, 6, 1, 9, 6, 6, 11, 1, 3, 1, 11, -1},              // 0111 1100; v -0,-1,-7(case -6)
        {-6, 6, 11, 3, 1, 9, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1},         // 0111 1100; v -0,-1,-7(case -6)
        {9, 0, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 1101; v -1,-7   (case -4)
        {-3, 0, 8, 7, 6, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 0111 1110; v -0,-7   (case -3)
        {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 0111 1111; v -7      (case -1)
        {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1000 0000; v 7       (case 1)
        {0, 3, 8, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 0001; v 0,7     (case 3)
        {1, 0, 9, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 0010; v 1,7     (case 4)
        {1, 8, 9, 3, 8, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1},           // 1000 0011; v 0,1,7   (case 6)
        {10, 2, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 0100; v 2,7     (case 3)
        {2, 1, 10, 0, 3, 8, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1},          // 1000 0101; v 0,2,7   (case 7)
        {2, 0, 9, 10, 2, 9, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1},          // 1000 0110; v 1,2,7   (case 6)
        {-12, 9, 10, 2, 3, 8, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1},        // 1000 0111; v 0,1,2,7 (case 12b)
        {7, 3, 2, 2, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1000 1000; v 3,7     (case 2)
        {-5, 2, 6, 7, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 1001; v 0,3,7   (case 5b)
        {2, 6, 7, 3, 2, 7, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1},            // 1000 1010; v 1,3,7   (case 6)
        {-14, 1, 2, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 1011; v 0,1,3,7 (case 14c)
        {-5, 3, 1, 10, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 1100; v 2,3,7   (case 5b)
        {-9, 7, 8, 0, 1, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1000 1101; v 0,2,3,7 (case 9b)
        {-11, 6, 7, 3, 0, 9, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 1110; v 1,2,3,7 (case 11c)
        {-5, 9, 10, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1000 1111; v -4,-5,-6(case -5b)
        {8, 6, 4, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1001 0000; v 4,7     (case 2)
        {-5, 4, 0, 3, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 0001; v 0,4,7   (case 5b)
        {6, 8, 11, 4, 8, 6, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1},           // 1001 0010; v 1,4,7   (case 6)
        {-11, 11, 6, 4, 9, 1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 0011; v 0,1,4,7 (case 11c)
        {8, 6, 4, 11, 6, 8, 10, 2, 1, -1, -1, -1, -1, -1, -1, -1},          // 1001 0100; v 2,4,7   (case 6)
        {-12, 4, 0, 3, 11, 6, 2, 1, 10, -1, -1, -1, -1, -1, -1, -1},        // 1001 0101; v 0,2,4,7 (case 12b)
        {11, 4, 8, 6, 4, 11, 2, 0, 9, 10, 2, 9, -1, -1, -1, -1},            // 1001 0110; v 1,2,4,7 (case 10)
        //{9, 10, 2, 9, 2, 3, 4, 9, 3, 3, 11, 4, 6, 4, 11, -1},             // 1001 0111; v -3,-5,-6(case -6)
        {-6, 3, 11, 6, 4, 9, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1},        // 1001 0111; v -3,-5,-6(case -6)
        {-5, 6, 4, 8, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1001 1000; v 3,4,7   (case 5b)
        {0, 2, 4, 6, 4, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1001 1001; v 0,3,4,7 (case 8)
        {-12, 6, 4, 8, 3, 2, 9, 1, 0, -1, -1, -1, -1, -1, -1, -1},          // 1001 1010; v 1,3,4,7 (case 12b)
        {-5, 6, 4, 9, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1001 1011; v -2,-5,-6(case -5b)
        {-14, 10, 6, 4, 8, 3, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 1100; v 2,3,4,7 (case 14c)
        {-5, 4, 0, 1, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 1101; v -1,-5,-6(case -5b)
        //{6, 4, 8, 6, 8, 3, 10, 6, 3, 3, 0, 10, 9, 10, 0, -1},             // 1001 1110; v -0,-5,-6(case -6)
        {-6, 3, 0, 9, 10, 6, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1},         // 1001 1110; v -0,-5,-6(case -6)
        {10, 4, 9, 10, 6, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1001 1111; v -5,-6   (case -2)
        {9, 4, 5, 6, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1010 0000; v 5,7     (case 3)
        {8, 0, 3, 9, 4, 5, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1},           // 1010 0001; v 0,5,7   (case 7)
        {0, 5, 1, 4, 5, 0, 6, 7, 11, -1, -1, -1, -1, -1, -1, -1},           // 1010 0010; v 1,5,7   (case 6)
        {-12, 1, 3, 8, 4, 5, 6, 7, 11, -1, -1, -1, -1, -1, -1, -1},         // 1010 0011; v 0.1.5.7 (case 12b)
        {9, 4, 5, 10, 2, 1, 6, 7, 11, -1, -1, -1, -1, -1, -1, -1},          // 1010 0100; v 2,5,7   (case 7)
        {11, 6, 7, 2, 1, 10, 8, 0, 3, 9, 4, 5, -1, -1, -1, -1},             // 1010 0101; v 0,2,5,7 (case 13)
        {-12, 0, 4, 5, 10, 2, 6, 7, 11, -1, -1, -1, -1, -1, -1, -1},        // 1010 0110; v 1,2,5,7 (case 12b)
        {-7, 5, 10, 2, 3, 8, 4, 11, 6, 7, -1, -1, -1, -1, -1, -1},          // 1010 0111; v -3,-4,-6(case -7)
        {7, 3, 2, 6, 7, 2, 4, 5, 9, -1, -1, -1, -1, -1, -1, -1},            // 1010 1000; v 3,5,7   (case 6)
        {-12, 2, 6, 7, 8, 0, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1},          // 1010 1001; v 0,3,5,7 (case 12b)
        {6, 3, 2, 3, 6, 7, 5, 1, 0, 4, 5, 0, -1, -1, -1, -1},               // 1010 1010; v 1,3,5,7 (case 10)
        //{2, 6, 7, 2, 7, 8, 1, 2, 8, 8, 4, 1, 1, 4, 5, -1},                // 1010 1011; v -2,-4,-6(case -6)
        {-6, 8, 4, 5, 1, 2, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1},          // 1010 1011; v -2,-4,-6(case -6)
        {-12, 3, 1, 10, 6, 7, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1},         // 1010 1100; v 2,3,5,7 (case 12b)
        {-7, 1, 10, 6, 7, 8, 0, 9, 4, 5, -1, -1, -1, -1, -1, -1},           // 1010 1101; v -1,-4,-6(case -7)
        //{0, 4, 5, 0, 5, 10, 3, 0, 10, 10, 6, 3, 3, 6, 7, -1},             // 1010 1110; v -0,-4,-6(case -6)
        {-6, 10, 6, 7, 3, 0, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1},         // 1010 1110; v -0,-4,-6(case -6)
        {-3, 10, 6, 7, 8, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1010 1111; v -4,-6   (case -3)
        {-5, 8, 11, 6, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0000; v 4,5,7   (case 5b)
        {-9, 6, 5, 9, 0, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 0001; v 0,4,5,7 (case 9b)
        {-14, 6, 5, 1, 0, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0010; v 1,4,5,7 (case 14c)
        {-5, 1, 3, 11, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0011; v -2,-3,-6(case -5b)
        {-12, 8, 11, 6, 5, 9, 2, 1, 10, -1, -1, -1, -1, -1, -1, -1},        // 1011 0100; v 2,4,5,7 (case 12b)
        {-7, 9, 0, 3, 11, 6, 5, 10, 2, 1, -1, -1, -1, -1, -1, -1},          // 1011 0101; v -1,-3,-6(case -7)
        //{8, 11, 6, 8, 6, 5, 0, 8, 5, 5, 10, 0, 2, 0, 10, -1},             // 1011 0110; v -0,-3,-6(case -6)
        {-6, 5, 10, 2, 0, 8, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 0110; v -0,-3,-6(case -6)
        {-3, 3, 11, 6, 5, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1011 0111; v -3,-6   (case -3)
        {-11, 3, 2, 6, 5, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1000; v 3,4,5,7 (case 11c)
        {-5, 2, 6, 5, 9, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1001; v -1,-2,-6(case -5b)
        //{5, 1, 0, 5, 0, 8, 6, 5, 8, 8, 3, 6, 6, 3, 2, -1},                // 1011 1010; v -0,-2,-6(case -6)
        {-6, 8, 3, 2, 6, 5, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1},          // 1011 1010; v -0,-2,-6(case -6)
        {1, 6, 5, 1, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1011 1011; v -2,-6   (case -2)
        //{3, 1, 10, 3, 10, 6, 8, 3, 6, 6, 5, 8, 9, 8, 5, -1},              // 1011 1100; v -0,-1,-6(case -6)
        {-6, 6, 5, 9, 8, 3, 1, 10, -1, -1, -1, -1, -1, -1, -1, -1},         // 1011 1100; v -0,-1,-6(case -6)
        {-3, 0, 1, 10, 6, 5, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1101; v -1,-6   (case -3)
        {0, 8, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1011 1110; v -0,-6   (case -4)
        {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1011 1111; v -6      (case -1)
        {5, 11, 10, 5, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1100 0000; v 6,7     (case 2)
        {5, 11, 10, 11, 5, 7, 3, 8, 0, -1, -1, -1, -1, -1, -1, -1},         // 1100 0001; v 0,6,7   (case 6)
        {11, 5, 7, 10, 5, 11, 9, 1, 0, -1, -1, -1, -1, -1, -1, -1},         // 1100 0010; v 1,6,7   (case 6)
        {10, 5, 7, 11, 10, 7, 8, 9, 1, 3, 8, 1, -1, -1, -1, -1},            // 1100 0011; v 0,1,6,7 (case 10)
        {-5, 5, 7, 11, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 0100; v 2,6,7   (case 5b)
        {-12, 5, 7, 11, 2, 1, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1},         // 1100 0101; v 0,2,6,7 (case 12b)
        {-14, 11, 2, 0, 9, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 0110; v 1,2,6,7 (case 14c)
        //{5, 7, 11, 11, 2, 5, 9, 5, 2, 2, 3, 9, 8, 9, 3, -1},              // 1100 0111; v -3,-4,-5(case -6)
        {-6, 2, 3, 8, 9, 5, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1},         // 1100 0111; v -3,-4,-5(case -6)
        {-5, 7, 3, 2, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 1000; v 3,6,7   (case 5b)
        {-11, 10, 5, 7, 8, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1100 1001; v 0,3,6,7 (case 11c)
        {-12, 7, 3, 2, 10, 5, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1},         // 1100 1010; v 1,3,6,7 (case 12b)
        //{8, 9, 1, 8, 1, 2, 7, 8, 2, 2, 10, 7, 5, 7, 10, -1},              // 1100 1011; v -2,-4,-5(case -6)
        {-6, 2, 10, 5, 7, 8, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1100 1011; v -2,-4,-5(case -6)
        {3, 1, 5, 7, 3, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1100 1100; v 2,3,6,7 (case 8)
        {-5, 5, 7, 8, 0, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1100 1101; v -1,-4,-5(case -5b)
        {-5, 7, 3, 0, 9, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1100 1110; v -0,-4,-5(case -5b)
        {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1100 1111; v -4,-5   (case -2)
        {-5, 11, 10, 5, 4, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1101 0000; v 4,6,7   (case 5b)
        {-14, 3, 11, 10, 5, 4, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1101 0001; v 0,4,6,7 (case 14c)
        {-12, 11, 10, 5, 4, 8, 1, 0, 9, -1, -1, -1, -1, -1, -1, -1},        // 1101 0010; v 1,4,6,7 (case 12b)
        //{11, 10, 5, 11, 5, 4, 11, 4, 3, 9, 3, 4, 1, 3, 9, -1},            // 1101 0011; v -2,-3,-5(case -6)
        {-6, 4, 9, 1, 3, 11, 10, 5, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 0011; v -2,-3,-5(case -6)
        {-11, 4, 8, 11, 2, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1101 0100; v 2,4,6,7 (case 11c)
        //{0, 3, 4, 4, 3, 11, 5, 4, 11, 11, 2, 5, 5, 2, 1, -1},             // 1101 0101; v -1,-3,-5(case -6)
        {-6, 11, 2, 1, 5, 4, 0, 3, -1, -1, -1, -1, -1, -1, -1, -1},         // 1101 0101; v -1,-3,-5(case -6)
        //{2, 0, 9, 2, 9, 5, 11, 2, 5, 5, 4, 11, 8, 11, 4, -1},             // 1101 0110; v -0,-3,-5(case -6)
        {-6, 5, 4, 8, 11, 2, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1},         // 1101 0110; v -0,-3,-5(case -6)
        {4, 9, 5, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 0111; v -3,-5   (case -4)
        {-9, 5, 4, 8, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 1000; v 3,4,6,7 (case 9b)
        {-5, 0, 2, 10, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1101 1001; v -1,-2,-5(case -5b)
        {-7, 5, 4, 8, 3, 2, 10, 9, 1, 0, -1, -1, -1, -1, -1, -1},           // 1101 1010; v -0,-2,-5(case -7)
        {-3, 2, 10, 5, 4, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 1011; v -2,-5   (case -3)
        {-5, 1, 5, 4, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1101 1100; v -0,-1,-5(case -5b)
        {4, 0, 5, 0, 1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1101 1101; v -1,-5   (case -2)
        {-3, 5, 4, 8, 3, 0, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1101 1110; v -0,-5   (case -3)
        {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1101 1111; v -5      (case -1)
        {-5, 10, 9, 4, 7, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1110 0000; v 5,6,7   (case 5b)
        {-12, 10, 9, 4, 7, 11, 8, 0, 3, -1, -1, -1, -1, -1, -1, -1},        // 1110 0001; v 0,5,6,7 (case 12b)
        {-11, 7, 11, 10, 1, 0, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1110 0010; v 1,5,6,7 (case 11c)
        //{1, 3, 8, 1, 8, 4, 10, 1, 4, 4, 7, 10, 11, 10, 7, -1},            // 1110 0011; v -2,-3,-4(case -6)
        {-6, 4, 7, 11, 10, 1, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 0011; v -2,-3,-4(case -6)
        {-9, 11, 2, 1, 9, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 0100; v 2,5,6,7 (case 9b)
        {-7, 9, 4, 7, 11, 2, 1, 8, 0, 3, -1, -1, -1, -1, -1, -1},           // 1110 0101; v -1,-3,-4(case -7)
        {-5, 0, 4, 7, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1110 0110; v -0,-3,-4(case -5b)
        {-3, 4, 7, 11, 2, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 0111; v -3,-4   (case -3)
        {-14, 4, 7, 3, 2, 10, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1110 1000; v 3,5,6,7 (case 14c)
        //{10, 9, 4, 10, 4, 7, 2, 10, 7, 7, 8, 2, 0, 2, 8, -1},             // 1110 1001; v -1,-2,-4(case -6)
        {-6, 7, 8, 0, 2, 10, 9, 4, -1, -1, -1, -1, -1, -1, -1, -1},         // 1110 1001; v -1,-2,-4(case -6)
        //{7, 3, 2, 7, 2, 10, 4, 7, 10, 10, 1, 4, 0, 4, 1, -1},             // 1110 1010; v -0,-2,-4(case -6)
        {-6, 10, 1, 0, 4, 7, 3, 2, -1, -1, -1, -1, -1, -1, -1, -1},         // 1110 1010; v -0,-2,-4(case -6)
        {10, 1, 2, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 1011; v -2,-4   (case -4)
        {-5, 3, 1, 9, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1110 1100; v -0,-1,-4(case -5b)
        {-3, 1, 9, 4, 7, 8, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1110 1101; v -1,-4   (case -3)
        {4, 3, 0, 4, 7, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1110 1110; v -0,-4   (case -2)
        {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1110 1111; v -4      (case -1)
        {10, 9, 8, 11, 10, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0000; v 4,5,6,7 (case 8)
        {-5, 10, 9, 0, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0001; v -1,-2,-3(case -5b)
        {-5, 11, 10, 1, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0010; v -0,-2,-3(case -5b)
        {1, 3, 10, 3, 11, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 0011; v -2,-3   (case -2)
        {-5, 8, 11, 2, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1111 0100; v -0,-1,-3(case -5b)
        {-3, 9, 0, 3, 11, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1111 0101; v -1,-3   (case -3)
        {2, 0, 11, 0, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1111 0110; v -0,-3   (case -2)
        {2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1111 0111; v -3      (case -1)
        {-5, 9, 8, 3, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 1111 1000; v -0,-1,-2(case -5b)
        {10, 9, 2, 9, 0, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1111 1001; v -1,-2   (case -2)
        {-3, 3, 2, 10, 1, 0, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1},        // 1111 1010; v -0,-2   (case -3)
        {10, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 1111 1011; v -2      (case -1)
        {3, 1, 8, 1, 9, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},         // 1111 1100; v -0,-1   (case -2)
        {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 1101; v -1      (case -1)
        {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 1111 1110; v -0      (case -1)
        {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}    // 1111 1111; all       (case 0)
    };


    template <class T>
    TilingNonobtuseMC<T>::TilingNonobtuseMC()
        : NonobtuseMC<T>::NonobtuseMC(),
        iNextUnusedVertexId(0),
        iNextUnusedEdgeId(0),
        iNumCubeMultiPatch(0),
        iNumPatchIgnored(0),
        iNumFaceStitching(0),
        iNumNonManifoldFix(0)
    {
    }


    template <class T>
    TilingNonobtuseMC<T>::~TilingNonobtuseMC()
    {
        this->deleteSurface();
    }

    // clean up all members
    template <class T>
    void TilingNonobtuseMC<T>::deleteSurface()
    {
        NonobtuseMC<T>::deleteSurface();
        this->iCubesProperty.clear();
        this->iVonE.clear();
        this->iV2EofCube.clear();
        this->iEonF.clear();
        this->iE2F.clear();
        this->iEdgeList.clear();
        this->iVPair2E.clear();
        this->iV2E.clear();
        this->iV2Tri.clear();
        this->iE2Tri.clear();
        this->iTri2Patch.clear();
        this->iTri2CubeId.clear();
        this->iNextUnusedVertexId = 0;
        this->iNextUnusedEdgeId = 0;
        this->iClosestTriList.clear();
        this->iNumCubeMultiPatch = 0;
        this->iNumPatchIgnored = 0;
        this->iNumFaceStitching = 0;
        this->iNumNonManifoldFix = 0;
    }

    // Generates the isosurface from the source mesh
    // Modified from the base class to give nonobtuse marching cube without using a scalarfield
    // surfaceType = MIDPOINT
    //
    // vertexList (in): source mesh's vertices list
    // polygonList (in): source mesh's polygons list
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // isoLevel (in): isolevel
    // cellsX (in): number of cells in x-dim
    // cellsY (in): number of cells in y-dim
    // cellsZ (in): number of cells in z-dim
    // cellLengthX (in): cell length in x-dim
    // cellLengthY (in): cell length in y-dim
    // cellLengthZ (in): cell length in z-dim
    // return value (out): time taken
    template <class T>
    clock_t TilingNonobtuseMC<T>::generateSurface(
        const std::vector<cv::Point3d>& vertexList,
        const std::vector<std::vector<uint>>& polygonList,
        const std::vector<uint>* polygonNeighbourList,
        T isoLevel,
        uint cellsX,
        uint cellsY,
        uint cellsZ,
        double cellLengthX,
        double cellLengthY,
        double cellLengthZ)
    {
        // sanity checks
        if(vertexList.empty() || polygonList.empty())
        {
            return 0;
        }
        // delete old data
        if(this->iValidSurface)
        {
            this->deleteSurface();
        }
        // update members
        this->iIsoLevel = isoLevel;
        this->iCellsX = cellsX;
        this->iCellsY = cellsY;
        this->iCellsZ = cellsZ;
        this->iCellLengthX = cellLengthX;
        this->iCellLengthY = cellLengthY;
        this->iCellLengthZ = cellLengthZ;
        clock_t beforeTime = clock();
        clock_t afterTime = clock();
        // computing mesh centroid
        cv::Point3d meshCentroid(0, 0, 0);
        for(std::vector<cv::Point3d>::const_iterator vIter = vertexList.begin(); vIter != vertexList.end(); ++vIter)
        {
            meshCentroid += *vIter;
        }
        meshCentroid /= vertexList.size();
        double mcBoxLength[3] = {cellsX * cellLengthX, cellsY * cellLengthY, cellsZ * cellLengthZ};
        this->iOffsets[0] = meshCentroid.x - mcBoxLength[0] / 2;
        this->iOffsets[1] = meshCentroid.y - mcBoxLength[1] / 2;
        this->iOffsets[2] = meshCentroid.z - mcBoxLength[2] / 2;
        // ------- STAGE 1: determine which cubes are intersected by which triangle -------
        this->markIntersectedCubes(vertexList, polygonList);
        // ------- STAGE 2: for each intersected cube, determine the signs and triangulate -------
        // make sure we have room to put out data in this->iVonE and this->iEonF
        // 10 edges per cell: 0,3,8,12,13,14,15,16,17,18,19
        this->iVonE.resize(11 * (cellsX + 1) * (cellsY + 1) * (cellsZ + 1));
        this->iEonF.resize(3 * (cellsX + 1) * (cellsY + 1) * (cellsZ + 1)); // faces are index by cubeIdx + {0,1,2}
        std::cout << "Start triangulating ... " << std::endl;
        // triangulate each cube
        for(uint z = 0; z < cellsZ; ++z)
        {
            for(uint y = 0; y < cellsY; ++y)
            {
                for(uint x = 0; x < cellsX; ++x)
                {
                    //std::cout << "Triangulating cube(" << x << ", " << y << ", " << z << ")" << std::endl;
                    this->triangulate(x, y, z, vertexList, polygonList, polygonNeighbourList);
                }
            }
        }
        std::cout << "Start stitching ... " << std::endl;
        // post process stitching
        for(uint z = 0; z <= cellsZ; ++z)
        {
            for(uint y = 0; y <= cellsY; ++y)
            {
                for(uint x = 0; x <= cellsX; ++x)
                {
                    // std::cout << "Stitching cube(" << x << ", " << y << ", " << z << ")" << std::endl;
                    this->checkStitching(x, y, z, polygonNeighbourList);
                }
            }
        }
        // rename the vertex ids
        this->renameVerticesAndTriangles(vertexList, polygonList);
        this->iValidSurface = true;
        afterTime = clock();
        clock_t totalTime = (afterTime - beforeTime) / CLOCKS_PER_SEC;
        std::cout << "Total processed time: " << totalTime << " seconds." << std::endl;
        std::cout << "Total number of cubes with multiple patches: " << this->iNumCubeMultiPatch << std::endl;
        std::cout << "Total number of patches ignored: " << this->iNumPatchIgnored << std::endl;
        std::cout << "Total number of faces needed for stitching: " << this->iNumFaceStitching << std::endl;
        std::cout << "Total number of non-manifold fix: " << this->iNumNonManifoldFix << std::endl;
        return totalTime;
    }

    // Generates the isosurface from the source mesh (using simple MC)
    // surfaceType = MIDPOINT
    //
    // vertexList (in): source mesh's vertices list
    // numVertices (in): number of vertices in source mesh
    // polygonList (in): source mesh's polygons list
    // numPolygons (in): number of polygons in source mesh
    // vertexNeighbourList (in): vertex-to-polygon neighbour information for source mesh
    // isoLevel (in): isolevel
    // cellsX (in): number of cells in x-dim
    // cellsY (in): number of cells in y-dim
    // cellsZ (in): number of cells in z-dim
    // cellLengthX (in): cell length in x-dim
    // cellLengthY (in): cell length in y-dim
    // cellLengthZ (in): cell length in z-dim
    // return value (out): time taken
    template <class T>
    clock_t TilingNonobtuseMC<T>::generateSurfaceSimpleMC(
        const std::vector<cv::Point3d>& vertexList,
        const std::vector<std::vector<uint>>& polygonList,
        const std::vector<uint>* vertexNeighbourList,
        T isoLevel,
        uint cellsX,
        uint cellsY,
        uint cellsZ,
        double cellLengthX,
        double cellLengthY,
        double cellLengthZ)
    {
        // sanity checks
        if(vertexList.empty() || polygonList.empty())
        {
            return 0;
        }
        // delete old data
        if(this->iValidSurface)
        {
            this->deleteSurface();
        }
        // update members
        this->iIsoLevel = isoLevel;
        this->iCellsX = cellsX;
        this->iCellsY = cellsY;
        this->iCellsZ = cellsZ;
        this->iCellLengthX = cellLengthX;
        this->iCellLengthY = cellLengthY;
        this->iCellLengthZ = cellLengthZ;

        clock_t beforeTime = clock();
        clock_t afterTime = clock();

        // computing mesh centroid
        cv::Point3d meshCentroid(0, 0, 0);
        for(std::vector<cv::Point3d>::const_iterator vIter = vertexList.begin(); vIter != vertexList.end(); ++vIter)
        {
            meshCentroid += *vIter;
        }
        meshCentroid /= vertexList.size();
        double mcBoxLength[3] = {cellsX * cellLengthX, cellsY * cellLengthY, cellsZ * cellLengthZ};
        this->iOffsets[0] = meshCentroid.x - mcBoxLength[0] / 2;
        this->iOffsets[1] = meshCentroid.y - mcBoxLength[1] / 2;
        this->iOffsets[2] = meshCentroid.z - mcBoxLength[2] / 2;
        // ------- STAGE 1: determine which cubes are intersected by which triangle -------
        this->markIntersectedCubes(vertexList, polygonList);
        // ------- STAGE 2: triangulate using simple MC -------
        this->triangulateSimpleMC(vertexList, polygonList, vertexNeighbourList);
        afterTime = clock();
        clock_t totalTime = (afterTime - beforeTime) / CLOCKS_PER_SEC;
        std::cout << "Total processed time: " << totalTime << " seconds." << std::endl;
        return totalTime;
    }

    // returns the list of closest triangle for each vertex; -1 if no closest triangle
    //
    // this->iClosestTriList (out): array of associated triangles to return
    // return value (out): number of slots in array
    template <class T>
    const std::vector<uint>& TilingNonobtuseMC<T>::getClosestTriList() const
    {
        return this->iClosestTriList;
    }

    // triangulate the intersected cubes using simple MC
    //
    // vertexList (in): source mesh's vertices list
    // numVertices (in): number of vertices in source mesh
    // polygonList (in): source mesh's polygons list
    // numPolygons (in): number of polygons in source mesh
    // vertexNeighbourList (in): vertex-to-polygon neighbour information for source mesh
    template <class T>
    void TilingNonobtuseMC<T>::triangulateSimpleMC(
        const std::vector<cv::Point3d>& vertexList,
        const std::vector<std::vector<uint>>& polygonList,
        const std::vector<uint>* vertexNeighbourList)
    {
        uint surfaceType = MIDPOINT;
        //this->iAllTableIndex = new uint[this->iCellsX * this->iCellsY * this->iCellsZ];
        // stores scalarfield for each grid point; + outside, - inside
        uint numScalars = (this->iCellsX + 1) * (this->iCellsY + 1) * (this->iCellsZ + 1);
        T* sField = new T[numScalars];
        this->iScalarField = sField;
        std::vector<bool> isValidScalar;
        isValidScalar.resize(numScalars, false);
        // quick indexing for locating where the cube is relative to edge
        uint cubeLocRelToEdge[12] = {3, 2, 2, 3, 1, 0, 0, 1, 3, 1, 0, 2};    
        // stores vertex to tri relationship at the adjacent cubes 0,1,2,3
        std::vector<std::vector<std::vector<uint>>> v2tri(3 * numScalars, std::vector<std::vector<uint>>(4));
        uint nextExtraVId = this->getEdgeId(this->iCellsX - 1, this->iCellsY - 1, this->iCellsZ - 1, 19) + 1;
        // Generate isosurface.
        for(uint z = 0; z < this->iCellsZ; z++)
        {
            for(uint y = 0; y < this->iCellsY; y++)
            {
                for(uint x = 0; x < this->iCellsX; x++)
                {
                    uint cubeIdx = this->iCellsX * this->iCellsY * z + this->iCellsX * y + x;
                    // only triangulate cubes that are intersected
                    //if(this->iCubesProperty[cubeIdx].iIntTriVec.empty())
                    //{
                    //    continue;
                    //}
                    if(!this->iCubesProperty[cubeIdx].iIntTriVec.empty())
                    {
                        // Calculate table lookup index from those vertices which are below the isolevel.
                        uint tableIndex = 0;
                        //    1----2
                        //   /|  / |
                        // 5----6  |
                        // | /0-|--3
                        // |/   |/
                        // 4----7
                        uint closestTriIdx = 0;
                        uint gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * y + x;
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x, y, z, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 1;
                        }
                        closestTriIdx = 0;
                        gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * (y + 1) + x;
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x, y + 1, z, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 2;
                        }
                        closestTriIdx = 0;
                        gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * (y + 1) + (x + 1);
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x + 1, y + 1, z, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 4;
                        }
                        closestTriIdx = 0;
                        gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * y + (x + 1);
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x + 1, y, z, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 8;
                        }
                        closestTriIdx = 0;
                        gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * y + x;
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x, y, z + 1, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 16;
                        }
                        closestTriIdx = 0;
                        gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * (y + 1) + x;
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x, y + 1, z + 1, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 32;
                        }
                        closestTriIdx = 0;
                        gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * (y + 1) + (x + 1);
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x + 1, y + 1, z + 1, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 64;
                        }
                        closestTriIdx = 0;
                        gridIdx = (this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * y + (x + 1);
                        if(!isValidScalar[gridIdx])
                        {
                            if(this->getScalar(x + 1, y, z + 1, closestTriIdx, vertexList, polygonList, vertexNeighbourList) >= 0)
                            {
                                sField[gridIdx] = 1;
                            }
                            else
                            {
                                sField[gridIdx] = -1;
                            }
                            isValidScalar[gridIdx] = true;
                        }
                        if(sField[gridIdx] >= this->iIsoLevel)
                        {
                            tableIndex |= 128;
                        }
                        //this->iAllTableIndex[z * this->iCellsX * this->iCellsY + y * this->iCellsX + x] = tableIndex;
                        uint nbrXIdx = this->iCellsX * this->iCellsY * z + this->iCellsX * y + (x + 1);
                        uint nbrYIdx = this->iCellsX * this->iCellsY * z + this->iCellsX * (y + 1) + x;
                        uint nbrZIdx = this->iCellsX * this->iCellsY * (z + 1) + this->iCellsX * y + x;
                        uint nbrXYIdx = this->iCellsX * this->iCellsY * z + this->iCellsX * (y + 1) + (x + 1);
                        uint nbrXZIdx = this->iCellsX * this->iCellsY * (z + 1) + this->iCellsX * y + (x + 1);
                        uint nbrYZIdx = this->iCellsX * this->iCellsY * (z + 1) + this->iCellsX * (y + 1) + x;
                        // Now create a triangulation of the isosurface in this cell.
                        if(this->iEdgeTable[tableIndex] != 0)
                        {
                            if(this->iEdgeTable[tableIndex] & 8)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 3, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 3);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                            if(this->iEdgeTable[tableIndex] & 1)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 0, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 0);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                            if(this->iEdgeTable[tableIndex] & 256)
                            {
                                Point3dId pt = this->calculateIntersection(x, y, z, 8, surfaceType);
                                pt.iId = 0;
                                uint id = this->getEdgeId(x, y, z, 8);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                            }
                            if((x == this->iCellsX - 1) || this->iCubesProperty[nbrXIdx].iIntTriVec.empty())
                            {
                                if(this->iEdgeTable[tableIndex] & 4)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 2, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 2);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                                if(this->iEdgeTable[tableIndex] & 2048)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 11, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 11);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                            }
                            if((y == this->iCellsY - 1) || this->iCubesProperty[nbrYIdx].iIntTriVec.empty())
                            {
                                if(this->iEdgeTable[tableIndex] & 2)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 1, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 1);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                                if(this->iEdgeTable[tableIndex] & 512)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 9, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 9);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                            }
                            if((z == this->iCellsZ - 1) || this->iCubesProperty[nbrZIdx].iIntTriVec.empty())
                            {
                                if(this->iEdgeTable[tableIndex] & 16)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 4, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 4);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                                if(this->iEdgeTable[tableIndex] & 128)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 7, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 7);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                            }
                            if(((x == this->iCellsX - 1) && (y == this->iCellsY - 1)) || this->iCubesProperty[nbrXYIdx].iIntTriVec.empty())
                            {
                                if(this->iEdgeTable[tableIndex] & 1024)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 10, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 10);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                            }
                            if(((x == this->iCellsX - 1) && (z == this->iCellsZ - 1)) || this->iCubesProperty[nbrXZIdx].iIntTriVec.empty())
                            {
                                if(this->iEdgeTable[tableIndex] & 64)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 6, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 6);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                            }
                            if(((y == this->iCellsY - 1) && (z == this->iCellsZ - 1)) || this->iCubesProperty[nbrYZIdx].iIntTriVec.empty())
                            {
                                if(this->iEdgeTable[tableIndex] & 32)
                                {
                                    Point3dId pt = this->calculateIntersection(x, y, z, 5, surfaceType);
                                    pt.iId = 0;
                                    uint id = this->getEdgeId(x, y, z, 5);
                                    this->iId2Point3dId.insert(Id2Point3dId::value_type(id, pt));
                                }
                            }
                            if(this->iTriTable[tableIndex][0] == -3)
                            {
                                // -3:    Special Case -3
                                // {-3, a, b, c, d, e, f, -1, ... }
                                // where a,b,c,d forms a quad, and d,e,f,a forms the other quad
                                // The right hand ordering determines the normals
                                // A new point m should be added to the midpoint of a,d
                                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                                // get point a, d
                                Point3dId pta;
                                Point3dId ptd;
                                pta = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], surfaceType);
                                ptd = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], surfaceType);

                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (pta.iPt + ptd.iPt) * 0.5;

                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 18);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));

                                // create triangles
                                for(uint i = 1; i <= 6; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, 18);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);

                                    // store v-to-tri info
                                    uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                    uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                    uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 6 + 1]];
                                    v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                }
                            }
                            else if(this->iTriTable[tableIndex][0] == -5)
                            {
                                // -5:  Special Case 5b
                                // {-5, a, b, c, d, e, -1, ... }
                                // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
                                // The right hand ordering determins the normals
                                // A new point m should be added to the midpoint of b,e
                                // Then, the 5 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, -1}

                                // get point b, e
                                Point3dId ptb;
                                Point3dId pte;
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);

                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;
    
                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 12);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
                    
                                // create triangles
                                for(uint i = 1; i <= 5; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 5 + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, 12);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                    uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                    uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 5 + 1]);
                                    uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 5 + 1]];
                                    v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                }
                            }
                            else if  (this->iTriTable[tableIndex][0] == -6)
                            {
                                // -6:    Special Case -6
                                // {-3, a, b, c, d, e, f, g, -1, ... }
                                // where a,b,c,d,e,f,g forms a seven-agon
                                // The right hand ordering determines the normals
                                // A new point m should be added to the center of cube
                                // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, g, m, g, a, m, -1}
    
                                // get point a, d
                                Point3dId ptb;
                                Point3dId pte;
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
                            
                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;
    
                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 19);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
                            
                                // create triangles
                                for(uint i = 1; i <= 7; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 7 + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, 19);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                    uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                    uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 7 + 1]);
                                    uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 7 + 1]];
                                    v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                }
                            }
                            else if(this->iTriTable[tableIndex][0] == -7)
                            {
                                // -7:  Special Case -7
                                // {-7, a, b, c, d, e, f, i, j, k, -1, ... }
                                // where a,b,c,d,e,f forms a hexagon and i,j,k forms a triangle
                                // The right hand ordering determines the normals
                                // A new point m should be added to the centroid of a,b,c,d,e,f
                                // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, i, j, k, -1}

                                // get point b, e
                                Point3dId ptb;
                                Point3dId pte;
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
    
                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;
    
                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 17);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
    
                                // create triangles
                                for(uint i = 1; i <= 7; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    if(i == 7)
                                    {
                                        pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                        pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 1]);
                                        pointId2 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 2]);
                                    }
                                    else
                                    {
                                        pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                        pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                        pointId2 = this->getEdgeId(x, y, z, 17);
                                    }
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    if(i == 7)
                                    {
                                        uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                        uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                        uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i + 1]);
                                        uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i + 1]];
                                        uint edgeIdx3 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i + 2]);
                                        uint cubePos3 = cubeLocRelToEdge[this->iTriTable[tableIndex][i + 2]];
                                        v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                        v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                        v2tri[edgeIdx3][cubePos3].push_back(this->iTriangleVec.size() - 1);
                                    }
                                    else
                                    {
                                        uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                        uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                        uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                        uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 6 + 1]];
                                        v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                        v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                    }
                                }
                            }
                            else if(this->iTriTable[tableIndex][0] == -9)
                            {
                                // -9:  Special Case 9b
                                // {-9, a, b, c, d, e, f, -1, ... }
                                // where a,b,c,d,e,f forms a hexagon.
                                // The right hand ordering determines the normals
                                // A new point m should be added to the centroid of a,b,c,d,e,f
                                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
    
                                // get point b, e
                                Point3dId ptb;
                                Point3dId pte;
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
    
                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;
    
                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 13);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
    
                                // create triangles
                                for(uint i = 1; i <= 6; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, 13);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                    uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                    uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 6 + 1]];
                                    v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                }
                            }
                            else if(this->iTriTable[tableIndex][0] == -11)    
                            {
                                // -11: Special Case 11c
                                // {-11, a, b, c, d, e, f, -1, ... ]
                                // where a,b,c,d,e,f forms a bent hexagon.
                                //       new point m is added in the center of the cube
                                //       b,c,m and e,f,m are right isoscele triangles
                                //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
                                // The right hand ordering determines the normals
                                // A new point m should be added to the center of cube (ie. midpoint of a and d)
                                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
    
                                // get point a, d
                                Point3dId pta = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], surfaceType);
                                Point3dId ptd = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], surfaceType);
    
                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (pta.iPt + ptd.iPt) * 0.5;
    
                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 14);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
    
                                // create triangles
                                for(uint i = 1; i <= 6; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, 14);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                    uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                    uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 6 + 1]];
                                    v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                }
                            }
                            else if(this->iTriTable[tableIndex][0] == -12)
                            {
                                // -12: Special Case 12b
                                // {-12, a, b, c, d, e, i, j, k, -1, ... }
                                // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
                                //       and i, j, k forms a seperate triangle
                                // The right hand ordering determines the normals
                                // A new point m should be added to the midpoint of b,e
                                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, a, m, i, j, k, -1}
    
                                // get point b, e
                                Point3dId ptb;
                                Point3dId pte;
                                ptb = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][2], surfaceType);
                                pte = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][5], surfaceType);
    
                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (ptb.iPt + pte.iPt) * 0.5;
    
                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 15);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
    
                                // create triangles
                                for(uint i = 1; i <= 6; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    uint idx2 = this->iTriTable[tableIndex][i % 5 + 1];
                                    uint idx3 = 15;
                                    if(i == 6)
                                    {
                                        idx2 = this->iTriTable[tableIndex][i + 1];
                                        idx3 = this->iTriTable[tableIndex][i + 2];
                                    }
                                
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, idx2);
                                    pointId2 = this->getEdgeId(x, y, z, idx3);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    if(i == 6)
                                    {
                                        uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                        uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                        uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i + 1]);
                                        uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i + 1]];
                                        uint edgeIdx3 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i + 2]);
                                        uint cubePos3 = cubeLocRelToEdge[this->iTriTable[tableIndex][i + 2]];
                                        v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                        v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                        v2tri[edgeIdx3][cubePos3].push_back(this->iTriangleVec.size() - 1);
                                    }
                                    else
                                    {
                                        uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                        uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                        uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 5 + 1]);
                                        uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 5 + 1]];
                                        v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                        v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                    }
                                }
                            }
                            else if(this->iTriTable[tableIndex][0] == -14)    
                            {
                                // -14: Special Case 14c
                                // {-14, a, b, c, d, e, f, -1, ... ]
                                // where a,b,c,d,e,f forms a bent hexagon.
                                //       new point m is added in the center of the cube
                                //       b,c,m and e,f,m are right isoscele triangles
                                //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
                                // The right hand ordering determines the normals
                                // A new point m should be added to the center of cube (ie. midpoint of a and d)
                                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}
    
                                // get point a, d
                                Point3dId pta = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][1], surfaceType);
                                Point3dId ptd = this->calculateIntersection(x, y, z, this->iTriTable[tableIndex][4], surfaceType);
    
                                // calculate midpoint m
                                Point3dId ptm;
                                ptm.iId = 0;
                                ptm.iPt = (pta.iPt + ptd.iPt) * 0.5;
    
                                // add vertex m
                                uint id = this->getEdgeId(x, y, z, 16);
                                this->iId2Point3dId.insert(Id2Point3dId::value_type(id, ptm));
    
                                // create triangles
                                for(uint i = 1; i <= 6; ++i)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, 16);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                    uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                    uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i % 6 + 1]);
                                    uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i % 6 + 1]];
                                    v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                }
                            }
                            else
                            {
                                for(uint i = 0; this->iTriTable[tableIndex][i] != -1; i += 3)
                                {
                                    Triangle triangle;
                                    uint pointId0, pointId1, pointId2;
                                    pointId0 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i]);
                                    pointId1 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 1]);
                                    pointId2 = this->getEdgeId(x, y, z, this->iTriTable[tableIndex][i + 2]);
                                    triangle.x = pointId0;
                                    triangle.y = pointId1;
                                    triangle.z = pointId2;
                                    this->iTriangleVec.push_back(triangle);
    
                                    // store v-to-tri info
                                    uint edgeIdx1 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i]);
                                    uint cubePos1 = cubeLocRelToEdge[this->iTriTable[tableIndex][i]];
                                    uint edgeIdx2 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i + 1]);
                                    uint cubePos2 = cubeLocRelToEdge[this->iTriTable[tableIndex][i + 1]];
                                    uint edgeIdx3 = edgeIndexing(x, y, z, this->iTriTable[tableIndex][i + 2]);
                                    uint cubePos3 = cubeLocRelToEdge[this->iTriTable[tableIndex][i + 2]];
                                    v2tri[edgeIdx1][cubePos1].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx2][cubePos2].push_back(this->iTriangleVec.size() - 1);
                                    v2tri[edgeIdx3][cubePos3].push_back(this->iTriangleVec.size() - 1);
                                }
                            }
                        }
                    }

                    // check for non-manifold vertices
                    for(uint i = 0; i < 3; ++i)
                    {
                        uint edge = 3;
                        if(i == 1)
                        {
                            edge = 0;
                        }
                        else if(i == 2)
                        {
                            edge = 8;
                        }
                        uint edgeIdx = edgeIndexing(x, y, z, edge);

                        // non-manifold vertices occur when diagonal cubes generate triangles where as the other diagonal cubes do not
                        uint indexToChange = 0;
                        if(!v2tri[edgeIdx][0].empty() &&
                            v2tri[edgeIdx][1].empty() &&
                            v2tri[edgeIdx][2].empty() &&
                            !v2tri[edgeIdx][3].empty())
                        {
                            indexToChange = 3;
                        }
                        else if(v2tri[edgeIdx][0].empty() &&
                            !v2tri[edgeIdx][1].empty() &&
                            !v2tri[edgeIdx][2].empty() &&
                            v2tri[edgeIdx][3].empty())
                        {
                            indexToChange = 2;
                        }
                        else
                        {
                            continue;
                        }
                        // split the vertex into two
                        uint vertexId = this->getEdgeId(x, y, z, edge);
                        uint newVId = nextExtraVId;
                        Point3dId ptm;
                        ptm.iId = 0;
                        ptm.iPt = this->iId2Point3dId[vertexId];
                        this->iId2Point3dId.insert(Id2Point3dId::value_type(newVId, ptm));
                        ++nextExtraVId;

                        for(uint j = 0; j < v2tri[edgeIdx][indexToChange].size(); ++j)
                        {
                            uint triIdx = v2tri[edgeIdx][indexToChange][j];
                            for(uint k = 0; k < 3; ++k)
                            {
                                if(this->iTriangleVec[triIdx].pointId[k] == vertexId)
                                {
                                    this->iTriangleVec[triIdx].pointId[k] = newVId;
                                    break;
                                }
                            }                        
                        }
                    }
                }
            }
        }
        IsoSurface<T>::renameVerticesAndTriangles();
        this->calculateNormals();
        this->iValidSurface = true;
    
        delete [] sField;
        this->iScalarField = NULL;
        //delete [] this->iAllTableIndex;
        //this->iAllTableIndex = NULL;
    }

    // returns the edge index
    //
    // x (in): cube x-coord
    // y (in): cube y-coord
    // z (in): cube z-coord
    // edgeIdx (in): edge index of cube (x,y,z)
    // return value (out): edge index being query
    template <class T>
    uint TilingNonobtuseMC<T>::edgeIndexing(uint x, uint y, uint z, uint edgeIdx) const
    {
        if(edgeIdx == 0)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * y + x) + 1;
        else if(edgeIdx == 1)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * (y + 1) + x) + 0;
        else if(edgeIdx == 2)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * y + (x + 1)) + 1;
        else if(edgeIdx == 3)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * y + x) + 0;
        else if(edgeIdx == 4)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * y + x) + 1;
        else if(edgeIdx == 5)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * (y + 1) + x) + 0;
        else if(edgeIdx == 6)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * y + (x + 1)) + 1;
        else if(edgeIdx == 7)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * (z + 1) + (this->iCellsX + 1) * y + x) + 0;
        else if(edgeIdx == 8)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * y + x) + 2;
        else if(edgeIdx == 9)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * (y + 1) + x) + 2;
        else if(edgeIdx == 10)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * (y + 1) + (x + 1)) + 2;
        else if(edgeIdx == 11)
            return 3 * ((this->iCellsX + 1) * (this->iCellsY + 1) * z + (this->iCellsX + 1) * y + (x + 1)) + 2;
        else
            return 0;
    }

    // post-processing for eliminating non-manifold vertices introduced during construction using simpleMC
    //
    template <class T>
    void TilingNonobtuseMC<T>::postProcessSimpleMC()
    {
    }

    // returns the scalar of grid point at (x,y,z); also return the closest triangle in the original mesh
    //
    // x (in): x-coord of cube
    // y (in): y-coord of cube
    // z (in): z-coord of cube
    // closestTriIdx (out): index of closest triangle in original mesh 
    // vertexList (in): source mesh's vertices list
    // polygonList (in): source mesh's polygons list
    // vertexNeighbourList (in): vertex-to-polygon neighbour information for source mesh
    // return val (out): scalar value of the grid point
    template <class T>
    double TilingNonobtuseMC<T>::getScalar(
        uint x,
        uint y,
        uint z,
        uint& closestTriIdx,
        const std::vector<cv::Point3d>& vertexList,
        const std::vector<std::vector<uint>>& polygonList,
        const std::vector<uint>* vertexNeighbourList) const
    {
        // geometry of grid point
        cv::Point3d pt(x * this->iCellLengthX + this->iOffsets[0], y * this->iCellLengthY + this->iOffsets[1], z * this->iCellLengthZ + this->iOffsets[2]);
        closestTriIdx = 0;
        double closestDist = -1;
        cv::Point3d closestPt(0, 0, 0);
        double closestPtType = 0;   // determines if closest pt is inside triangle, on edge, or at a vertex
                                    //  0 - closest pt is inside triangle,
                                    //  1 - closest pt is tript1,
                                    //  2 - closest pt is tript2,
                                    //  3 - closest pt is tript3,
                                    // -1 - closest pt is on edge (tript1, tript2),
                                    // -2 - closest pt is on edge (tript2, tript3),
                                    // -3 - closest pt is on edge (tript3, tript1),

        // offset for the cubes to check; 1st 8 are the cubes that share the grid point; others are direct neighbours of those 8 cubes
        const int nbrCubesOffset[32][3] =
        {
            { 0,  0,  0},
            { 0,  0, -1},
            {-1,  0, -1},
            {-1,  0,  0},
            { 0, -1,  0},
            { 0, -1, -1},
            {-1, -1, -1},
            {-1, -1,  0},

            { 1,  0,  0},
            { 1,  0, -1},
            { 1, -1,  0},
            { 1, -1, -1},
            {-2,  0,  0},
            {-2,  0, -1},
            {-2, -1,  0},
            {-2, -1, -1},

            { 0,  1,  0},
            { 0,  1, -1},
            {-1,  1,  0},
            {-1,  1, -1},
            { 0, -2,  0},
            { 0, -2, -1},
            {-1, -2,  0},
            {-1, -2, -1},

            { 0,  0,  1},
            { 0, -1,  1},
            {-1,  0,  1},
            {-1, -1,  1},
            { 0,  0, -2},
            { 0, -1, -2},
            {-1,  0, -2},
            {-1, -1, -2}
        };

        for(uint i = 0; i < 32; ++i) // check all 8 + 24 neighbour cubes for closest triangle
        {
            // check if closest triangle lies in the adjacent 8 cubes
            if(i > 7 && closestDist < this->iCellLengthX && closestDist > 0)
            {
                break;
            }
            uint cubeIdx = this->iCellsX * this->iCellsY * (z + nbrCubesOffset[i][2]) + this->iCellsX * (y + nbrCubesOffset[i][1]) + (x + nbrCubesOffset[i][0]);

            // check cubes that have intersected triangles only
            if(this->iCubesProperty[cubeIdx].iIntTriVec.empty())
            {
                continue;
            }
            for(uint j = 0; j < this->iCubesProperty[cubeIdx].iIntTriVec.size(); ++j)
            {
                uint triIdx = this->iCubesProperty[cubeIdx].iIntTriVec[j].iTriIdx;
                cv::Point3d triPt1 = vertexList[polygonList[triIdx][0]];
                cv::Point3d triPt2 = vertexList[polygonList[triIdx][1]];
                cv::Point3d triPt3 = vertexList[polygonList[triIdx][2]];
                cv::Point3d closestPt_tri;
                double dist;
                int returnCode = Utility::pointTriangleDistance(pt, triPt1, triPt2, triPt3, closestPt_tri, dist);
                if(closestDist == -1 || dist < closestDist)
                {
                    closestTriIdx = triIdx;
                    closestDist = dist;
                    closestPt = closestPt_tri;
                    closestPtType = returnCode;
                }
            }
        }

        // after finding closest triangle, now use it to compute scalar field
        if(closestDist == -1) // can't find a closest triangle
        {
            //std::cout << "this shouldn't happen!" << std::endl;
            return 0;
        }
    
        cv::Point3d normal(0, 0, 0);
        if(closestPtType == 0) // closest pt is inside triangle
        {
            // get closest triangle's face normal
            cv::Point3d triPt1 = vertexList[polygonList[closestTriIdx][0]];
            cv::Point3d triPt2 = vertexList[polygonList[closestTriIdx][1]];
            cv::Point3d triPt3 = vertexList[polygonList[closestTriIdx][2]];
            Utility::computeFaceNormal(triPt1, triPt2, triPt3, normal);
        }
        else if(closestPtType > 0) // closest pt is at a vertex
        {
            uint vId = polygonList[closestTriIdx][0];
            if(closestPtType == 2)
            {
                vId = polygonList[closestTriIdx][1];
            }
            else if(closestPtType == 3)
            {
                vId = polygonList[closestTriIdx][2];
            }
            cv::Point3d pt = vertexList[vId];

            // get angle weighted vertex normal
            double totalAngle = 0;
            for(uint i = 0; i < vertexNeighbourList[vId].size(); ++i)
            {
                uint triIdx = vertexNeighbourList[vId][i];
                // get angle weights
                uint prevIdx = 0;
                uint nextIdx = 0;
                for(uint j = 0; j < 3; ++j)
                {
                    if(polygonList[triIdx][j] == vId)
                    {
                        nextIdx = polygonList[triIdx][(j + 1) % 3];
                        prevIdx = polygonList[triIdx][(j + 2) % 3];
                        break;
                    }
                }
                cv::Point3d nextPt = vertexList[nextIdx];
                cv::Point3d prevPt = vertexList[prevIdx];
                double angle = Utility::getAngle(pt, nextPt, prevPt);

                // get face normals
                cv::Point3d triNormal(0, 0, 0);
                Utility::computeFaceNormal(pt, nextPt, prevPt, triNormal);
                normal += triNormal * angle;
                totalAngle += angle;
            }
            normal *= 1.0 / totalAngle;
        }
        else // closest pt is on an edge
        {
            // get face normal of closest triangle
            cv::Point3d triPt1 = vertexList[polygonList[closestTriIdx][0]];
            cv::Point3d triPt2 = vertexList[polygonList[closestTriIdx][1]];
            cv::Point3d triPt3 = vertexList[polygonList[closestTriIdx][2]];
            Utility::computeFaceNormal(triPt1, triPt2, triPt3, normal);

            // now get the face normal of the other triangle
            int vId = polygonList[closestTriIdx][0];
            int nextVID = polygonList[closestTriIdx][1];
            if(closestPtType == -2) {
                vId = polygonList[closestTriIdx][1];
                nextVID = polygonList[closestTriIdx][2];
            }
            else if(closestPtType == -3) {
                vId = polygonList[closestTriIdx][2];
                nextVID = polygonList[closestTriIdx][0];
            }

            // find adjacent triangle
            bool foundNbr = false;
            int nbrTriIdx;
            for(uint i = 0; i < vertexNeighbourList[vId].size(); ++i)
            {
                uint triIdx = vertexNeighbourList[vId][i];
                if(triIdx == closestTriIdx)
                    continue;

                for(uint j = 0; j < 3; ++j) {
                    if(polygonList[triIdx][j] == vId) {
                        if(polygonList[triIdx][(j+2)%3] == nextVID) {
                            foundNbr = true;
                            nbrTriIdx = triIdx;
                        }
                        break;
                    }
                }

                if(foundNbr)
                    break;
            }

            if(foundNbr)
            {
                cv::Point3d triPt1 = vertexList[polygonList[nbrTriIdx][0]];
                cv::Point3d triPt2 = vertexList[polygonList[nbrTriIdx][1]];
                cv::Point3d triPt3 = vertexList[polygonList[nbrTriIdx][2]];
                cv::Point3d triNormal(0, 0, 0);
                Utility::computeFaceNormal(triPt1, triPt2, triPt3, triNormal);
                normal = (normal + triNormal) * 0.5;
            }
        }

        // closestPt-to-pt vector
        double v[3] = {pt[0]-closestPt[0], pt[1]-closestPt[1], pt[2]-closestPt[2]};
        Utility::normalize(v);
    
        if(dotProduct(normal, v) < 0)
            closestDist = -1 * closestDist;

        return closestDist;
    }


    // triangulate the cube(x,y,z) based on the intersecting triangles and the sorted groups
    //
    // x (in): x-coord of cube
    // y (in): y-coord of cube
    // z (in): z-coord of cube
    // vertexList (in): source mesh's vertices list
    // polygonList (in): source mesh's polygons list
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    template <class T>
    void TilingNonobtuseMC<T>::triangulate(
        uint x,
        uint y,
        uint z,
        const std::vector<cv::Point3d>& vertexList,
        const std::vector<std::vector<uint>>& polygonList,
        const std::vector<int>* polygonNeighbourList)
    {
        uint cubeIdx = (this->iCellsX)*(this->iCellsY)*z + (this->iCellsX)*y + x;
        sortIntersectingTriangle(cubeIdx, polygonNeighbourList);    // make sure we sort the trianlges into patches if not already sorted

         std::vector<vector<int> > &triGroups = this->iCubesProperty[cubeIdx].triGroups;

        // triangulate patch-wise
        uint numGroups = triGroups.size();
        if(numGroups > 1)
            ++this->iNumCubeMultiPatch;

        for(uint i = 0; i < numGroups; ++i)
        {
            // find all edge intersections
            std::vector<Intersection> edgeInt[12];
            findEdgeIntersection(x, y, z, i, vertexList, numVertices, polygonList, numPolygons, polygonNeighbourList, edgeInt);
        
            // assign signs to corners
            if(!assignSigns(edgeInt, x, y, z, i))
            {
                this->iCubesProperty[cubeIdx].isConsistent[i] = false;
                this->iCubesProperty[cubeIdx].isEmptyTriangulation[i] = true;
                ++this->iNumPatchIgnored;
                continue;
            }

            this->iCubesProperty[cubeIdx].isConsistent[i] = true;
        
            // triangulate patch
            //if((x == 8 && y == 47 && z == 32) || (x == 9 && y == 47 && z == 32))
            triangulatePatch(x, y, z, i, edgeInt, vertexList, numVertices, polygonList, numPolygons, polygonNeighbourList);
        }
    }

    // triangulate patch on cube(x,y,z) based on the signs given in 'signs'
    //
    // x (in): x-coord of cube
    // y (in): y-coord of cube
    // z (in): z-coord of cube
    // signs (in): array of signs for all 8 corners of the cube; 1=inside, -1=outside
    // patchNo (in): patch number we are triangulating
    // edgeInt (in): stores the edge intersection for all 12 edges of cube(x,y,z); sorted from smallest to largest depending on which edge
    // vertexList (in): source mesh's vertices list
    // polygonList (in): source mesh's polygons list
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    template <class T>
    void TilingNonobtuseMC<T>::triangulatePatch(
        uint x,
        uint y,
        uint z,
        uint patchNo,
        const std::vector<Intersection> (&edgeInt)[12],
        const std::vector<cv::Point3d>& vertexList,
        const std::vector<std::vector<uint>>& polygonList,
        const std::vector<uint>* polygonNeighbourList)
    {
        uint cubeIdx = (this->iCellsX)*(this->iCellsY)*z + (this->iCellsX)*y + x;
        std::vector<int> &signs = this->iCubesProperty[cubeIdx].signs[patchNo];

        int edgeOnFaceLookup[12][12] = {
                                        {-1, 2, 2, 2, 1, -1, -1, -1, 1, 1, -1, -1},
                                        {2, -1, 2, 2, -1, 4, -1, -1, -1, 4, 4, -1},
                                        {2, 2, -1, 2, -1, -1, 3, -1, -1, -1, 3, 3},
                                        {2, 2, 2, -1, -1, -1, -1, 5, 5, -1, -1, 5},
                                        {1, -1, -1, -1, -1, 0, 0, 0, 1, 1, -1, -1},
                                        {-1, 4, -1, -1, 0, -1, 0, 0, -1, 4, 4, -1},
                                        {-1, -1, 3, -1, 0, 0, -1, 0, -1, -1, 3, 3},
                                        {-1, -1, -1, 5, 0, 0, 0, -1, 5, -1, -1, 5},
                                        {1, -1, -1, 5, 1, -1, -1, 5, -1, 1, -1, 5},
                                        {1, 4, -1, -1, 1, 4, -1, -1, 1, -1, 4, -1},
                                        {-1, 4, 3, -1, -1, 4, 3, -1, -1, 4, -1, 3},
                                        {-1, -1, 3, 5, -1, -1, 3, 5, 5, -1, 3, -1},
                                        };

        // use to transform v1Edge and v2Edge into edge index in 2D
        //
        //  _ 1 _
        // |     |
        // 0     2
        // |_   _|
        //    3
        int transformEdgeIdx[6][12] = {{-1,-1,-1,-1,0,1,2,3,-1,-1,-1,-1},
                                        {0,-1,-1,-1,2,-1,-1,-1,3,1,-1,-1},
                                        {2,1,0,3,-1,-1,-1,-1,-1,-1,-1,-1},
                                        {-1,-1,2,-1,-1,-1,0,-1,-1,-1,1,3},
                                        {-1,1,-1,-1,-1,3,-1,-1,-1,0,2,-1},
                                        {-1,-1,-1,3,-1,-1,-1,1,0,-1,-1,2}};

        // Calculate table lookup index from those
        // vertices which are below the isolevel.
        uint tableIndex = 0;
        //    1----2
        //   /|  / |
        // 5----6  |
        // | /0-|--3
        // |/   |/
        // 4----7
        for(uint i = 0; i < 8; ++i)
        {
            if(signs[i] > this->iIsoLevel)
                //tableIndex |= (uint)pow(2,i);
                tableIndex |= (uint)pow((double)2,(double)i);        // strange hack to get it compile at home
        }    
        
        // Now create a triangulation of the isosurface in this
        // cell.
        if(this->iEdgeTable[tableIndex] == 0)
            this->iCubesProperty[cubeIdx].isEmptyTriangulation[patchNo] = true;
        else
        {
            this->iCubesProperty[cubeIdx].isEmptyTriangulation[patchNo] = false;
            // stores the vertex ID introduced on an edge of the cube that were used during the triangulation
            int existingVertices[12] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};

            if  (this->iTriTable[tableIndex][0] == -3)
            {
                // -3:    Special Case -3
                // {-3, a, b, c, d, e, f, -1, ... }
                // where a,b,c,d forms a quad, and d,e,f,a forms the other quad
                // The right hand ordering determines the normals
                // A new point m should be added to the midpoint of a,d
                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                // ---- Add midpoint m first ----
                Point3dId pta = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][1]);
                Point3dId ptd = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][4]);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, pta.x, pta.y, pta.z, ptd.x, ptd.y, ptd.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 18);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));

                // create triangles
                for(uint i = 1; i <= 6; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 2; ++j)
                    {
                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%6 + 1];
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);

                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }
            
                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointId[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint
                    triangle.pointId[2] = mID;
                
                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointId[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointId[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointId[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointId[j];
                        e.vertex2Idx = triangle.pointId[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointId[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%6 + 1]];
                    VPAIR vertexpair;
                    vertexpair.first = triangle.pointID[0];
                    vertexpair.second = triangle.pointID[1];

                    EdgePosInfo eInfo;
                    eInfo.v1Edge = this->iTriTable[tableIndex][i];
                    eInfo.v2Edge = this->iTriTable[tableIndex][i%6 + 1];
                    eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                    eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                    eInfo.isV1First = true;

                    if(vertexpair.first > vertexpair.second) {
                        std::swap(vertexpair.first, vertexpair.second);
                        std::swap(eInfo.v1Edge, eInfo.v2Edge);
                        eInfo.isV1First = false;
                    }
                    if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                    {
                        eInfo.edgeIdx = this->iVPair2E[vertexpair];
                        uint faceID = GetFaceID(x,y,z,faceIdx);
                        this->iEonF[faceID].push_back(eInfo);
                        this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                    }
                }
            }
            else if(this->iTriTable[tableIndex][0] == -5)
            {
                // -5:  Special Case 5b
                // {-5, a, b, c, d, e, -1, ... }
                // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
                // The right hand ordering determins the normals
                // A new point m should be added to the midpoint of b,e
                // Then, the 5 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, -1}

                // ---- Add midpoint m first ----
                Point3dId ptb = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][2]);
                Point3dId pte = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][5]);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, ptb.x, ptb.y, ptb.z, pte.x, pte.y, pte.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 12);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));

                // create triangles
                for(uint i = 1; i <= 5; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 2; ++j)
                    {
                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%5 + 1];
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }

                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint
                    triangle.pointID[2] = mID;

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%5 + 1]];
                    VPAIR vertexpair;
                    vertexpair.first = triangle.pointID[0];
                    vertexpair.second = triangle.pointID[1];

                    EdgePosInfo eInfo;
                    eInfo.v1Edge = this->iTriTable[tableIndex][i];
                    eInfo.v2Edge = this->iTriTable[tableIndex][i%5 + 1];
                    eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                    eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                    eInfo.isV1First = true;

                    if(vertexpair.first > vertexpair.second) {
                        std::swap(vertexpair.first, vertexpair.second);
                        std::swap(eInfo.v1Edge, eInfo.v2Edge);
                        eInfo.isV1First = false;
                    }
                    if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                    {
                        eInfo.edgeIdx = this->iVPair2E[vertexpair];
                        uint faceID = GetFaceID(x,y,z,faceIdx);
                        this->iEonF[faceID].push_back(eInfo);
                        this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                    }
                }
            }
            else if  (this->iTriTable[tableIndex][0] == -6)
            {
                // -6:    Special Case -6
                // {-3, a, b, c, d, e, f, g, -1, ... }
                // where a,b,c,d,e,f,g forms a seven-agon
                // The right hand ordering determines the normals
                // A new point m should be added to the center of cube
                // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, g, m, g, a, m, -1}

                // ---- Add midpoint m first ----
                Point3dId pta = this->computeVertexLocation(x, y, z, 0);
                Point3dId ptd = this->computeVertexLocation(x, y, z, 6);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, pta.x, pta.y, pta.z, ptd.x, ptd.y, ptd.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 19);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));
            
                // create triangles
                for(uint i = 1; i <= 7; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 2; ++j)
                    {
                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%7 + 1];
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }

                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint
                    triangle.pointID[2] = mID;

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%7 + 1]];
                    VPAIR vertexpair;
                    vertexpair.first = triangle.pointID[0];
                    vertexpair.second = triangle.pointID[1];

                    EdgePosInfo eInfo;
                    eInfo.v1Edge = this->iTriTable[tableIndex][i];
                    eInfo.v2Edge = this->iTriTable[tableIndex][i%7 + 1];
                    eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                    eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                    eInfo.isV1First = true;    

                    if(vertexpair.first > vertexpair.second) {
                        std::swap(vertexpair.first, vertexpair.second);
                        std::swap(eInfo.v1Edge, eInfo.v2Edge);
                        eInfo.isV1First = false;
                    }
                    if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                    {
                        eInfo.edgeIdx = this->iVPair2E[vertexpair];
                        uint faceID = GetFaceID(x,y,z,faceIdx);
                        this->iEonF[faceID].push_back(eInfo);
                        this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                    }
                }
            }
            else if(this->iTriTable[tableIndex][0] == -7)
            {
                // -7:  Special Case -7
                // {-7, a, b, c, d, e, f, i, j, k, -1, ... }
                // where a,b,c,d,e,f forms a hexagon and i,j,k forms a triangle
                // The right hand ordering determines the normals
                // A new point m should be added to the centroid of a,b,c,d,e,f
                // Then, the 7 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, i, j, k, -1}
            
                // ---- Add midpoint m first ----
                Point3dId ptb = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][2]);
                Point3dId pte = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][5]);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, ptb.x, ptb.y, ptb.z, pte.x, pte.y, pte.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 17);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));

                // create triangles
                for(uint i = 1; i <= 7; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 3; ++j)
                    {
                        if(i != 7 && j == 2)    // only the 7th triangle use 3rd vertex that lies on edge, other use midpoint m as the 3rd pt
                            break;

                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(i == 7)
                            edgeNo = this->iTriTable[tableIndex][i+j];
                        else if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%6 + 1];
                    
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }

                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint, except for the 7th triangle
                    if(i != 7)
                        triangle.pointID[2] = mID;

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    if(i != 7)
                    {
                        int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%6 + 1]];
                        VPAIR vertexpair;
                        vertexpair.first = triangle.pointID[0];
                        vertexpair.second = triangle.pointID[1];

                        EdgePosInfo eInfo;
                        eInfo.v1Edge = this->iTriTable[tableIndex][i];
                        eInfo.v2Edge = this->iTriTable[tableIndex][i%6 + 1];
                        eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                        eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                        eInfo.isV1First = true;

                        if(vertexpair.first > vertexpair.second) {
                            std::swap(vertexpair.first, vertexpair.second);
                            std::swap(eInfo.v1Edge, eInfo.v2Edge);
                            eInfo.isV1First = false;
                        }
                        if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                        {
                            eInfo.edgeIdx = this->iVPair2E[vertexpair];
                            uint faceID = GetFaceID(x,y,z,faceIdx);
                            this->iEonF[faceID].push_back(eInfo);
                            this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                        }
                    }
                    else
                    {    
                        for(uint k = 0; k < 3; ++k)
                        {
                            int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i+k]][this->iTriTable[tableIndex][i+((k+1)%3)]];
                            VPAIR vertexpair;
                            vertexpair.first = triangle.pointID[k];
                            vertexpair.second = triangle.pointID[(k+1)%3];

                            EdgePosInfo eInfo;
                            eInfo.v1Edge = this->iTriTable[tableIndex][i+k];
                            eInfo.v2Edge = this->iTriTable[tableIndex][i+((k+1)%3)];
                            eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                            eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                            eInfo.isV1First = true;

                            if(vertexpair.first > vertexpair.second) {
                                std::swap(vertexpair.first, vertexpair.second);
                                std::swap(eInfo.v1Edge, eInfo.v2Edge);
                                eInfo.isV1First = false;
                            }
                            if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                            {
                                eInfo.edgeIdx = this->iVPair2E[vertexpair];
                                uint faceID = GetFaceID(x,y,z,faceIdx);
                                this->iEonF[faceID].push_back(eInfo);
                                this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                            }
                        }
                    }
                }
            }
            else if(this->iTriTable[tableIndex][0] == -9)
            {
                // -9:  Special Case 9b
                // {-9, a, b, c, d, e, f, -1, ... }
                // where a,b,c,d,e,f forms a hexagon.
                // The right hand ordering determines the normals
                // A new point m should be added to the centroid of a,b,c,d,e,f
                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                // ---- Add midpoint m first ----
                Point3dId ptb = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][2]);
                Point3dId pte = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][5]);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, ptb.x, ptb.y, ptb.z, pte.x, pte.y, pte.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 13);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));

                // create triangles
                for(uint i = 1; i <= 6; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 2; ++j)
                    {
                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%6 + 1];
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }
            
                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint
                    triangle.pointID[2] = mID;

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%6 + 1]];
                    VPAIR vertexpair;
                    vertexpair.first = triangle.pointID[0];
                    vertexpair.second = triangle.pointID[1];

                    EdgePosInfo eInfo;
                    eInfo.v1Edge = this->iTriTable[tableIndex][i];
                    eInfo.v2Edge = this->iTriTable[tableIndex][i%6 + 1];
                    eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                    eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                    eInfo.isV1First = true;

                    if(vertexpair.first > vertexpair.second) {
                        std::swap(vertexpair.first, vertexpair.second);
                        std::swap(eInfo.v1Edge, eInfo.v2Edge);
                        eInfo.isV1First = false;
                    }
                    if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                    {
                        eInfo.edgeIdx = this->iVPair2E[vertexpair];
                        uint faceID = GetFaceID(x,y,z,faceIdx);
                        this->iEonF[faceID].push_back(eInfo);
                        this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                    }
                }
            }
            else if(this->iTriTable[tableIndex][0] == -11)    
            {
                // -11: Special Case 11c
                // {-11, a, b, c, d, e, f, -1, ... ]
                // where a,b,c,d,e,f forms a bent hexagon.
                //       new point m is added in the center of the cube
                //       b,c,m and e,f,m are right isoscele triangles
                //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
                // The right hand ordering determines the normals
                // A new point m should be added to the center of cube (ie. midpoint of a and d)
                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                // ---- Add midpoint m first ----
                Point3dId pta = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][1]);
                Point3dId ptd = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][4]);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, pta.x, pta.y, pta.z, ptd.x, ptd.y, ptd.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 14);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));

                // create triangles
                for(uint i = 1; i <= 6; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 2; ++j)
                    {
                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%6 + 1];
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }
            
                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint
                    triangle.pointID[2] = mID;

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%6 + 1]];
                    VPAIR vertexpair;
                    vertexpair.first = triangle.pointID[0];
                    vertexpair.second = triangle.pointID[1];

                    EdgePosInfo eInfo;
                    eInfo.v1Edge = this->iTriTable[tableIndex][i];
                    eInfo.v2Edge = this->iTriTable[tableIndex][i%6 + 1];
                    eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                    eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                    eInfo.isV1First = true;

                    if(vertexpair.first > vertexpair.second) {
                        std::swap(vertexpair.first, vertexpair.second);
                        std::swap(eInfo.v1Edge, eInfo.v2Edge);
                        eInfo.isV1First = false;
                    }
                    if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                    {
                        eInfo.edgeIdx = this->iVPair2E[vertexpair];
                        uint faceID = GetFaceID(x,y,z,faceIdx);
                        this->iEonF[faceID].push_back(eInfo);
                        this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                    }
                }
            }
            else if(this->iTriTable[tableIndex][0] == -12)
            {
                // -12: Special Case 12b
                // {-12, a, b, c, d, e, i, j, k, -1, ... }
                // where a, b, e forms a triangle and b, c, d, e forms a trapezoid (both connected)
                //       and i, j, k forms a seperate triangle
                // The right hand ordering determines the normals
                // A new point m should be added to the midpoint of b,e
                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, a, m, i, j, k, -1}

                // ---- Add midpoint m first ----
                Point3dId ptb = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][2]);
                Point3dId pte = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][5]);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, ptb.x, ptb.y, ptb.z, pte.x, pte.y, pte.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 15);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));

                // create triangles
                for(uint i = 1; i <= 6; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 3; ++j)
                    {
                        if(i != 6 && j == 2)    // only the 6th triangle use 3rd vertex that lies on edge, other use midpoint m as the 3rd pt
                            break;

                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(i == 6)
                            edgeNo = this->iTriTable[tableIndex][i+j];
                        else if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%5 + 1];
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }

                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint, except for the 6th triangle
                    if(i != 6)
                        triangle.pointID[2] = mID;

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    if(i != 6)
                    {
                        // add edge-on-face reference
                        int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%5 + 1]];
                        VPAIR vertexpair;
                        vertexpair.first = triangle.pointID[0];
                        vertexpair.second = triangle.pointID[1];

                        EdgePosInfo eInfo;
                        eInfo.v1Edge = this->iTriTable[tableIndex][i];
                        eInfo.v2Edge = this->iTriTable[tableIndex][i%5 + 1];
                        eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                        eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                        eInfo.isV1First = true;

                        if(vertexpair.first > vertexpair.second) {
                            std::swap(vertexpair.first, vertexpair.second);
                            std::swap(eInfo.v1Edge, eInfo.v2Edge);
                            eInfo.isV1First = false;
                        }
                        if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                        {
                            eInfo.edgeIdx = this->iVPair2E[vertexpair];
                            uint faceID = GetFaceID(x,y,z,faceIdx);
                            this->iEonF[faceID].push_back(eInfo);
                            this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                        }
                    }
                    else
                    {
                        for(uint k = 0; k < 3; ++k)
                        {    
                            // add edge-on-face reference
                            int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i+k]][this->iTriTable[tableIndex][i+((k+1)%3)]];
                            VPAIR vertexpair;
                            vertexpair.first = triangle.pointID[k];
                            vertexpair.second = triangle.pointID[(k+1)%3];

                            EdgePosInfo eInfo;
                            eInfo.v1Edge = this->iTriTable[tableIndex][i+k];
                            eInfo.v2Edge = this->iTriTable[tableIndex][i+((k+1)%3)];
                            eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                            eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                            eInfo.isV1First = true;

                            if(vertexpair.first > vertexpair.second) {
                                std::swap(vertexpair.first, vertexpair.second);
                                std::swap(eInfo.v1Edge, eInfo.v2Edge);
                                eInfo.isV1First = false;
                            }
                            if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                            {
                                eInfo.edgeIdx = this->iVPair2E[vertexpair];
                                uint faceID = GetFaceID(x,y,z,faceIdx);
                                this->iEonF[faceID].push_back(eInfo);
                                this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                            }
                        }
                    }
                }
            }
            else if(this->iTriTable[tableIndex][0] == -14)
            {
                // -14: Special Case 14c
                // {-14, a, b, c, d, e, f, -1, ... ]
                // where a,b,c,d,e,f forms a bent hexagon.
                //       new point m is added in the center of the cube
                //       b,c,m and e,f,m are right isoscele triangles
                //       a,b,m and c,d,m and d,e,m and f,a,m are equilateral triangles
                // The right hand ordering determines the normals
                // A new point m should be added to the center of cube (ie. midpoint of a and d)
                // Then, the 6 new triangles are {a, b, m, b, c, m, c, d, m, d, e, m, e, f, m, f, a, m, -1}

                // ---- Add midpoint m first ----
                Point3dId pta = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][1]);
                Point3dId ptd = this->computeVertexLocation(x, y, z, this->iTriTable[tableIndex][4]);
            
                // computing midpoint m
                double m[3] = {0,0,0};
                midpoint(m, pta.x, pta.y, pta.z, ptd.x, ptd.y, ptd.z);
                Point3dId ptm;
                ptm.iId = 0;
                ptm.x = m[0];
                ptm.y = m[1];
                ptm.z = m[2];

                // add m into list
                uint mID = this->iNextUnusedVertexId;
                ++this->iNextUnusedVertexId;
                this->iId2Point3dId.insert(Id2Point3dId::value_type(mID, ptm));

                // add new vertex to corresponding edge for reference
                uint edgeID = this->getEdgeId(x, y, z, 16);
                this->iVonE[edgeID].push_back(mID);
                this->iV2EOfCube.insert(VTOEOFCUBE::value_type(mID, edgeID));

                // create triangles
                for(uint i = 1; i <= 6; ++i) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 2; ++j)
                    {
                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i];
                        if(j == 1)
                            edgeNo = this->iTriTable[tableIndex][i%6 + 1];
                        // index of edge we are to put a vertex
                        edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }
            
                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    // 3rd point of the triangle is midpoint
                    triangle.pointID[2] = mID;

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i]][this->iTriTable[tableIndex][i%6 + 1]];
                    VPAIR vertexpair;
                    vertexpair.first = triangle.pointID[0];
                    vertexpair.second = triangle.pointID[1];

                    EdgePosInfo eInfo;
                    eInfo.v1Edge = this->iTriTable[tableIndex][i];
                    eInfo.v2Edge = this->iTriTable[tableIndex][i%6 + 1];
                    eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                    eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                    eInfo.isV1First = true;

                    if(vertexpair.first > vertexpair.second) {
                        std::swap(vertexpair.first, vertexpair.second);
                        std::swap(eInfo.v1Edge, eInfo.v2Edge);
                        eInfo.isV1First = false;
                    }
                    if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                    {
                        eInfo.edgeIdx = this->iVPair2E[vertexpair];
                        uint faceID = GetFaceID(x,y,z,faceIdx);
                        this->iEonF[faceID].push_back(eInfo);
                        this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                    }
                }
            }
            else
            {
                for(uint i = 0; this->iTriTable[tableIndex][i] != -1; i += 3) 
                {
                    TRIANGLE triangle;
                    for(uint j = 0; j < 3; ++j) 
                    {
                        // edge number we are putting a vertex
                        uint edgeNo = this->iTriTable[tableIndex][i+j];
                        // index of edge we are to put a vertex
                        uint edgeID = this->getEdgeId(x, y, z, edgeNo);
            
                        // sanity check
                        if(edgeNo >= 12) {
                            std::cout << "TilingNonobtuseMC<T>::triangulatePatch() - edgeNo is not with [0,11]" << std::endl;
                            return;
                        }
            
                        uint vertexId;
                        if(existingVertices[edgeNo] > -1)
                        {
                            vertexId = existingVertices[edgeNo];
                        }
                        // if no existing vertex can be used, add a new one
                        else
                        {
                            vertexId = this->iNextUnusedVertexId;
                            ++this->iNextUnusedVertexId;

                            // insert new vertex into list
                            Point3dId pt = this->computeVertexLocation(x, y, z, edgeNo);
                            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));

                            existingVertices[edgeNo] = vertexId;

                            // add new vertex to corresponding edge for reference
                            this->iVonE[edgeID].push_back(vertexId);
                            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
                        }

                        // add vertex reference to the triangle
                        triangle.pointID[j] = vertexId;
                    }

                    for(uint j = 0; j < 3; ++j)
                    {
                        // add triangle reference to vertices
                        if(this->iV2Tri.find(triangle.pointID[j]) == this->iV2Tri.end())
                        {
                            std::vector<uint> adjTriList(1, this->iTriangleVec.size());
                            this->iV2Tri.insert(VTOTRI::value_type(triangle.pointID[j], adjTriList));
                        }
                        else
                            this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                        Edge e;
                        e.vertex1Idx = triangle.pointID[j];
                        e.vertex2Idx = triangle.pointID[(j+1)%3];
                        if(e.vertex1Idx > e.vertex2Idx)
                            std::swap(e.vertex1Idx, e.vertex2Idx);
                    
                        // check if a new edge needs to be created
                        uint currentEdgeID;
                        bool needNewEdge(true);
                    
                        VTOE::iterator iter = this->iV2E.find(triangle.pointID[j]);
                        if(iter != this->iV2E.end())
                        {
                            std::vector<uint> &adjEdges = this->iV2E[triangle.pointID[j]];
                            for(uint i = 0; i < adjEdges.size(); ++i) {
                                if(e.vertex1Idx == this->iEdgeList[adjEdges[i]].vertex1Idx && e.vertex2Idx == this->iEdgeList[adjEdges[i]].vertex2Idx) {
                                    currentEdgeID = adjEdges[i];
                                    needNewEdge = false;
                                    break;
                                }
                            }
                        }
        
                        // add edge to the edge list
                        if(needNewEdge) {
                            currentEdgeID = this->iNextUnusedEdgeId;
                            ++this->iNextUnusedEdgeId;
                            this->iEdgeList.insert(ID2EDGE::value_type(currentEdgeID, e));
                        
                            VPAIR vertexpair;
                            vertexpair.first = e.vertex1Idx;
                            vertexpair.second = e.vertex2Idx;
                            this->iVPair2E.insert(VPAIRTOE::value_type(vertexpair, currentEdgeID));
                    
                            // add e-to-tri references
                            std::vector<uint> triIndices;
                            triIndices.push_back(this->iTriangleVec.size());
                            this->iV2Tri.insert(ETOTRI::value_type(currentEdgeID, triIndices));
                        }
                        else    // add e-to-tri references
                            this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());

                        // add v-to-e references
                        if(iter == this->iV2E.end())
                        {
                            std::vector<uint> adjEdgeList;
                            adjEdgeList.push_back(currentEdgeID);
                            this->iV2E.insert(VTOE::value_type(triangle.pointID[j], adjEdgeList));

                            if(this->iV2E.find(triangle.pointID[(j+1)%3]) == this->iV2E.end())
                                this->iV2E.insert(VTOE::value_type(triangle.pointID[(j+1)%3], adjEdgeList));
                            else
                                this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                        else if(needNewEdge)
                        {
                            this->iV2E[triangle.pointID[j]].push_back(currentEdgeID);
                            this->iV2E[triangle.pointID[(j+1)%3]].push_back(currentEdgeID);
                        }
                    }

                    // add triangle to triangle list
                    this->iTriangleVec.push_back(triangle);

                    // add tri-to-cube reference
                    std::vector<CubeID> cIDList(1, CubeID(x,y,z));
                    std::vector<uint> pNoList(1, patchNo);
                    this->iTri2CubeId.push_back(cIDList);
                    this->iTri2Patch.push_back(pNoList);

                    // add edge-on-face reference
                    for(uint k = 0; k < 3; ++k)
                    {
                        int faceIdx = edgeOnFaceLookup[this->iTriTable[tableIndex][i+k]][this->iTriTable[tableIndex][i+((k+1)%3)]];
                        VPAIR vertexpair;
                        vertexpair.first = triangle.pointID[k];
                        vertexpair.second = triangle.pointID[(k+1)%3];

                        EdgePosInfo eInfo;
                        eInfo.v1Edge = this->iTriTable[tableIndex][i+k];
                        eInfo.v2Edge = this->iTriTable[tableIndex][i+((k+1)%3)];
                        eInfo.v1Edge = transformEdgeIdx[faceIdx][eInfo.v1Edge];
                        eInfo.v2Edge = transformEdgeIdx[faceIdx][eInfo.v2Edge];
                        eInfo.isV1First = true;

                        if(vertexpair.first > vertexpair.second) {
                            std::swap(vertexpair.first, vertexpair.second);
                            std::swap(eInfo.v1Edge, eInfo.v2Edge);
                            eInfo.isV1First = false;
                        }
                        if(this->iVPair2E.find(vertexpair) != this->iVPair2E.end())
                        {
                            eInfo.edgeIdx = this->iVPair2E[vertexpair];
                            int faceID = GetFaceID(x,y,z,faceIdx);
                            if(faceID != -1)
                            {
                                this->iEonF[faceID].push_back(eInfo);
                                this->iE2F.insert(ETOFACE::value_type(eInfo.edgeIdx, faceID));
                            }
                        }
                    }
                }
            }
        }
    }

    // based on edge intersections, determine all signs for the cube
    // array of signs for all 8 corners of the cube; 1=outside, -1=inside
    //
    // edgeInt (in): array of 12 slots; stores the edge intersection for all 12 edges of cube(x,y,z); sorted from smallest to largest depending on which edge
    // x (in): x-coord of cube
    // y (in): y-coord of cube
    // z (in): z-coord of cube
    // patchNo (in): patch number we are triangulating
    // return value (out): true if all signs can be assigned without conflict
    template <class T> bool TilingNonobtuseMC<T>::assignSigns(const std::vector<Intersection> (&edgeInt)[12], uint x, uint y, uint z, uint patchNo)
    {
        uint cubeIdx = (this->iCellsX)*(this->iCellsY)*z + (this->iCellsX)*y + x;
        std::vector<int> &signs = this->iCubesProperty[cubeIdx].signs[patchNo];
    
        // if no edge intersection, return an empty cube
        if(edgeInt[0].empty() && edgeInt[1].empty() && edgeInt[2].empty() && edgeInt[3].empty() && edgeInt[4].empty() && edgeInt[5].empty() && edgeInt[6].empty() && edgeInt[7].empty() && edgeInt[8].empty() && edgeInt[9].empty() && edgeInt[10].empty() && edgeInt[11].empty()) {
            for(uint i = 0; i < 8; ++i)
                signs[i] = 1;
            return true;
        }

        uint nbrEdgeIdx[8][3] = {{3,0,8},{1,0,9},{1,2,10},{3,2,11},{7,4,8},{5,4,9},{5,6,10},{7,6,11}};
        uint closestIntIdx[8][3] = {{0,0,0},
                                            {0,edgeInt[0].size()-1,0},
                                            {edgeInt[1].size()-1,edgeInt[2].size()-1,0},
                                            {edgeInt[3].size()-1,0,0},
                                            {0,0,edgeInt[8].size()-1},
                                            {0,edgeInt[4].size()-1,edgeInt[9].size()-1},
                                            {edgeInt[5].size()-1,edgeInt[6].size()-1,edgeInt[10].size()-1},
                                            {edgeInt[7].size()-1,0,edgeInt[11].size()-1}};
        bool flipFacingPos[8][3] = {{false,false,false},
                                    {false,true,false},
                                    {true,true,false},
                                    {true,false,false},
                                    {false,false,true},
                                    {false,true,true},
                                    {true,true,true},
                                    {true,false,true}};
        uint nbrIdx[8][3] = {{3,1,4},{2,0,5},{1,3,6},{0,2,7},{7,5,0},{6,4,1},{5,7,2},{4,6,3}};
        //    1----2
        //   /|  / |
        // 5----6  |
        // | /0-|--3
        // |/   |/
        // 4----7
        // assign signs to all 8 corners of the cube
        std::vector<uint> unassignedCorners;
        for(uint i = 0; i < 8; ++i)
        {
            // assign signs and make sure it doesn't conflict among the 3 neighbour edges
            signs[i] = 0;
            for(int j = 0; j < 3; ++j) {
                if(signs[i] == 0) {
                    if(!edgeInt[nbrEdgeIdx[i][j]].empty()) {
                        if(flipFacingPos[i][j] != edgeInt[nbrEdgeIdx[i][j]][closestIntIdx[i][j]].isFacingPos)
                            signs[i] = -1;
                        else
                            signs[i] = 1;

                        j = -1;    // make sure we check for consistency on all edges
                        continue;
                    }
                }
                else if(!edgeInt[nbrEdgeIdx[i][j]].empty()) {
                    if((signs[i] == -1 && flipFacingPos[i][j] == edgeInt[nbrEdgeIdx[i][j]][closestIntIdx[i][j]].isFacingPos) ||
                        (signs[i] == 1 && flipFacingPos[i][j] != edgeInt[nbrEdgeIdx[i][j]][closestIntIdx[i][j]].isFacingPos))
                    {
                        //cout << "Cannot assign signs for cube(" << x << ", " << y << ", " << z << ") patch " << patchNo << std::endl;
                        signs[0] = 0;
                        return false;
                    }
                }
                else if(signs[nbrIdx[i][j]] != 0 && signs[i] != signs[nbrIdx[i][j]]) {
                    //cout << "Cannot assign signs for cube(" << x << ", " << y << ", " << z << ") patch " << patchNo << std::endl;
                    signs[0] = 0;
                    return false;
                }
            }

            if(signs[i] == 0)
                unassignedCorners.push_back(i);
        }

        // for all unmarked corner, we assign it by examining the closest neighbour
        std::vector<uint>::iterator iter = unassignedCorners.begin();
        while(!unassignedCorners.empty())
        {
            uint cornerIdx = *iter;
            // assign signs based on neighbour and check for consistency
            for(int j = 0; j < 3; ++j) {
                if(signs[cornerIdx] == 0) {
                    if(signs[nbrIdx[cornerIdx][j]] != 0) {
                        signs[cornerIdx] = signs[nbrIdx[cornerIdx][j]];
                        unassignedCorners.erase(iter);
                        j = -1;
                        continue;
                    }
                }
                else if(signs[nbrIdx[cornerIdx][j]] != 0 && signs[cornerIdx] != signs[nbrIdx[cornerIdx][j]])
                {
                    //cout << "Cannot assign signs for cube(" << x << ", " << y << ", " << z << ") patch " << patchNo << std::endl;
                    signs[0] = 0;
                    return false;
                }
            }

            if(signs[cornerIdx] == 0)
                iter++;
            if(iter == unassignedCorners.end())
                iter = unassignedCorners.begin();
        }

        return true;
    }

    // find edge intersection of groupIdx on cube(x,y,z)
    //
    // x (in): x-coord of cube
    // y (in): y-coord of cube
    // z (in): z-coord of cube
    // groupIdx (in): group index to check
    // vertexList (in): source mesh's vertices list
    // polygonList (in): source mesh's polygons list
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // edgeInt (out): stores the edge intersection for all 12 edges of cube(x,y,z); sorted from smallest to largest depending on which edge
    template <class T>
    void TilingNonobtuseMC<T>::findEdgeIntersection(
            uint x,
            uint y,
            uint z,
            uint groupIdx,
            const std::vector<cv::Point3d>& vertexList,
            const std::vector<std::vector<uint>>& polygonList,
            const std::vector<uint>* polygonNeighbourList,
            std::vector<Intersection> (&edgeInt)[12])
    {
        uint cubeIdx = (this->iCellsX)*(this->iCellsY)*z + (this->iCellsX)*y + x;
        std::vector<int> &group = this->iCubesProperty[cubeIdx].triGroups[groupIdx];
        std::vector<IntersectTri> &iIntTriVec = this->iCubesProperty[cubeIdx].iIntTriVec;

        // find intersection on all 12 edges of cube(x,y,z)
        for(uint i = 0; i < 12; ++i)
        {
            uint v1x = x;
            uint v1y = y;
            uint v1z = z;
            uint v2x = x;
            uint v2y = y+1;
            uint v2z = z;
            if(i == 1)    {
                v1y += 1;
                v2x += 1;
            } else if(i == 2) {
                v1x += 1;
                v2x += 1;
            } else if(i == 3) {
                v2x += 1;
                v2y -= 1;
            } else if(i == 4) {
                v1z += 1;
                v2z += 1;
            } else if(i == 5) {
                v1y += 1;
                v1z += 1;
                v2x += 1;
                v2z += 1;
            } else if(i == 6) {
                v1x += 1;
                v1z += 1;
                v2x += 1;
                v2z += 1;
            } else if(i == 7) {
                v1z += 1;
                v2x += 1;
                v2y -= 1;
                v2z += 1;
            } else if(i == 8) {
                v2y -= 1;
                v2z += 1;
            } else if(i == 9) {
                v1y += 1;
                v2z += 1;
            } else if(i == 10) {
                v1x += 1;
                v1y += 1;
                v2x += 1;
                v2z += 1;
            } else if(i == 11) {
                v1x += 1;
                v2x += 1;
                v2y -= 1;
                v2z += 1;
            }
            double linePt1[3] = {v1x*(this->iCellLengthX) + (this->iOffsets[0]), v1y*(this->iCellLengthY) + (this->iOffsets[1]), v1z*(this->iCellLengthZ) + (this->iOffsets[2])};
            double linePt2[3] = {v2x*(this->iCellLengthX) + (this->iOffsets[0]), v2y*(this->iCellLengthY) + (this->iOffsets[1]), v2z*(this->iCellLengthZ) + (this->iOffsets[2])};

            std::vector<int> ignoreTri;        // stores the triangle to ignore; used for special cases such as edge intersection

            // check all the intersected triangles
            for(vector<int>::iterator iter = group.begin(); iter != group.end(); iter++)
            {
                IntersectTri &intTri = iIntTriVec[*iter];

                // skip triangle if it should be ignored due to edge intersection of neighbouring triangle
                if(find(ignoreTri.begin(), ignoreTri.end(), intTri.iTriIdx) != ignoreTri.end())
                    continue;

                // skip triangles that are completely inside cube
                if(intTri.insideCube)
                    continue;

                // sanity checks
                if(intTri.iTriIdx >= numPolygons) {
                    std::cout << "Error: TilingNonobtuseMC<T>::findEdgeIntersection() - Array Index Overflow for polygonList" << std::endl;
                    return;
                }

                cv::Point3d triPt1 = vertexList[polygonList[intTri.iTriIdx][0]];
                cv::Point3d triPt2 = vertexList[polygonList[intTri.iTriIdx][1]];
                cv::Point3d triPt3 = vertexList[polygonList[intTri.iTriIdx][2]];

                Intersection edgeIntPt;
                edgeIntPt.iTriIdx = intTri.iTriIdx;
                int intType = line_triangle_intersection(edgeIntPt.intPt, linePt1, linePt2, triPt1, triPt2, triPt3);
                if(intType == 0 || intType >= 4)    // no intersection or intersects in a coplanar manner
                    continue;

                if(!segment_pt_intersection(edgeIntPt.intPt, linePt1, linePt2))    // no intersection
                    continue;

                if(abs(intType) == 3)        // special case where ray hits triangle's edge
                {
                    // check intersection for the neighbouring triangle
                    uint intEdge = 0;
                    if(segment_pt_intersection(edgeIntPt.intPt, triPt2, triPt3))
                        intEdge = 1;
                    else if(segment_pt_intersection(edgeIntPt.intPt, triPt3, triPt1))
                        intEdge = 2;

                    // find neighbouring triangle
                    bool nbrFound(false);
                    uint nbrTriIdx = 0;
                    for(vector<int>::const_iterator nbrIter = polygonNeighbourList[intTri.iTriIdx].begin(); nbrIter != polygonNeighbourList[intTri.iTriIdx].end(); nbrIter++)
                    {
                        if(((polygonList[*nbrIter][0] == polygonList[intTri.iTriIdx][intEdge]) ||
                            (polygonList[*nbrIter][1] == polygonList[intTri.iTriIdx][intEdge]) ||
                            (polygonList[*nbrIter][2] == polygonList[intTri.iTriIdx][intEdge]))
                            &&
                            ((polygonList[*nbrIter][0] == polygonList[intTri.iTriIdx][(intEdge+1)%3]) ||
                            (polygonList[*nbrIter][1] == polygonList[intTri.iTriIdx][(intEdge+1)%3]) ||
                            (polygonList[*nbrIter][2] == polygonList[intTri.iTriIdx][(intEdge+1)%3]))) 
                        {
                            nbrTriIdx = *nbrIter;
                            nbrFound = true;
                            break;
                        }
                    }

                    if(nbrFound)    // check the type of edge intersection if it should be counted
                    {
                        cv::Point3d line = linePt2 - linePt1;
                        cv::Point3d normal(0, 0, 0);
                        cv::Point3d nbrTriPt1 = vertexList[polygonList[nbrTriIdx][0]];
                        cv::Point3d nbrTriPt2 = vertexList[polygonList[nbrTriIdx][1]];
                        cv::Point3d nbrTriPt3 = vertexList[polygonList[nbrTriIdx][2]];
                        Utility::computeFaceNormal(nbrTriPt1, nbrTriPt2, nbrTriPt3, normal);
                        double dp = normal.dot(line);
                    
                        if((intType > 0) != (dp < 0)) // ray intersects edge but did not get in/out of the surface
                        {
                            // if nbr triangle has already been checked and added, remove it
                            for(vector<Intersection>::iterator intIter = edgeInt[i].begin(); intIter != edgeInt[i].end(); intIter++) {
                                if(intIter->triIdx == nbrTriIdx) {
                                    edgeInt[i].erase(intIter);
                                    break;
                                }
                            }

                            // make sure we don't check the nbr triangle again for this edge
                            ignoreTri.push_back(nbrTriIdx);
                        
                            // continue checking with next triangle
                            continue;
                        }
                    }

                    // no neighbour found means the current intersected triangle is at boundary, so we count the intersection as valid
                }

                edgeIntPt.isFacingPos = (intType < 0);    // ray hits triangle's backside

                // ---- insert intPt into array ----
                uint sortIdx = 0;
                if(i == 0 || i == 2 || i == 4 || i == 6)
                    sortIdx = 1;
                else if(i == 8 || i == 9 || i == 10 || i == 11)
                    sortIdx = 2;
            
                bool isIntPtAdded(false);
                for(vector<Intersection>::iterator intIter = edgeInt[i].begin(); intIter != edgeInt[i].end(); intIter++) {
                    if(intIter->intPt[sortIdx] >= edgeIntPt.intPt[sortIdx]) {
                        edgeInt[i].insert(intIter, edgeIntPt);
                        isIntPtAdded = true;
                        break;
                    } 
                }
                if(!isIntPtAdded)
                    edgeInt[i].push_back(edgeIntPt);
            }
        }
    }

    // determine which cubes are intersected by which triangle in source mesh
    //
    // vertexList (in): source mesh's vertices list
    // polygonList (in): source mesh's polygons list
    template <class T>
    void TilingNonobtuseMC<T>::markIntersectedCubes(
        const std::vector<cv::Point3d>& vertexList,
        const std::vector<std::vector<uint>>& polygonList)
    {
        // sanity checks
        if(vertexList == NULL ||
            numVertices == 0 ||
            polygonList == NULL ||
            numPolygons == 0)
            return;

        if(this->iCubesProperty != NULL)
            delete[] this->iCubesProperty;

        // initialize cubes property list
        this->iCubesProperty = new IntersectedCube[(this->iCellsX)*(this->iCellsY)*(this->iCellsZ)];

        std::cout << "Marking Intersected Cubes... " << std::endl;

        // go through all triangles and see which cubes it intersects
        for(int i = 0; i < numPolygons; ++i)
        {
            //cout << "Processing polygon " << i << std::endl;
            this->markIntersectedCubes(i, vertexList[polygonList[i][0]], vertexList[polygonList[i][1]], vertexList[polygonList[i][2]]);
        }
    }

    // determine which cubes are intersected by the given triangle
    //
    // triangleIdx (in): index of triangle
    // pt1x (in): x-coord of vertex 1 of triangle
    // pt1y (in): y-coord of vertex 1 of triangle
    // pt1z (in): z-coord of vertex 1 of triangle
    // pt2x (in): x-coord of vertex 2 of triangle
    // pt2y (in): y-coord of vertex 2 of triangle
    // pt2z (in): z-coord of vertex 2 of triangle
    // pt3x (in): x-coord of vertex 3 of triangle
    // pt3y (in): y-coord of vertex 3 of triangle
    // pt3z (in): z-coord of vertex 3 of triangle
    template <class T>
    void TilingNonobtuseMC<T>::markIntersectedCubes(int triangleIdx, const cv::Point3d& pt1, const cv::Point3d& pt2, const cv::Point3d& pt3)
    {
        // first find the coordinate to scan-slice
        double normal[3] = {0,0,0};
        Utility::computeFaceNormal(pt1, pt2, pt3, normal);
    
        uint largestProjCoord = 0;
        if(normal[largestProjCoord] < normal[1]) {
            largestProjCoord = 1;
        }
        if(normal[largestProjCoord] < normal[2]) {
            largestProjCoord = 2;
        }
        uint scanSliceCoord = (largestProjCoord+1)%3;
        uint scanLineCoord = (largestProjCoord+2)%3;

        double triPts[3][3] = {{pt1x, pt1y, pt1z},{pt2x, pt2y, pt2z},{pt3x, pt3y, pt3z}};    // for easy indexing

        // find the min and max
        double minSlice = triPts[0][scanSliceCoord];
        if(minSlice > triPts[1][scanSliceCoord])
            minSlice = triPts[1][scanSliceCoord];
        if(minSlice > triPts[2][scanSliceCoord])
            minSlice = triPts[2][scanSliceCoord];
        double maxSlice = triPts[0][scanSliceCoord];
        if(maxSlice < triPts[1][scanSliceCoord])
            maxSlice = triPts[1][scanSliceCoord];
        if(maxSlice < triPts[2][scanSliceCoord])
            maxSlice = triPts[2][scanSliceCoord];
        double minLine = triPts[0][scanLineCoord];
        if(minLine > triPts[1][scanLineCoord])
            minLine = triPts[1][scanLineCoord];
        if(minLine > triPts[2][scanLineCoord])
            minLine = triPts[2][scanLineCoord];
        double maxLine = triPts[0][scanLineCoord];
        if(maxLine < triPts[1][scanLineCoord])
            maxLine = triPts[1][scanLineCoord];
        if(maxLine < triPts[2][scanLineCoord])
            maxLine = triPts[2][scanLineCoord];
        double minProj = triPts[0][largestProjCoord];
        if(minProj > triPts[1][largestProjCoord])
            minProj = triPts[1][largestProjCoord];
        if(minProj > triPts[2][largestProjCoord])
            minProj = triPts[2][largestProjCoord];
        double maxProj = triPts[0][largestProjCoord];
        if(maxProj < triPts[1][largestProjCoord])
            maxProj = triPts[1][largestProjCoord];
        if(maxProj < triPts[2][largestProjCoord])
            maxProj = triPts[2][largestProjCoord];

        // make sure the slice coordinate has largest variation
        if(maxSlice - minSlice < maxLine - minLine)
        {
            std::swap(minSlice, minLine);
            std::swap(maxSlice, maxLine);
            std::swap(scanSliceCoord, scanLineCoord);
        }

        // sanity check
        /*
        if(normal[scanSliceCoord] == 1.0 || normal[scanSliceCoord] == -1.0)    // check if triangle is coplanar with scanSliceCoord
        {
            std::cout << "Error: TilingNonobtuseMC<T>::markIntersectedCubes: triangle is coplanar with scanSliceCoord" << std::endl;
            return;
        }
        */

        // check which coordinate is the x-coord
        // 0 - ProjCoord
        // 1 - ScanSliceCoord
        // 2 - ScanLineCoord
        uint xCoord = 0;
        if(scanLineCoord == 0)
            xCoord = 2;
        else if(largestProjCoord != 0)
            xCoord = 1;

        uint yCoord = 0;
        if(scanLineCoord == 1)
            yCoord = 2;
        else if(largestProjCoord != 1)
            yCoord = 1;

        uint zCoord = 0;
        if(scanLineCoord == 2)
            zCoord = 2;
        else if(largestProjCoord != 2)
            zCoord = 1;

        // set CellLength and nCells in terms of Proj,Slice,Line coordinate
        double cellLength_PSLCoord[3] = {0,0,0};
        cellLength_PSLCoord[xCoord] = this->iCellLengthX;
        cellLength_PSLCoord[yCoord] = this->iCellLengthY;
        cellLength_PSLCoord[zCoord] = this->iCellLengthZ;
        uint nCells_PSLCoord[3] = {0,0,0};
        nCells_PSLCoord[xCoord] = this->iCellsX;
        nCells_PSLCoord[yCoord] = this->iCellsY;
        nCells_PSLCoord[zCoord] = this->iCellsZ;

        // find the min cube and max cube to start testing each slice
        double cubeCoord = (minSlice - this->iOffsets[scanSliceCoord]) / cellLength_PSLCoord[1];
        int minSliceCube = (int)floor(cubeCoord);
        cubeCoord = (maxSlice - this->iOffsets[scanSliceCoord]) / cellLength_PSLCoord[1];
         int maxSliceCube = (int)ceil(cubeCoord);

        // find the min cube and max cube along scan-line-coord and proj-coord that needs to be covered by the slices
        cubeCoord = (minLine - this->iOffsets[scanLineCoord]) / cellLength_PSLCoord[2];
         int minLineCube = (int)floor(cubeCoord);
        cubeCoord = (maxLine - this->iOffsets[scanLineCoord]) / cellLength_PSLCoord[2];
         int maxLineCube = (int)ceil(cubeCoord);

        cubeCoord = (minProj - this->iOffsets[largestProjCoord]) / cellLength_PSLCoord[0];
         int minProjCube = (int)floor(cubeCoord);
        cubeCoord = (maxProj - this->iOffsets[largestProjCoord]) / cellLength_PSLCoord[0];
        int maxProjCube = (int)ceil(cubeCoord);

        if((minSliceCube+1) == maxSliceCube &&        // triangle is completely within the cube
            (minProjCube+1) == maxProjCube &&
            (minLineCube+1) == maxLineCube)
        {
            // mark the cube
            uint cubeIdx[3] = {minProjCube, minSliceCube, minLineCube};
            if(cubeIdx[xCoord] >= 0 && cubeIdx[xCoord] < this->iCellsX &&    // make sure the cube index is valid
                cubeIdx[yCoord] >= 0 && cubeIdx[yCoord] < this->iCellsY &&
                cubeIdx[zCoord] >= 0 && cubeIdx[zCoord] < this->iCellsZ)
            {    
                addIntersectingTriangle(triangleIdx, (this->iCellsY)*(this->iCellsX)*cubeIdx[zCoord] + (this->iCellsX)*cubeIdx[yCoord] + cubeIdx[xCoord], true);
            }
        }
        else
        {
            // check all slices in all x-y-z axis
            markIntersectedCubes(triangleIdx, triPts, minSliceCube, maxSliceCube, largestProjCoord, scanSliceCoord, scanLineCoord, cellLength_PSLCoord, nCells_PSLCoord);
        
            double updated_CellLen_PSL[3] = {cellLength_PSLCoord[1],cellLength_PSLCoord[2],cellLength_PSLCoord[0]};
            uint updated_nCells_PSL[3] = {nCells_PSLCoord[1],nCells_PSLCoord[2],nCells_PSLCoord[0]};
            markIntersectedCubes(triangleIdx, triPts, minLineCube, maxLineCube, scanSliceCoord, scanLineCoord, largestProjCoord, updated_CellLen_PSL, updated_nCells_PSL);
        
            updated_CellLen_PSL[0] = cellLength_PSLCoord[2];
            updated_CellLen_PSL[1] = cellLength_PSLCoord[0];
            updated_CellLen_PSL[2] = cellLength_PSLCoord[1];
            updated_nCells_PSL[0] = nCells_PSLCoord[2];
            updated_nCells_PSL[1] = nCells_PSLCoord[0];
            updated_nCells_PSL[2] = nCells_PSLCoord[1];
            markIntersectedCubes(triangleIdx, triPts, minProjCube, maxProjCube, scanLineCoord, largestProjCoord, scanSliceCoord, updated_CellLen_PSL, updated_nCells_PSL);
        }
    }

    // determine which cubes between the minSliceCube and maxSliceCube that are intersected by the given triangle
    //
    // triangleIdx (in): index of triangle
    // triPts (in): vertex positions of the triangle
    // minSliceCube (in:) starting slice index
    // maxSliceCube (in:) ending slice index
    // largestProjCoord (in): determines which coordinate has the largest projection area
    // scanSliceCoord (in): determines which coordinate scan slice takes place along
    // scanLineCoord (in): determines which coordinate scan line takes place along
    // cellLength_PSLCoord (in): CellLenth in terms of Proj,Slice,Line coordinate
    // nCells_PSLCoord (in): number of Cells in terms of Proj,Slice,Line coordinate
    template <class T>
    void TilingNonobtuseMC<T>::markIntersectedCubes(
            uint triangleIdx,
            cv::Point3d triPts[3],
            uint minSliceCube,
            uint maxSliceCube,
            uint largestProjCoord,
            uint scanSliceCoord,
            uint scanLineCoord,
            double cellLength_PSLCoord[3],
            uint cells_PSLCoord[3])
    {
        for(int sliceIdx = minSliceCube; sliceIdx <= maxSliceCube && sliceIdx < (int)nCells_PSLCoord[1]; ++sliceIdx)
        {
            // make sure we skip all the cubes that are not valid
            if(sliceIdx < 0) {
                sliceIdx = -1;
                continue;
            }

            // check where the 3 vertices are located relative to the plane
            int vLocFlags[3] = {0,0,0};        // 0-pt is on plane; 1-pt is on front side; -1-pt is on back side
            for(uint j = 0; j < 3; ++j)
            {
                double planeNormal[3] = {0,0,0};
                planeNormal[scanSliceCoord] = 1;
                double testVector[3] = {triPts[j][0],triPts[j][1],triPts[j][2]};
                testVector[scanSliceCoord] -= (sliceIdx*cellLength_PSLCoord[1] + this->iOffsets[scanSliceCoord]);
                double testResult = dotProduct(planeNormal, testVector);        // n dot (x - p0) = 0
                if(testResult < 0)
                    vLocFlags[j] = -1;
                else if(testResult > 0)
                    vLocFlags[j] = 1;
                else
                    vLocFlags[j] = 0;
            }

            double pt1ScanLineCoord = 0;
            double pt1ProjCoord = 0;
            double pt2ScanLineCoord = 0;
            double pt2ProjCoord = 0;
            // check all the cases that may occur when a plane intersects a triangle
            if(vLocFlags[0] == 0 && vLocFlags[1] == 0 && vLocFlags[2] == 0)    // intersects pt1,pt2,pt3; Special Case, ignore it
                continue;
            else if((vLocFlags[0] == 1 && vLocFlags[1] == 1 && vLocFlags[2] == 1) ||    // all 3 pts are on one side
                (vLocFlags[0] == -1 && vLocFlags[1] == -1 && vLocFlags[2] == -1))
                continue;    // no intersection
            else if(vLocFlags[0] == 0 && vLocFlags[1] != 0 && vLocFlags[2] != 0)    // intersects pt1 only
            {
                pt1ScanLineCoord = triPts[0][scanLineCoord];
                pt1ProjCoord = triPts[0][largestProjCoord];
                pt2ScanLineCoord = triPts[0][scanLineCoord];
                pt2ProjCoord = triPts[0][largestProjCoord];
            }
            else if(vLocFlags[0] != 0 && vLocFlags[1] == 0 && vLocFlags[2] != 0)    // intersects pt2 only
            {
                pt1ScanLineCoord = triPts[1][scanLineCoord];
                pt1ProjCoord = triPts[1][largestProjCoord];
                pt2ScanLineCoord = triPts[1][scanLineCoord];
                pt2ProjCoord = triPts[1][largestProjCoord];
            }
            else if(vLocFlags[0] != 0 && vLocFlags[1] != 0 && vLocFlags[2] == 0)    // intersects pt3 only
            {
                pt1ScanLineCoord = triPts[2][scanLineCoord];
                pt1ProjCoord = triPts[2][largestProjCoord];
                pt2ScanLineCoord = triPts[2][scanLineCoord];
                pt2ProjCoord = triPts[2][largestProjCoord];
            }
            else if(vLocFlags[0] == 0 && vLocFlags[1] == 0 && vLocFlags[2] != 0)    // intersects pt1 & pt2 only
            {
                pt1ScanLineCoord = triPts[0][scanLineCoord];
                pt1ProjCoord = triPts[0][largestProjCoord];
                pt2ScanLineCoord = triPts[1][scanLineCoord];
                pt2ProjCoord = triPts[1][largestProjCoord];
            }
            else if(vLocFlags[0] == 0 && vLocFlags[1] != 0 && vLocFlags[2] == 0)    // intersects pt1 & pt3 only
            {
                pt1ScanLineCoord = triPts[0][scanLineCoord];
                pt1ProjCoord = triPts[0][largestProjCoord];
                pt2ScanLineCoord = triPts[2][scanLineCoord];
                pt2ProjCoord = triPts[2][largestProjCoord];
            }
            else if(vLocFlags[0] != 0 && vLocFlags[1] == 0 && vLocFlags[2] == 0)    // intersects pt2 & pt3 only
            {
                pt1ScanLineCoord = triPts[1][scanLineCoord];
                pt1ProjCoord = triPts[1][largestProjCoord];
                pt2ScanLineCoord = triPts[2][scanLineCoord];
                pt2ProjCoord = triPts[2][largestProjCoord];
            }
            else if((vLocFlags[0] == 1 && vLocFlags[1] == -1 && vLocFlags[2] == -1) ||    // pt1 is alone on one side
                    (vLocFlags[0] == -1 && vLocFlags[1] == 1 && vLocFlags[2] == 1))
            {
                double intPt[2][3] = {{0,0,0},{0,0,0}};
                double planeNormal[3] = {0,0,0};
                planeNormal[scanSliceCoord] = 1;
                double ptOnPlane[3] = {0,0,0};
                ptOnPlane[scanSliceCoord] = (sliceIdx*cellLength_PSLCoord[1] + this->iOffsets[scanSliceCoord]);

                if(segment_plane_intersection(intPt[0], planeNormal, ptOnPlane, triPts[0], triPts[1]) != 1)
                {
                    std::cout << "Error: TilingNonobtuseMC<T>::markIntersectedCubes: edge(pt1,pt2) did not intersect plane at a point" << std::endl;
                    return;
                }
            
                if(segment_plane_intersection(intPt[1], planeNormal, ptOnPlane, triPts[0], triPts[2]) != 1)
                {
                    std::cout << "Error: TilingNonobtuseMC<T>::markIntersectedCubes: edge(pt1,pt3) did not intersect plane at a point" << std::endl;
                    return;
                }

                pt1ScanLineCoord = intPt[0][scanLineCoord];
                pt1ProjCoord = intPt[0][largestProjCoord];
                pt2ScanLineCoord = intPt[1][scanLineCoord];
                pt2ProjCoord = intPt[1][largestProjCoord];
            }
            else if((vLocFlags[0] == -1 && vLocFlags[1] == 1 && vLocFlags[2] == -1) ||    // pt2 is alone on one side
                    (vLocFlags[0] == 1 && vLocFlags[1] == -1 && vLocFlags[2] == 1))
            {
                double intPt[2][3] = {{0,0,0},{0,0,0}};
                double planeNormal[3] = {0,0,0};
                planeNormal[scanSliceCoord] = 1;
                double ptOnPlane[3] = {0,0,0};
                ptOnPlane[scanSliceCoord] = (sliceIdx*cellLength_PSLCoord[1] + this->iOffsets[scanSliceCoord]);

                if(segment_plane_intersection(intPt[0], planeNormal, ptOnPlane, triPts[1], triPts[0]) != 1)
                {
                    std::cout << "Error: TilingNonobtuseMC<T>::markIntersectedCubes: edge(pt2,pt1) did not intersect plane at a point" << std::endl;
                    return;
                }
            
                if(segment_plane_intersection(intPt[1], planeNormal, ptOnPlane, triPts[1], triPts[2]) != 1)
                {
                    std::cout << "Error: TilingNonobtuseMC<T>::markIntersectedCubes: edge(pt2,pt3) did not intersect plane at a point" << std::endl;
                    return;
                }

                pt1ScanLineCoord = intPt[0][scanLineCoord];
                pt1ProjCoord = intPt[0][largestProjCoord];
                pt2ScanLineCoord = intPt[1][scanLineCoord];
                pt2ProjCoord = intPt[1][largestProjCoord];
            }
            else if((vLocFlags[0] == -1 && vLocFlags[1] == -1 && vLocFlags[2] == 1) ||    // pt3 is alone on one side
                    (vLocFlags[0] == 1 && vLocFlags[1] == 1 && vLocFlags[2] == -1))
            {
                double intPt[2][3] = {{0,0,0},{0,0,0}};
                double planeNormal[3] = {0,0,0};
                planeNormal[scanSliceCoord] = 1;
                double ptOnPlane[3] = {0,0,0};
                ptOnPlane[scanSliceCoord] = (sliceIdx*cellLength_PSLCoord[1] + this->iOffsets[scanSliceCoord]);

                if(segment_plane_intersection(intPt[0], planeNormal, ptOnPlane, triPts[2], triPts[0]) != 1)
                {
                    std::cout << "Error: TilingNonobtuseMC<T>::markIntersectedCubes: edge(pt3,pt1) did not intersect plane at a point" << std::endl;
                    return;
                }
            
                if(segment_plane_intersection(intPt[1], planeNormal, ptOnPlane, triPts[2], triPts[1]) != 1)
                {
                    std::cout << "Error: TilingNonobtuseMC<T>::markIntersectedCubes: edge(pt3,pt2) did not intersect plane at a point" << std::endl;
                    return;
                }

                pt1ScanLineCoord = intPt[0][scanLineCoord];
                pt1ProjCoord = intPt[0][largestProjCoord];
                pt2ScanLineCoord = intPt[1][scanLineCoord];
                pt2ProjCoord = intPt[1][largestProjCoord];
            }

            // mark all cubes by scan line
            markIntersectedCubes(triangleIdx, pt1ScanLineCoord, pt1ProjCoord, pt2ScanLineCoord, pt2ProjCoord, sliceIdx, largestProjCoord, scanLineCoord);
        }
    }

    // determine which cubes are intersected by the given line segment
    //
    // triangleIdx (in): index of triangle
    // pt1ScanLineCoord (in): scan-line coord. of vertex 1 of line segment
    // pt1ProjCoord (in): projection coord. of vertex 1 of line segment
    // pt2ScanLineCoord (in): scan-line coord. of vertex 2 of line segment
    // pt2ProjCoord (in): projection coord. of vertex 2 of line segment
    // scanSliceCubeIdx (in): slice cube index; determines which slice the line is at
    // projCoord (in): determines which coordinate has the largest projection area
    // scanLineCoord (in): determines which coordinate scan long takes place along
    template <class T>
    void TilingNonobtuseMC<T>::markIntersectedCubes(
        uint triangleIdx,
        double pt1ScanLineCoord,
        double pt1ProjCoord,
        double pt2ScanLineCoord,
        double pt2ProjCoord,
        uint scanSliceCubeIdx,
        uint projCoord,
        uint scanLineCoord)
    {
        // make sure pt1 has min along scanLineCoord
        if(pt1ScanLineCoord > pt2ScanLineCoord)
        {
            std::swap(pt1ScanLineCoord, pt2ScanLineCoord);
            std::swap(pt1ProjCoord, pt2ProjCoord);
        }
        else if(pt1ScanLineCoord == pt2ScanLineCoord)
        {
            if(pt1ProjCoord > pt2ProjCoord)
            {
                std::swap(pt1ProjCoord, pt2ProjCoord);
            }
        }
        // check which coordinate is the x-coord
        // 0 - ProjCoord
        // 1 - ScanSliceCoord
        // 2 - ScanLineCoord
        uint xCoord = 0;
        if(scanLineCoord == 0)
        {
            xCoord = 2;
        }
        else if(projCoord != 0)
        {
            xCoord = 1;
        }
        uint yCoord = 0;
        if(scanLineCoord == 1)
        {
            yCoord = 2;
        }
        else if(projCoord != 1)
        {
            yCoord = 1;
        }
        uint zCoord = 0;
        if(scanLineCoord == 2)
        {
            zCoord = 2;
        }
        else if(projCoord != 2)
        {
            zCoord = 1;
        }
        // set cellLength, cells, offsets in terms of proj, slice, line coordinate
        double cellLength_PSLCoord[3] = {0, 0, 0};
        cellLength_PSLCoord[xCoord] = this->iCellLengthX;
        cellLength_PSLCoord[yCoord] = this->iCellLengthY;
        cellLength_PSLCoord[zCoord] = this->iCellLengthZ;
        double offsets_PSLCoord[3] = {0, 0, 0};
        offsets_PSLCoord[xCoord] = this->iOffsets[0];
        offsets_PSLCoord[yCoord] = this->iOffsets[1];
        offsets_PSLCoord[zCoord] = this->iOffsets[2];
        // calculate slope of line pt1-pt2
        double slopeDenominator = pt2ScanLineCoord - pt1ScanLineCoord;
        double slopeNominator = pt2ProjCoord - pt1ProjCoord;
        double slope = 0;
        if(slopeDenominator != 0)
        {
            slope = slopeNominator/slopeDenominator;
        }
        bool pt1_lies_LineCoord = false;
        bool pt1_lies_ProjCoord = false;
        bool pt2_lies_LineCoord = false;
        bool pt2_lies_ProjCoord = false;
        bool pt1_closeTo_LineCoord = false;
        bool pt1_closeTo_FloorProjCoord = false;
        bool pt1_closeTo_CeilProjCoord = false;
        // -----------------------------------------------
        // -------- find which box pt1 resides in --------
        // -----------------------------------------------
        double cubeCoord = (pt1ScanLineCoord - this->iOffsets[scanLineCoord]) / cellLength_PSLCoord[2];
        int currentLineBox = (int)floor(cubeCoord);        
        if(cubeCoord == ceil(cubeCoord)) // pt1 intersects at edge along the scan-line-coord
        {    
            pt1_lies_LineCoord = true;
            currentLineBox = (int)ceil(cubeCoord);
        }
        else if(std::equal(cubeCoord, floor(cubeCoord), 0.00001)) // pt1 is very close at edge along the scan-line-coord
        {
            currentLineBox = (int)floor(cubeCoord) - 1; // make sure we examine more thoroughly to avoid roundoff errors
            pt1_closeTo_LineCoord = true;
        }
        cubeCoord = (pt1ProjCoord - this->iOffsets[projCoord]) / cellLength_PSLCoord[0];
        int currentProjBox = (int)floor(cubeCoord);
        if(cubeCoord == ceil(cubeCoord)) // pt1 intersects at edge along the proj-coord
        {
            pt1_lies_ProjCoord = true;
            currentProjBox = (int)ceil(cubeCoord);        
        }
        else if(std::equal(cubeCoord, ceil(cubeCoord), 0.00001)) // pt1 is very close at edge along the proj-coord
        {
            currentProjBox = (int)ceil(cubeCoord); // make sure we examine more thoroughly to avoid roundoff errors
            pt1_closeTo_CeilProjCoord = true;
        }
        else if(std::equal(cubeCoord, floor(cubeCoord), 0.00001)) // pt1 is very close at edge along the proj-coord
        {
            currentProjBox = (int)floor(cubeCoord) - 1; // make sure we examine more thoroughly to avoid roundoff errors
            pt1_closeTo_FloorProjCoord = true;
        }
        if(pt1_lies_LineCoord && pt1_lies_ProjCoord) // pt1 lies at grid corner
        {
            if(slope < 0)
            {
                --currentProjBox;
            }
        }
        else if(pt1_lies_ProjCoord) // pt1 lies along the projCoord grid
        {
            if(slope < 0)
            {
                --currentProjBox;
            }
        }
        // -----------------------------------------------
        // -------- find which box pt2 resides in --------
        // -----------------------------------------------
        cubeCoord = (pt2ScanLineCoord - this->iOffsets[scanLineCoord]) / cellLength_PSLCoord[2];
        int lastLineBox = (int)floor(cubeCoord);
        if(cubeCoord == ceil(cubeCoord)) // pt2 intersects at edge along the scan-line-coord
        {
            pt2_lies_LineCoord = true;
            lastLineBox = (int)ceil(cubeCoord);                    
        }
        else if(std::equal(cubeCoord, ceil(cubeCoord), 0.00001)) // pt2 is very close at edge along the scan-line-coord
        {
            lastLineBox = (int)ceil(cubeCoord); // make sure we examine more thoroughly to avoid roundoff errors
        }
        cubeCoord = (pt2ProjCoord - this->iOffsets[projCoord]) / cellLength_PSLCoord[0];
        int lastProjBox = (int)floor(cubeCoord);
        if(cubeCoord == ceil(cubeCoord)) // pt2 intersects at edge along the proj-coord
        {
            pt2_lies_ProjCoord = true;
            lastProjBox = (int)ceil(cubeCoord);                    
        }
        else if(std::equal(cubeCoord, ceil(cubeCoord), 0.00001)) // pt2 is very close at edge along the proj-coord
        {
            lastProjBox = (int)ceil(cubeCoord); // make sure we examine more thoroughly to avoid roundoff errors
        }
        else if(std::equal(cubeCoord, floor(cubeCoord), 0.00001)) // pt2 is very close at edge along the proj-coord
        {
            lastProjBox = (int)floor(cubeCoord) - 1; // make sure we examine more thoroughly to avoid roundoff errors
        }
        if(pt2_lies_LineCoord && pt2_lies_ProjCoord) // pt2 lies at grid corner
        {
            if(slopeDenominator == 0)
            {
                --lastProjBox;
            }
            else if(slope < 0)
            {
                --lastLineBox;
            }
            else if(slope > 0)
            {
                --lastLineBox;
                --lastProjBox;
            }
            else
            {
                --lastLineBox;
            }
        }
        else if(pt2_lies_ProjCoord) // pt2 lies along the projCoord grid
        {
            if(slopeDenominator == 0)
            {
                --lastProjBox;
            }
            else if(slope > 0)
            {
                --lastProjBox;
            }
        }
        else if(pt2_lies_LineCoord) // pt2 lies along the lineCoord grid
        {
            if(slopeDenominator != 0)
            {
                --lastLineBox;
            }
        }
        // -------------------------------------------------------
        // -------- traverse boxes along the line pt1-pt2 --------
        // -------------------------------------------------------
        bool addLastCube = true;
        int cubeIdx[3] = {currentProjBox, scanSliceCubeIdx, currentLineBox};
        while((currentLineBox <= lastLineBox) && 
            ((slopeDenominator == 0 && currentProjBox <= lastProjBox) ||
            (slope >= 0 && currentProjBox <= lastProjBox) ||
            (slope < 0 && currentProjBox >= lastProjBox)))
        {
            // mark current cube as intersected
            cubeIdx[0] = currentProjBox;
            cubeIdx[1] = scanSliceCubeIdx;
            cubeIdx[2] = currentLineBox;
            for(uint i = 0; i < 2; ++i)
            {
                if(cubeIdx[xCoord] >= 0 && cubeIdx[xCoord] < (int)this->iCellsX && // make sure the cube index is valid
                    cubeIdx[yCoord] >= 0 && cubeIdx[yCoord] < (int)this->iCellsY &&
                    cubeIdx[zCoord] >= 0 && cubeIdx[zCoord] < (int)this->iCellsZ)
                {    
                    addIntersectingTriangle(triangleIdx, (this->iCellsY)*(this->iCellsX)*cubeIdx[zCoord] + (this->iCellsX)*cubeIdx[yCoord] + cubeIdx[xCoord], false);
                }
                cubeIdx[1] = scanSliceCubeIdx - 1;    // make sure we add the cubes for previous slice in case last slice missed any cubes
            }

            // find which side of the box intersects
            if(slopeDenominator == 0)    // line is vertical; slope infinite
                ++currentProjBox;
            else if(slope == 0)        // line is horizontal; slope 0
                ++currentLineBox;
            else if(slope > 0)            // line is going upward; slope > 0
            {
                double seg1[3] = {currentLineBox*cellLength_PSLCoord[2] + offsets_PSLCoord[2],
                    (currentProjBox+1)*cellLength_PSLCoord[0] + offsets_PSLCoord[0],
                    0};
                double seg2[3] = {(currentLineBox+1)*cellLength_PSLCoord[2] + offsets_PSLCoord[2], seg1[1], seg1[2]};
                double intPt[3] = {0,0,0};
                double pt1[3] = {pt1ScanLineCoord, pt1ProjCoord, 0};
                double pt2[3] = {pt2ScanLineCoord, pt2ProjCoord, 0};

                // test intersecting edge with top edge
                int res1 = segment_line_intersection(intPt, pt1, pt2, seg1, seg2);

                seg1[0] = seg2[0];
                seg1[1] = currentProjBox*cellLength_PSLCoord[0] + offsets_PSLCoord[0];
                // test intersecting edge with right edge
                int res2 = segment_line_intersection(intPt, pt1, pt2, seg1, seg2);

                if(res1 == 1 && res2 == 1)        // intersected top-right corner
                {
                    ++currentProjBox;
                    ++currentLineBox;
                }
                else if(res1 == 1 && res2 == 0)    // intersected top edge
                {
                    ++currentProjBox;
                }
                else if(res1 == 0 && res2 == 1)    // intersected right edge
                {
                    ++currentLineBox;
                }
                else if(res1 == 0 && res2 == 0)    // line stops at current cube
                {
                    if(pt1_closeTo_LineCoord)                // extra check for roundoff error fail, so increment by one along lineCoord
                        ++currentLineBox;
                    else if(pt1_closeTo_FloorProjCoord)    // extra check for roundoff error fail, so increment by one along projCoord
                        ++currentProjBox;
                    else if(pt1_closeTo_CeilProjCoord)        // extra check for roundoff error fail, so decrement by one along projCoord
                        --currentProjBox;
                    else
                    {
                        addLastCube = false;
                        break;
                    }
                }
                else                            // special cases?! THIS SHOULDN'T HAPPEN
                {
                    // ignore it
                }
            }
            else                        // line is going downward; slope < 0
            {
                double seg1[3] = {currentLineBox*cellLength_PSLCoord[2] + offsets_PSLCoord[2],
                    currentProjBox*cellLength_PSLCoord[0] + offsets_PSLCoord[0],
                    0};
                double seg2[3] = {(currentLineBox+1)*cellLength_PSLCoord[2] + offsets_PSLCoord[2], seg1[1], seg1[2]};
                double intPt[3] = {0,0,0};
                double pt1[3] = {pt1ScanLineCoord, pt1ProjCoord, 0};
                double pt2[3] = {pt2ScanLineCoord, pt2ProjCoord, 0};

                // test intersecting edge with bottom edge
                int res1 = segment_line_intersection(intPt, pt1, pt2, seg1, seg2);

                seg1[0] = seg2[0];
                seg1[1] = (currentProjBox+1)*cellLength_PSLCoord[0] + offsets_PSLCoord[0];
                // test intersecting edge with right edge
                int res2 = segment_line_intersection(intPt, pt1, pt2, seg1, seg2);

                if(res1 == 1 && res2 == 1)        // intersected bottom-right corner
                {
                    --currentProjBox;
                    ++currentLineBox;
                }
                else if(res1 == 1 && res2 == 0)    // intersected bottom edge
                {
                    --currentProjBox;
                }
                else if(res1 == 0 && res2 == 1)    // intersected right edge
                {
                    ++currentLineBox;
                }
                else if(res1 == 0 && res2 == 0)    // line stops at current cube
                {
                    if(pt1_closeTo_LineCoord)                // extra check for roundoff error fail, so increment by one along lineCoord
                        ++currentLineBox;
                    else if(pt1_closeTo_FloorProjCoord)    // extra check for roundoff error fail, so increment by one along projCoord
                        ++currentProjBox;
                    else if(pt1_closeTo_CeilProjCoord)        // extra check for roundoff error fail, so decrement by one along projCoord
                        --currentProjBox;
                    else
                    {
                        addLastCube = false;
                        break;
                    }
                }
                else                            // special cases?! THIS SHOULDN'T HAPPEN
                {
                    // ignore it
                }
            }        
        }
    }

    // add triangle 'triIdx' to be intersecting cube 'cubeIdx'
    //
    // triIdx (in): index of intersecting triangle
    // cubeIdx (in): cube index
    // insideCube(in): true if triangle is completely inside the cube
    template <class T> void TilingNonobtuseMC<T>::addIntersectingTriangle(uint triangleIdx, uint cubeIdx, bool insideCube)
    {
        std::vector<IntersectTri> &intTriList = this->iCubesProperty[cubeIdx].iIntTriVec;

        IntersectTri intTri;
        intTri.iTriIdx = triangleIdx;
        intTri.insideCube = insideCube;

        if(find(intTriList.begin(), intTriList.end(), intTri) == intTriList.end())
            intTriList.push_back(intTri);
    }

    // // sort the intersected triangles of cubeIdx into connected components
    // //
    // // cubeIdx (in): index of cube to be sorted
    // // polygonNeighbourList (in): polygon neighbour information for source mesh
    template <class T> void TilingNonobtuseMC<T>::sortIntersectingTriangle(uint cubeIdx, const std::vector<int>* polygonNeighbourList)
    {
        uint numIntTri = this->iCubesProperty[cubeIdx].iIntTriVec.size();
        if(numIntTri == 0)
            return;

        std::vector<uint> needSortedList;
        for(uint i = 0; i < numIntTri; ++i)
            needSortedList.push_back(i);

        std::vector<vector<int> > &triGroups = this->iCubesProperty[cubeIdx].triGroups;
        // continue to add new group when there are still unsorted triangles
        while(!needSortedList.empty())
        {
            triGroups.resize(triGroups.size()+1);
            expandGroup(cubeIdx, polygonNeighbourList, triGroups.size()-1, 0, needSortedList);
        }

        // create space for the signs generated by this patch
        for(uint i = 0; i < triGroups.size(); ++i) {
            std::vector<int> unsetSigns(8,0);
            this->iCubesProperty[cubeIdx].signs.push_back(unsetSigns);
            this->iCubesProperty[cubeIdx].isConsistent.push_back(true);
            this->iCubesProperty[cubeIdx].isEmptyTriangulation.push_back(false);
        }
    }

    // expand a connected component group by adding triIdx into groupIdx and expand it
    //
    // cubeIdx (in): index of cube to be sorted
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // groupIdx (in): index of group to expand
    // triIdx (in): index of intersecting triangle in the needSortedList array to add to the group and expand
    // needSortedList (in/out): index of intersecting triangles in iIntTriVec need to be sorted
    template <class T> void TilingNonobtuseMC<T>::expandGroup(uint cubeIdx, const std::vector<int>* polygonNeighbourList, uint groupIdx, uint triIdx, std::vector<uint> &needSortedList)
    {
        std::vector<IntersectTri> &intTriList = this->iCubesProperty[cubeIdx].iIntTriVec;
        std::vector<vector<int> > &triGroups = this->iCubesProperty[cubeIdx].triGroups;

        uint triangleAdded = intTriList[needSortedList[triIdx]].iTriIdx;

        // if triIdx is in group, then no need to check
        if(find(triGroups[groupIdx].begin(), triGroups[groupIdx].end(), (int)needSortedList[triIdx]) != triGroups[groupIdx].end())
            return;
    
        // add triIdx to group first if not in group already
        triGroups[groupIdx].push_back(needSortedList[triIdx]);
        intTriList[needSortedList[triIdx]].patchNo = groupIdx;
        
        // remove triIdx from needSortedList
        needSortedList.erase(needSortedList.begin() + triIdx);

        // expand group by examining the neighbour of triangle just added
        for(vector<int>::const_iterator iter = polygonNeighbourList[triangleAdded].begin(); iter != polygonNeighbourList[triangleAdded].end(); iter++)
        {
            for(uint i = 0; i < needSortedList.size(); ++i) {
                if(intTriList[needSortedList[i]].iTriIdx == *iter) {
                    expandGroup(cubeIdx, polygonNeighbourList, groupIdx, i, needSortedList);
                    break;
                }
            }
        }
    }

    // compute the intersecting point on the specified edge of the cube
    //
    // nX (in): x-coord of cube
    // nY (in): y-coord of cube
    // nZ (in): z-coord of cube
    // edgeNo (in): edge number the vertex is to be put on
    template <class T> Point3dId TilingNonobtuseMC<T>::computeVertexLocation(uint nX, uint nY, uint nZ, uint edgeNo)
    {
        float x1, y1, z1, x2, y2, z2;
        uint v1x = nX, v1y = nY, v1z = nZ;
        uint v2x = nX, v2y = nY, v2z = nZ;
    
        switch (edgeNo)
        {
        case 0:
            v2y += 1;
            break;
        case 1:
            v1y += 1;
            v2x += 1;
            v2y += 1;
            break;
        case 2:
            v1x += 1;
            v1y += 1;
            v2x += 1;
            break;
        case 3:
            v1x += 1;
            break;
        case 4:
            v1z += 1;
            v2y += 1;
            v2z += 1;
            break;
        case 5:
            v1y += 1;
            v1z += 1;
            v2x += 1;
            v2y += 1;
            v2z += 1;
            break;
        case 6:
            v1x += 1;
            v1y += 1;
            v1z += 1;
            v2x += 1;
            v2z += 1;
            break;
        case 7:
            v1x += 1;
            v1z += 1;
            v2z += 1;
            break;
        case 8:
            v2z += 1;
            break;
        case 9:
            v1y += 1;
            v2y += 1;
            v2z += 1;
            break;
        case 10:
            v1x += 1;
            v1y += 1;
            v2x += 1;
            v2y += 1;
            v2z += 1;
            break;
        case 11:
            v1x += 1;
            v2x += 1;
            v2z += 1;
            break;
        }

        x1 = v1x*(this->iCellLengthX) + (this->iOffsets[0]);
        y1 = v1y*(this->iCellLengthY) + (this->iOffsets[1]);
        z1 = v1z*(this->iCellLengthZ) + (this->iOffsets[2]);
        x2 = v2x*(this->iCellLengthX) + (this->iOffsets[0]);
        y2 = v2y*(this->iCellLengthY) + (this->iOffsets[1]);
        z2 = v2z*(this->iCellLengthZ) + (this->iOffsets[2]);

        Point3dId intersection = this->Interpolate(x1, y1, z1, x2, y2, z2, -1, 1);
    
        return intersection;
    }

    // unused vertices are moved to end of array;
    //
    // vertexList (in): source mesh's vertices list
    // polygonList (in): source mesh's polygons list
    template <class T>
    void TilingNonobtuseMC<T>::renameVerticesAndTriangles(
            const std::vector<cv::Point3d>& vertexList,
            const std::vector<std::vector<uint>>& polygonList)
    {
        uint nextId = 0;
        Id2Point3dId::iterator mapIter = this->iId2Point3dId.begin();
        // Rename vertices.
        this->iVertices.clear();
        this->iClosestTriList = new uint[this->iId2Point3dId.size()];
        while(mapIter != this->iId2Point3dId.end())
        {
            this->iVertices.push_back(mapIter->second.iPt);
            mapIter->second.iId = nextId;

            this->iClosestTriList[nextId] = -1;
            if(!this->iV2Tri[mapIter->first].empty())
            {
                CubeId c = this->iTri2CubeId[this->iV2Tri[mapIter->first][0]][0];
                uint cubeIdx = this->iCellsX * this->iCellsY * c.z + this->iCellsX * c.y + c.x;
                uint pNo = this->iTri2Patch[this->iV2Tri[mapIter->first][0]][0];
                std::vector<IntersectTri>& iIntTriVec = this->iCubesProperty[cubeIdx].iIntTriVec;
                std::vector<uint>& group = this->iCubesProperty[cubeIdx].iTriGroups[pNo];

                int closestTriIdx = -1;
                double closestDist = -1.0;
                for(uint i = 0; i < group.size(); ++i)
                {
                    cv::Point3d pt = mapIter->second.iPt;
                    cv::Point3d triPt1 = vertexList[polygonList[iIntTriVec[group[i]].iTriIdx][0]];
                    cv::Point3d triPt2 = vertexList[polygonList[iIntTriVec[group[i]].iTriIdx][1]];
                    cv::Point3d triPt3 = vertexList[polygonList[iIntTriVec[group[i]].iTriIdx][2]];

                    cv::Point3d closestPt_tri;
                    double dist = Utility::pointTriangleDistance(pt, triPt1, triPt2, triPt3, closestPt_tri);
                    if(closestTriIdx == -1 || dist < closestDist)
                    {
                        closestTriIdx = iIntTriVec[group[i]].iTriIdx;
                        closestDist = dist;
                    }
                }
                this->iClosestTriList[nextId] = iIntTriVec[group.front()].iTriIdx;
            }
            ++nextId;
            ++mapIter;
        }

        // Now rename triangles.
        Triangle triangle;
        for(TriangleVec::iterator triIter = this->iTriangleVec.begin(); triIter != this->iTriangleVec.end(); ++triIter)
        {
            triangle.x = this->iId2Point3dId[triIter->x].iId;
            triangle.y = this->iId2Point3dId[triIter->y].iId;
            triangle.z = this->iId2Point3dId[triIter->z].iId;
            this->iTriangleIndices.push_back(triangle);
        }

        this->iId2Point3dId.clear();
        this->iTriangleVec.clear();
    }

    // modified from base class
    // edge 12: (b,e) in special case 5b
    // edge 13: (b,e) in special case 9b
    // edge 14: (b,f) in special case 11b ***OBSOLETE***
    // edge 14: (a,d) in special case 11c
    // edge 15: (b,e) in special case 12b
    // edge 16: (b,f) in special case 14b ***OBSOLETE***
    // edge 16: (a,d) in special case 14c
    // edge 17: (b,e) in special case -7
    // edge 18: (a,d) in special case -3
    // edge 19: center of cube in special case -6
    template <class T> uint TilingNonobtuseMC<T>::getEdgeId(uint nX, uint nY, uint nZ, uint edgeNo) const
    {
        switch (edgeNo) {
        case 0:
            return this->getVertexId(nX, nY, nZ) + 1;
        case 1:
            return this->getVertexId(nX, nY + 1, nZ);
        case 2:
            return this->getVertexId(nX + 1, nY, nZ) + 1;
        case 3:
            return this->getVertexId(nX, nY, nZ);
        case 4:
            return this->getVertexId(nX, nY, nZ + 1) + 1;
        case 5:
            return this->getVertexId(nX, nY + 1, nZ + 1);
        case 6:
            return this->getVertexId(nX + 1, nY, nZ + 1) + 1;
        case 7:
            return this->getVertexId(nX, nY, nZ + 1);
        case 8:
            return this->getVertexId(nX, nY, nZ) + 2;
        case 9:
            return this->getVertexId(nX, nY + 1, nZ) + 2;
        case 10:
            return this->getVertexId(nX + 1, nY + 1, nZ) + 2;
        case 11:
            return this->getVertexId(nX + 1, nY, nZ) + 2;
        case 12:
            return this->getVertexId(nX, nY, nZ) + 3;
        case 13:
            return this->getVertexId(nX, nY, nZ) + 4;
        case 14:                           
            return this->getVertexId(nX, nY, nZ) + 5;
        case 15:
            return this->getVertexId(nX, nY, nZ) + 6;
        case 16:
            return this->getVertexId(nX, nY, nZ) + 7;
        case 17:
            return this->getVertexId(nX, nY, nZ) + 8;
        case 18:
            return this->getVertexId(nX, nY, nZ) + 9;
        case 19:
            return this->getVertexId(nX, nY, nZ) + 10;
        default:
            // Invalid edge no.
            return -1;
        }
    }

    // modified from base class
    // this class: each cube has 11 vertices
    // edge 12: (b,e) in special case 5b
    // edge 13: (b,e) in special case 9b
    // edge 14: (a,d) in special case 11c
    // edge 15: (b,e) in special case 12b
    // edge 16: (a,d) in special case 14c
    // edge 17: (b,e) in special case -7
    // edge 18: (a,d) in special case -3
    // edge 19: center of cube in special case -6
    template <class T> uint TilingNonobtuseMC<T>::getVertexId(uint nX, uint nY, uint nZ) const
    {
        return 11*(nZ*(this->iCellsY + 1)*(this->iCellsX + 1) + nY*(this->iCellsX + 1) + nX);
    }

    // Returns the face ID of cube.
    template <class T> uint TilingNonobtuseMC<T>::getFaceId(uint nX, uint nY, uint nZ, uint nFaceNo) const
    {
        switch (nFaceNo) {
        case 0:
            return 3*((this->iCellsX)*(this->iCellsY)*(nZ+1) + (this->iCellsX)*nY + nX) + 2;
        case 1:
            return 3*((this->iCellsX)*(this->iCellsY)*nZ + (this->iCellsX)*nY + nX);
        case 2:
            return 3*((this->iCellsX)*(this->iCellsY)*nZ + (this->iCellsX)*nY + nX) + 2;
        case 3:
            return 3*((this->iCellsX)*(this->iCellsY)*nZ + (this->iCellsX)*nY + (nX+1));
        case 4:
            return 3*((this->iCellsX)*(this->iCellsY)*nZ + (this->iCellsX)*(nY+1) + nX) + 1;
        case 5:
            return 3*((this->iCellsX)*(this->iCellsY)*nZ + (this->iCellsX)*nY + nX) + 1;
        default:
            // Invalid face no.
            return -1;
        }
    }

    // check the triangulated cube(x,y,z) if it needs any stitching, if so, stitch it
    //
    // x (in): x-coord of cube
    // y (in): y-coord of cube
    // z (in): z-coord of cube
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    template <class T> void TilingNonobtuseMC<T>::checkStitching(uint x, uint y, uint z, const std::vector<int>* polygonNeighbourList)
    {
        int faceToConsider[3] = {1,2,5};

        // sanity check
        if(x > this->iCellsX || y > this->iCellsY || z > this->iCellsZ)
            return;

        for(uint k = 0; k < 3; ++k)
        {
            if(x == this->iCellsX && y == this->iCellsY && z == this->iCellsZ)
                break;
            else if(x == this->iCellsX && y == this->iCellsY)
                break;
            else if(x == this->iCellsX && z == this->iCellsZ)
                break;
            else if(z == this->iCellsZ && y == this->iCellsY)
                break;
            else if(x == this->iCellsX)
            {
                if(k != 0)
                    continue;
            }
            else if(y == this->iCellsY)
            {
                if(k != 2)
                    continue;
            }
            else if(z == this->iCellsZ)
            {
                if(k != 1)
                    continue;
            }

            bool needStitch = false;
        
            std::vector<EdgePosInfo> &edgesOnFace = this->iEonF[GetFaceID(x, y, z, faceToConsider[k])];
    
            // pre-process the edges and stitch up all the edge pairs that uses the same set of vertices
            for(int i = 0; i < (int)edgesOnFace.size(); ++i)
            {
                // check if edge is open, if not, skip to next edge
                if(this->iV2Tri[edgesOnFace[i].edgeIdx].size() >= 2)
                {
                    continue;
                }

                Edge e1 = this->iEdgeList[edgesOnFace[i].edgeIdx];
                for(uint j = i+1; j < edgesOnFace.size(); ++j)
                {
                    // check if edge is open, if not, skip to next edge
                    if(this->iV2Tri[edgesOnFace[j].edgeIdx].size() >= 2)
                    {
                        continue;
                    }

                    Edge e2 = this->iEdgeList[edgesOnFace[j].edgeIdx];
                    if((e1.vertex1Idx == e2.vertex1Idx && e1.vertex2Idx == e2.vertex2Idx) || (e1.vertex1Idx == e2.vertex2Idx && e1.vertex2Idx == e2.vertex1Idx))
                    {
                        if(stitch(edgesOnFace[i], edgesOnFace[j], x, y, z, faceToConsider[k], polygonNeighbourList))
                        {
                        
                        }
                        else
                            std::cout << "TilingNonobtuseMC<T>::checkStitching() - cannot stitch edges during pre-processing" << std::endl;
                    }
                }
            }

            // try to pair up edges and stitch them
            for(int i = 0; i < (int)edgesOnFace.size(); ++i)
            {
                // check if edge is open, if not, skip to next edge
                if(this->iV2Tri[edgesOnFace[i].edgeIdx].size() >= 2)
                {
                    continue;
                }

                for(uint j = i+1; j < edgesOnFace.size(); ++j)
                {
                    // check if edge is open, if not, skip to next edge
                    if(this->iV2Tri[edgesOnFace[j].edgeIdx].size() >= 2)
                    {
                        continue;
                    }

                    if(shouldStitch(edgesOnFace[i].edgeIdx, edgesOnFace[j].edgeIdx, x, y, z, faceToConsider[k], polygonNeighbourList))
                    {
                        if(stitch(edgesOnFace[i], edgesOnFace[j], x, y, z, faceToConsider[k], polygonNeighbourList))
                        {
                            needStitch = true;
                            i = -1;
                            break;
                        }
                    }
                }
            }

            if(needStitch)
                ++this->iNumFaceStitching;
        }
    }

    // returns true if edge 'edge1Idx' and 'edge2Idx' should be stitched up
    //
    // edge1Idx (in): edge index 1
    // edge2Idx (in): edge index 2
    // x,y,z (in):    index of cube where stitching was invoked
    // faceIdx (in): face index of where stitching occurs on cube
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // return value (out): true if edge 'edge1Idx' and 'edge2Idx' should be stitched up
    template <class T> bool TilingNonobtuseMC<T>::shouldStitch(uint edge1Idx, uint edge2Idx, uint x, uint y, uint z, uint faceIdx, const std::vector<int>* polygonNeighbourList)
    {
        // setting up quick indexing of adjacent cube
        int adjacentCube[6][3] = {{x,y,z+1}, {x-1,y,z}, {x,y,z-1}, {x+1,y,z}, {x,y+1,z}, {x,y-1,z}};

        // sanity check
        if(this->iV2Tri[edge1Idx].size() != 1 || this->iV2Tri[edge2Idx].size() != 1)
            return false;
    
        int tri1Idx = this->iV2Tri[edge1Idx][0];
        int tri2Idx = this->iV2Tri[edge2Idx][0];

    //     int patch1No = this->iTri2Patch[tri1Idx];
    //     int patch2No = this->iTri2Patch[tri2Idx];

        CubeID helperCube1(x,y,z);
        CubeID helperCube2(adjacentCube[faceIdx][0], adjacentCube[faceIdx][1], adjacentCube[faceIdx][2]);

        // SPECIAL CASE: two edges generated from the same patch within a cube. Only stitch it if the patch is connected to some black patch in the other cube
    //     if(this->iTri2CubeId[tri1Idx].x == this->iTri2CubeId[tri2Idx].x && this->iTri2CubeId[tri1Idx].y == this->iTri2CubeId[tri2Idx].y && this->iTri2CubeId[tri1Idx].z == this->iTri2CubeId[tri2Idx].z && patch1No == patch2No)
    //     {
    //         if(this->iTri2CubeId[tri1Idx].x == x && this->iTri2CubeId[tri1Idx].y == y && this->iTri2CubeId[tri1Idx].z == z)
    //             return isConnected_samePatch(this->iTri2CubeId[tri1Idx].x, this->iTri2CubeId[tri1Idx].y, this->iTri2CubeId[tri1Idx].z, patch1No, helperCube2, polygonNeighbourList);
    //         else
    //             return isConnected_samePatch(this->iTri2CubeId[tri1Idx].x, this->iTri2CubeId[tri1Idx].y, this->iTri2CubeId[tri1Idx].z, patch1No, helperCube1, polygonNeighbourList);
    //     }
        std::vector<CubeID> &cID1List = this->iTri2CubeId[tri1Idx];
        std::vector<uint> &pNo1List = this->iTri2Patch[tri1Idx];
        std::vector<CubeID> &cID2List = this->iTri2CubeId[tri2Idx];
        std::vector<uint> &pNo2List = this->iTri2Patch[tri2Idx];
        for(uint i = 0; i < cID1List.size(); ++i)
        {
            for(uint j = 0; j < cID2List.size(); ++j)
            {
                // never stitch edges generated from same patch.... for now!
                if(cID1List[i].x == cID2List[j].x && cID1List[i].y == cID2List[j].y && cID1List[i].z == cID2List[j].z && pNo1List[i] == pNo2List[j])
                {
                    // stitch edges generated from same patch if and only if there exist a black patch that connects the two edges
                    // THIS MAY NOT BE CORRECT CONCEPTUALLY!!!
    //                 if(isConnected_samePatch(cID1List[i].x, cID1List[i].y, cID1List[i].z, pNo1List[i], helperCube2, polygonNeighbourList))
    //                     return true;
                    return false;
                }
            
                if(isConnected(cID1List[i].x, cID1List[i].y, cID1List[i].z, pNo1List[i], 
                                cID2List[j].x, cID2List[j].y, cID2List[j].z, pNo2List[j], 
                                helperCube1, helperCube2, polygonNeighbourList))
                    return true;
            }
        }

        return false;

    //     return isConnected(this->iTri2CubeId[tri1Idx].x, this->iTri2CubeId[tri1Idx].y, this->iTri2CubeId[tri1Idx].z, patch1No, 
    //                         this->iTri2CubeId[tri2Idx].x, this->iTri2CubeId[tri2Idx].y, this->iTri2CubeId[tri2Idx].z, patch2No, 
    //                         helperCube1, helperCube2, polygonNeighbourList);
    }

    // returns true if patch is connected with some nontriangulable patch in adjcent cube
    // 
    // x, y, z (in): index of cube where patch is in
    // patchNo (in): patch number
    // helperCube (in): index of helper cube
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    template <class T>
    bool TilingNonobtuseMC<T>::isConnected_samePatch(uint x, uint y, uint z, uint patchNo, CubeId helperCube, const std::vector<int>* polygonNeighbourList)
    {
        std::vector<uint> triList;    // list of triangles that are in patchNo
        std::vector<uint> helperTriList;    // list of triangles that are from 'non-triangulable' patches within the helper cube

        // add all triangles in patch 1
        uint cubeIdx = (this->iCellsX)*(this->iCellsY)*z + (this->iCellsX)*y + x;
        uint numTriInPatch = this->iCubesProperty[cubeIdx].triGroups[patchNo].size();
        for(uint i = 0; i < numTriInPatch; ++i)
        {
            uint idx = this->iCubesProperty[cubeIdx].triGroups[patchNo][i];
            triList.push_back(this->iCubesProperty[cubeIdx].iIntTriVec[idx].iTriIdx);
        }

        // add all triangles in patch that does not generate any triangles in helper cube
        cubeIdx = (this->iCellsX)*(this->iCellsY)*helperCube.z + (this->iCellsX)*helperCube.y + helperCube.x;
        uint numPatch = this->iCubesProperty[cubeIdx].triGroups.size();
        for(uint j = 0; j < numPatch; ++j)
        {
            //if(this->iCubesProperty[cubeIdx].isConsistent[j] && this->iCubesProperty[cubeIdx].isEmptyTriangulation[j])
            if(this->iCubesProperty[cubeIdx].isEmptyTriangulation[j])
            {
                uint numTriInPatch = this->iCubesProperty[cubeIdx].triGroups[j].size();
                for(uint i = 0; i < numTriInPatch; ++i)
                {
                    uint idx = this->iCubesProperty[cubeIdx].triGroups[j][i];
                    uint triIdx = this->iCubesProperty[cubeIdx].iIntTriVec[idx].iTriIdx;
                
                    if(find(helperTriList.begin(), helperTriList.end(), triIdx) == helperTriList.end())
                        helperTriList.push_back(triIdx);
                }
            }
        }
    
        uint numHelperTri = helperTriList.size();
        if(numHelperTri == 0)
            return false;

        isOnePatch_aux(triList, helperTriList, polygonNeighbourList, 0, true);
        return (numHelperTri != helperTriList.size());
    }

    // returns true if patch 1 and patch 2 are connected by a sequence of untriangulable patches
    // 
    // x1, y1, z1 (in): index of cube where patch 1 is in
    // patch1No (in): patch 1
    // x2, y2, z2 (in): index of cube where patch 2 is in
    // patch2No (in): patch 2
    // helperCube1 (in): index of helper cube 1
    // helperCube2 (in): index of helper cube 2
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    template <class T> bool TilingNonobtuseMC<T>::isConnected(uint x1, uint y1, uint z1, uint patch1No, uint x2, uint y2, uint z2, uint patch2No, CubeID helperCube1, CubeID helperCube2, const std::vector<int>* polygonNeighbourList)
    {
        std::vector<uint> triList;    // list of triangles that are in patch1No or patch2No
        std::vector<uint> helperTriList;    // list of triangles that are from 'non-triangulable' patches within the same cube

        // add all triangles in patch 1
        uint cubeIdx = (this->iCellsX)*(this->iCellsY)*z1 + (this->iCellsX)*y1 + x1;
        uint numTriInPatch = this->iCubesProperty[cubeIdx].triGroups[patch1No].size();
        for(uint i = 0; i < numTriInPatch; ++i)
        {
            uint idx = this->iCubesProperty[cubeIdx].triGroups[patch1No][i];
            triList.push_back(this->iCubesProperty[cubeIdx].iIntTriVec[idx].iTriIdx);
        }

        // add all triangles in patch 2
        cubeIdx = (this->iCellsX)*(this->iCellsY)*z2 + (this->iCellsX)*y2 + x2;
        numTriInPatch = this->iCubesProperty[cubeIdx].triGroups[patch2No].size();
        for(uint i = 0; i < numTriInPatch; ++i)
        {
            uint idx = this->iCubesProperty[cubeIdx].triGroups[patch2No][i];
            uint triIdx = this->iCubesProperty[cubeIdx].iIntTriVec[idx].iTriIdx;
            if(find(triList.begin(), triList.end(), triIdx) == triList.end())
                triList.push_back(triIdx);
        }

        // add all triangles in patch that does not generate any triangles in helper cube 1
        cubeIdx = (this->iCellsX)*(this->iCellsY)*helperCube1.z + (this->iCellsX)*helperCube1.y + helperCube1.x;
        uint numPatch = this->iCubesProperty[cubeIdx].triGroups.size();
        for(uint j = 0; j < numPatch; ++j)
        {
    //         if(this->iCubesProperty[cubeIdx].isConsistent[j] && this->iCubesProperty[cubeIdx].isEmptyTriangulation[j])
            if(this->iCubesProperty[cubeIdx].isEmptyTriangulation[j])
            {
                uint numTriInPatch = this->iCubesProperty[cubeIdx].triGroups[j].size();
                for(uint i = 0; i < numTriInPatch; ++i)
                {
                    uint idx = this->iCubesProperty[cubeIdx].triGroups[j][i];
                    uint triIdx = this->iCubesProperty[cubeIdx].iIntTriVec[idx].iTriIdx;
                
                    if(find(helperTriList.begin(), helperTriList.end(), triIdx) == helperTriList.end())
                        helperTriList.push_back(triIdx);
                }
            }
        }

        // add all triangles in patch that does not generate any triangles in cube 2
        cubeIdx = (this->iCellsX)*(this->iCellsY)*helperCube2.z + (this->iCellsX)*helperCube2.y + helperCube2.x;
        numPatch = this->iCubesProperty[cubeIdx].triGroups.size();
        for(uint j = 0; j < numPatch; ++j)
        {
            //if(this->iCubesProperty[cubeIdx].isConsistent[j] && this->iCubesProperty[cubeIdx].isEmptyTriangulation[j])
            if(this->iCubesProperty[cubeIdx].isEmptyTriangulation[j])
            {
                uint numTriInPatch = this->iCubesProperty[cubeIdx].triGroups[j].size();
                for(uint i = 0; i < numTriInPatch; ++i)
                {
                    uint idx = this->iCubesProperty[cubeIdx].triGroups[j][i];
                    uint triIdx = this->iCubesProperty[cubeIdx].iIntTriVec[idx].iTriIdx;
                
                    if(find(helperTriList.begin(), helperTriList.end(), triIdx) == helperTriList.end())
                        helperTriList.push_back(triIdx);
                }
            }
        }

        return (isOnePatch(triList, helperTriList, polygonNeighbourList));
    }

    // check if the triangles in checkTriList are all connected by the helper triangles in helperList
    //
    // checkTriList (in/out): index of triangles to see if one patch can be formed
    // helperList (in/out): index of triangles from non-triangulable patches may help connect the patches
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // triIdx (in): index of needSortedList array to add to the patch and expand
    // return value (out): true if the triangles in needSortedList are all connected into one big patch
    template <class T> bool TilingNonobtuseMC<T>::isOnePatch(vector<uint> &checkTriList, std::vector<uint> &helperList, const std::vector<int>* polygonNeighbourList)
    {
        if(checkTriList.empty())
            return true;

        isOnePatch_aux(checkTriList, helperList, polygonNeighbourList, 0, true);
        return (checkTriList.empty());
    }

    // check if the triangles in needSortedList are all connected into one big patch
    //
    // checkTriList (in/out): index of triangles to see if one patch can be formed
    // helperList (in/out): index of triangles from non-triangulable patches may help connect the patches
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // index (in): index of needSortedList array to add to the patch and expand
    // indexFromCheckTriList (in): true if index is for checkTriList
    // return value (out): true if the triangles in needSortedList are all connected into one big patch
    template <class T> void TilingNonobtuseMC<T>::isOnePatch_aux(vector<uint> &checkTriList, std::vector<uint> &helperList, const std::vector<int>* polygonNeighbourList, uint index, bool indexFromCheckTriList)
    {
        uint triangleAdded = checkTriList[index];
        if(!indexFromCheckTriList)
            triangleAdded = helperList[index];

        // remove index from checkTriList
        if(!indexFromCheckTriList)
            helperList.erase(helperList.begin() + index);
        else
            checkTriList.erase(checkTriList.begin() + index);

        // expand group by examining the neighbour of triangle just added
        for(vector<int>::const_iterator iter = polygonNeighbourList[triangleAdded].begin(); iter != polygonNeighbourList[triangleAdded].end(); iter++)
        {
            bool foundNbr(false);
            for(uint i = 0; i < checkTriList.size(); ++i) {
                if((int)checkTriList[i] == *iter) {
                    isOnePatch_aux(checkTriList, helperList, polygonNeighbourList, i, true);
                    foundNbr = true;
                    break;
                }
            }

            if(!foundNbr)
            {
                for(uint i = 0; i < helperList.size(); ++i) {
                    if((int)helperList[i] == *iter) {
                        isOnePatch_aux(checkTriList, helperList, polygonNeighbourList, i, false);
                        foundNbr = true;
                        break;
                    }
                }
            }
        }
    }

    // stitch the two edges e1 and e2 together
    //
    // e1Info (in): edge info 1
    // e2Info (in): edge info 2
    // x,y,z (in): index of cube we are stitching at
    // faceIdx (in): face index of where stitching occurs
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // return value (out): true if stitching successful
    template <class T> bool TilingNonobtuseMC<T>::stitch(EdgePosInfo e1Info, EdgePosInfo e2Info, uint x, uint y, uint z, uint faceIdx, const std::vector<int>* polygonNeighbourList)
    {
        uint transformEdgePos[6][4] = {{2,1,0,3},{2,1,0,3},{2,1,0,3},{2,1,0,3},{0,3,2,1},{0,3,2,1}};

        Edge e1 = this->iEdgeList[e1Info.edgeIdx];    
        Edge e2 = this->iEdgeList[e2Info.edgeIdx];

        if(!e1Info.isV1First) {
            std::swap(e1Info.v1Edge, e1Info.v2Edge);
            std::swap(e1.vertex1Idx, e1.vertex2Idx);
        }
        if(!e2Info.isV1First) {
            std::swap(e2Info.v1Edge, e2Info.v2Edge);
            std::swap(e2.vertex1Idx, e2.vertex2Idx);
        }

        int e1v1 = e1Info.v1Edge;
        int e1v2 = e1Info.v2Edge;
        int e2v1 = e2Info.v1Edge;
        int e2v2 = e2Info.v2Edge;

        // flip v1Edge and v2Edge if edge was recorded at the adjacent cube
        bool e1InCube(true);
        CubeID c = this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]][0];
        if(c.x != x || c.y != y || c.z != z)
        {
            e1v1 = transformEdgePos[faceIdx][e1v1];
            e1v2 = transformEdgePos[faceIdx][e1v2];
            e1InCube = false;
        }

        c = this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]][0];
        if(c.x != x || c.y != y || c.z != z)
        {
            e2v1 = transformEdgePos[faceIdx][e2v1];
            e2v2 = transformEdgePos[faceIdx][e2v2];
        }

        // sanity check
        if(e1v1 == -1 || e1v2 == -1 || e2v1 == -1 || e2v2 == -1)
        {
            std::cout << "ERROR: TilingNonobtuseMC::stitch() - conflict in edge indices" << std::endl;
            return false;
        }

        if(e1v1 == e2v2 && e1v2 == e2v1)    // edges have same orientation; stitch both ends
        {
            int newv1Idx = stitchVertices(e1.vertex1Idx, e2.vertex2Idx);
            if(newv1Idx == -1)
                return false;
            int newv2Idx = stitchVertices(e1.vertex2Idx, e2.vertex1Idx);
            if(newv2Idx == -1)
                return false;

            // remove the redundant edges
            this->iEdgeList.erase(e1Info.edgeIdx);
            this->iEdgeList.erase(e2Info.edgeIdx);
            VPAIR vp;
            vp.first = newv1Idx;
            vp.second = newv2Idx;
            if(vp.first > vp.second)
                std::swap(vp.first, vp.second);
            this->iVPair2E.erase(vp);

            uint tri1Idx = this->iV2Tri[e1Info.edgeIdx][0];
            uint tri2Idx = this->iV2Tri[e2Info.edgeIdx][0];
            this->iV2Tri.erase(e1Info.edgeIdx);
            this->iV2Tri.erase(e2Info.edgeIdx);

            // remove this->iEonF reference
            uint onFaceIdx = this->iE2F[e1Info.edgeIdx];
            std::vector<EdgePosInfo>::iterator iter = find(this->iEonF[onFaceIdx].begin(), this->iEonF[onFaceIdx].end(), e1Info);
            if(iter != this->iEonF[onFaceIdx].end())
                this->iEonF[onFaceIdx].erase(iter);
            this->iE2F.erase(e1Info.edgeIdx);

            onFaceIdx = this->iE2F[e2Info.edgeIdx];
            iter = find(this->iEonF[onFaceIdx].begin(), this->iEonF[onFaceIdx].end(), e2Info);
            if(iter != this->iEonF[onFaceIdx].end())
                this->iEonF[onFaceIdx].erase(iter);
            this->iE2F.erase(e2Info.edgeIdx);

            // add new edge
            Edge newEdge;
            newEdge.vertex1Idx = newv1Idx;
            newEdge.vertex2Idx = newv2Idx;
            EdgePosInfo epi;
            epi.v1Edge = e1v1;
            epi.v2Edge = e1v2;
            // make sure v1Edge and v2Edge are recorded respect to the cube where it contains the triangle in the first entry of this->iV2Tri
            if(this->iTri2CubeId[tri1Idx][0].x != x ||
                this->iTri2CubeId[tri1Idx][0].y != y ||
                this->iTri2CubeId[tri1Idx][0].z != z)
            {
                epi.v1Edge = transformEdgePos[faceIdx][e1v1];
                epi.v2Edge = transformEdgePos[faceIdx][e1v2];
            }

            epi.isV1First = true;
            if(!e1InCube)
            {
                std::swap(newEdge.vertex1Idx, newEdge.vertex2Idx);
                std::swap(epi.v1Edge, epi.v2Edge);
                epi.isV1First = false;
            }

            if(newEdge.vertex1Idx > newEdge.vertex2Idx) {
                std::swap(newEdge.vertex1Idx, newEdge.vertex2Idx);
                std::swap(epi.v1Edge, epi.v2Edge);
                epi.isV1First = false;
            }

            uint newEdgeIdx = this->iNextUnusedEdgeId;
            ++this->iNextUnusedEdgeId;
            epi.edgeIdx = newEdgeIdx;
            this->iEdgeList.insert(ID2EDGE::value_type(newEdgeIdx, newEdge));
        
            this->iV2E[newEdge.vertex1Idx].push_back(newEdgeIdx);
            this->iV2E[newEdge.vertex2Idx].push_back(newEdgeIdx);

            vp.first = newEdge.vertex1Idx;
            vp.second = newEdge.vertex2Idx;
            this->iVPair2E.insert(VPAIRTOE::value_type(vp, newEdgeIdx));

            std::vector<uint> adjTriList(2);
            adjTriList[0] =    tri1Idx;
            adjTriList[1] = tri2Idx;
            this->iV2Tri.insert(ETOTRI::value_type(newEdgeIdx, adjTriList));

            this->iEonF[onFaceIdx].push_back(epi);
            this->iE2F.insert(ETOFACE::value_type(newEdgeIdx, onFaceIdx));

        }
        else if(e1v1 == e2v2)                // one end is stitched, then triangulate
        {
            int vertexId = stitchVertices(e1.vertex1Idx, e2.vertex2Idx);
            if(vertexId == -1)
                return false;

            // create triangle to cover hole
            TRIANGLE triangle;
            triangle.pointID[0] = vertexId;
            triangle.pointID[1] = e2.vertex1Idx;
            triangle.pointID[2] = e1.vertex2Idx;

            // record info for the new triangle
            std::vector<CubeID> cIDList;
            std::vector<uint> pNoList;
            for(uint i = 0; i < this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]].size(); ++i)
                cIDList.push_back(this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]][i]);
            for(uint i = 0; i < this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]].size(); ++i)
                cIDList.push_back(this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]][i]);
            for(uint i = 0; i < this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]].size(); ++i)
                pNoList.push_back(this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]][i]);
            for(uint i = 0; i < this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]].size(); ++i)
                pNoList.push_back(this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]][i]);
    //         CubeID cID = this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]];
    //         uint pNo = this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]];
    //         CubeID cID2 = this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]];
    //         uint pNo2 = this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]];

            for(uint j = 0; j < 3; ++j)
            {
                // add triangle reference to vertices
                this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                // add e-to-tri references
                VPAIR vp;
                vp.first = triangle.pointID[j];
                vp.second = triangle.pointID[(j+1)%3];
                if(vp.first > vp.second)
                    std::swap(vp.first, vp.second);

                VPAIRTOE::iterator iter = this->iVPair2E.find(vp);
                if(iter != this->iVPair2E.end())
                {
                    uint currentEdgeID = iter->second;
                    this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());
                }
            }

            // add the new edge
            Edge e;
            e.vertex1Idx = e2.vertex1Idx;
            e.vertex2Idx = e1.vertex2Idx;
            EdgePosInfo epi;
            epi.v1Edge = e2v1;
            epi.v2Edge = e1v2;
            // make sure v1Edge and v2Edge are recorded respect to the cube where it contains the triangle in the first entry of this->iV2Tri
            if(cIDList[0].x != x || cIDList[0].y != y || cIDList[0].z != z)
            {
                epi.v1Edge = transformEdgePos[faceIdx][e2v1];
                epi.v2Edge = transformEdgePos[faceIdx][e1v2];
            }

            epi.isV1First = true;
            if(e.vertex1Idx > e.vertex2Idx) {
                std::swap(e.vertex1Idx, e.vertex2Idx);
                std::swap(epi.v1Edge, epi.v2Edge);
                epi.isV1First = false;
            }

            uint newEdgeIdx = this->iNextUnusedEdgeId;
            ++this->iNextUnusedEdgeId;
            epi.edgeIdx = newEdgeIdx;
            this->iEdgeList.insert(ID2EDGE::value_type(newEdgeIdx, e));

            VPAIR vp;
            vp.first = e.vertex1Idx;
            vp.second = e.vertex2Idx;
            this->iVPair2E.insert(VPAIRTOE::value_type(vp, newEdgeIdx));

            // add this->iV2E references        
            this->iV2E[e.vertex1Idx].push_back(newEdgeIdx);
            this->iV2E[e.vertex2Idx].push_back(newEdgeIdx);

            // add this->iV2Tri references
            std::vector<uint> adjTriList(1,this->iTriangleVec.size());
            this->iV2Tri.insert(ETOTRI::value_type(newEdgeIdx, adjTriList));

            // add this->iV2Tri references for the two existing edges
            vp.first = vertexId;
            vp.second = e2.vertex1Idx;
            if(vp.first > vp.second)
                std::swap(vp.first, vp.second);
            this->iV2Tri[this->iVPair2E[vp]].push_back(this->iTriangleVec.size());

            vp.first = e1.vertex2Idx;
            vp.second = vertexId;
            if(vp.first > vp.second)
                std::swap(vp.first, vp.second);
            this->iV2Tri[this->iVPair2E[vp]].push_back(this->iTriangleVec.size());

            // add this->iEonF references for new edge
            uint onFaceIdx = this->iE2F[e1Info.edgeIdx];
            this->iEonF[onFaceIdx].push_back(epi);
            this->iE2F.insert(ETOFACE::value_type(newEdgeIdx, onFaceIdx));
        
            // add triangle to triangle list
            this->iTriangleVec.push_back(triangle);
        
            // add tri-to-cube reference
            this->iTri2CubeId.push_back(cIDList);
            this->iTri2Patch.push_back(pNoList);

            // stitch new edge that may overlap with existing ones
            stitchOverlappingEdges(epi, x, y, z, faceIdx, polygonNeighbourList);
    //         if(!stitchOverlappingEdges(epi, x, y, z, faceIdx, polygonNeighbourList))
    //         {
    //             // if it doesn't work the first try, then try to associate the other patch to the new triangle, and try again
    //             std::vector<EdgePosInfo>::iterator iter = find(this->iEonF[onFaceIdx].begin(), this->iEonF[onFaceIdx].end(), epi);
    //             if(iter != this->iEonF[onFaceIdx].end())
    //             {
    //                 if(cID.x != x || cID.y != y || cID.z != z)
    //                 {
    //                     // convert coordinate back w.r.t current cube
    //                     iter->v1Edge = transformEdgePos[faceIdx][iter->v1Edge];
    //                     iter->v2Edge = transformEdgePos[faceIdx][iter->v2Edge];
    //                 }
    // 
    //                 if(cID2.x != x || cID2.y != y || cID2.z != z)
    //                 {
    //                     // convert coordinate w.r.t associated cube
    //                     iter->v1Edge = transformEdgePos[faceIdx][iter->v1Edge];
    //                     iter->v2Edge = transformEdgePos[faceIdx][iter->v2Edge];
    //                 }
    // 
    //                 this->iTri2CubeId[this->iTri2CubeId.size()-1] = cID2;
    //                 this->iTri2Patch[this->iTri2Patch.size()-1] = pNo2;
    //                 stitchOverlappingEdges(epi, x, y, z, faceIdx, polygonNeighbourList);
    //             }
    //         }
        }
        else if(e1v2 == e2v1)                // the other end is stitched, then triangulate
        {    
            int vertexId = stitchVertices(e1.vertex2Idx, e2.vertex1Idx);
            if(vertexId == -1)
                return false;

            // record info for the new triangle
            std::vector<CubeID> cIDList;
            std::vector<uint> pNoList;
            for(uint i = 0; i < this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]].size(); ++i)
                cIDList.push_back(this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]][i]);
            for(uint i = 0; i < this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]].size(); ++i)
                cIDList.push_back(this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]][i]);
            for(uint i = 0; i < this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]].size(); ++i)
                pNoList.push_back(this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]][i]);
            for(uint i = 0; i < this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]].size(); ++i)
                pNoList.push_back(this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]][i]);
    //         CubeID cID = this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]];
    //         uint pNo = this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]];
    //         CubeID cID2 = this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]];
    //         uint pNo2 = this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]];

            // create triangle to cover hole
            TRIANGLE triangle;
            triangle.pointID[0] = vertexId;
            triangle.pointID[1] = e1.vertex1Idx;
            triangle.pointID[2] = e2.vertex2Idx;

            for(uint j = 0; j < 3; ++j)
            {
                // add triangle reference to vertices
                this->iV2Tri[triangle.pointID[j]].push_back(this->iTriangleVec.size());

                // add e-to-tri references
                VPAIR vp;
                vp.first = triangle.pointID[j];
                vp.second = triangle.pointID[(j+1)%3];
                if(vp.first > vp.second)
                    std::swap(vp.first, vp.second);

                VPAIRTOE::iterator iter = this->iVPair2E.find(vp);
                if(iter != this->iVPair2E.end())
                {
                    uint currentEdgeID = iter->second;
                    this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());
                }
            }

            // add the new edge
            Edge e;
            e.vertex1Idx = e1.vertex1Idx;
            e.vertex2Idx = e2.vertex2Idx;
            EdgePosInfo epi;
            epi.v1Edge = e1v1;
            epi.v2Edge = e2v2;
            // make sure v1Edge and v2Edge are recorded respect to the cube where it contains the triangle in the first entry of this->iV2Tri
            if(cIDList[0].x != x || cIDList[0].y != y || cIDList[0].z != z)
            {
                epi.v1Edge = transformEdgePos[faceIdx][e1v1];
                epi.v2Edge = transformEdgePos[faceIdx][e2v2];
            }
            epi.isV1First = true;
            if(e.vertex1Idx > e.vertex2Idx) {
                std::swap(e.vertex1Idx, e.vertex2Idx);
                std::swap(epi.v1Edge, epi.v2Edge);
                epi.isV1First = false;
            }

            uint newEdgeIdx = this->iNextUnusedEdgeId;
            ++this->iNextUnusedEdgeId;
            epi.edgeIdx = newEdgeIdx;
            this->iEdgeList.insert(ID2EDGE::value_type(newEdgeIdx, e));

            VPAIR vp;
            vp.first = e.vertex1Idx;
            vp.second = e.vertex2Idx;
            this->iVPair2E.insert(VPAIRTOE::value_type(vp, newEdgeIdx));

            // add this->iV2E references        
            this->iV2E[e.vertex1Idx].push_back(newEdgeIdx);
            this->iV2E[e.vertex2Idx].push_back(newEdgeIdx);

            // add this->iV2Tri references
            std::vector<uint> adjTriList(1,this->iTriangleVec.size());
            this->iV2Tri.insert(ETOTRI::value_type(newEdgeIdx, adjTriList));

            vp.first = vertexId;
            vp.second = e1.vertex1Idx;
            if(vp.first > vp.second)
                std::swap(vp.first, vp.second);
            this->iV2Tri[this->iVPair2E[vp]].push_back(this->iTriangleVec.size());

            vp.first = e2.vertex2Idx;
            vp.second = vertexId;
            if(vp.first > vp.second)
                std::swap(vp.first, vp.second);
            this->iV2Tri[this->iVPair2E[vp]].push_back(this->iTriangleVec.size());

            // add this->iEonF references
            uint onFaceIdx = this->iE2F[e1Info.edgeIdx];
            this->iEonF[onFaceIdx].push_back(epi);
            this->iE2F.insert(ETOFACE::value_type(newEdgeIdx, onFaceIdx));

            // add triangle to triangle list
            this->iTriangleVec.push_back(triangle);

            // add tri-to-cube reference
            this->iTri2CubeId.push_back(cIDList);
            this->iTri2Patch.push_back(pNoList);

            // stitch new edge that may overlap with existing ones
            stitchOverlappingEdges(epi, x, y, z, faceIdx, polygonNeighbourList);
    //         if(!stitchOverlappingEdges(epi, x, y, z, faceIdx, polygonNeighbourList))
    //         {
    //             // if it doesn't work the first try, then try to associate the other patch to the new triangle, and try again
    //             std::vector<EdgePosInfo>::iterator iter = find(this->iEonF[onFaceIdx].begin(), this->iEonF[onFaceIdx].end(), epi);
    //             if(iter != this->iEonF[onFaceIdx].end())
    //             {
    //                 if(cID.x != x || cID.y != y || cID.z != z)
    //                 {
    //                     // convert coordinate back w.r.t current cube
    //                     iter->v1Edge = transformEdgePos[faceIdx][iter->v1Edge];
    //                     iter->v2Edge = transformEdgePos[faceIdx][iter->v2Edge];
    //                 }
    // 
    //                 if(cID2.x != x || cID2.y != y || cID2.z != z)
    //                 {
    //                     // convert coordinate w.r.t associated cube
    //                     iter->v1Edge = transformEdgePos[faceIdx][iter->v1Edge];
    //                     iter->v2Edge = transformEdgePos[faceIdx][iter->v2Edge];
    //                 }
    // 
    //                 this->iTri2CubeId[this->iTri2CubeId.size()-1] = cID2;
    //                 this->iTri2Patch[this->iTri2Patch.size()-1] = pNo2;
    //                 stitchOverlappingEdges(epi, x, y, z, faceIdx, polygonNeighbourList);
    //             }
    //         }
        }
        else if(e1v1 != e2v1 && e1v1 != e2v2 && e1v2 != e2v1 && e1v2 != e2v2)    // edges are parallel; triangulate
        {
            if(((e1v1 + e2v1)%2 == 0) && ((e1v2 + e2v2)%2 == 0))    // to check for consistent facing
            {
                // record info for the new triangle
                std::vector<CubeID> cIDList;
                std::vector<uint> pNoList;
                for(uint i = 0; i < this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]].size(); ++i)
                    cIDList.push_back(this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]][i]);
                for(uint i = 0; i < this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]].size(); ++i)
                    pNoList.push_back(this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]][i]);
                for(uint i = 0; i < this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]].size(); ++i)
                    cIDList.push_back(this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]][i]);
                for(uint i = 0; i < this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]].size(); ++i)
                    pNoList.push_back(this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]][i]);
    //             CubeID cID = this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]];
    //             uint pNo = this->iTri2Patch[this->iV2Tri[e1Info.edgeIdx][0]];

                // create triangle to cover hole
                TRIANGLE triangle1;
                triangle1.pointID[0] = e1.vertex2Idx;
                triangle1.pointID[1] = e1.vertex1Idx;
                triangle1.pointID[2] = e2.vertex1Idx;

                for(uint j = 0; j < 3; ++j)
                {
                    // add triangle reference to vertices
                    this->iV2Tri[triangle1.pointID[j]].push_back(this->iTriangleVec.size());
    
                    // add e-to-tri references
                    VPAIR vp;
                    vp.first = triangle1.pointID[j];
                    vp.second = triangle1.pointID[(j+1)%3];
                    if(vp.first > vp.second)
                        std::swap(vp.first, vp.second);
    
                    VPAIRTOE::iterator iter = this->iVPair2E.find(vp);
                    if(iter != this->iVPair2E.end())
                    {
                        uint currentEdgeID = iter->second;
                        this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());
                    }
                }
    
                // add the new edges
                EdgePosInfo tocheckOverlapStiching;
                for(uint k = 0; k < 2; ++k)
                {
                    uint v1Idx = e1.vertex1Idx;
                    uint v2Idx = e2.vertex1Idx;
                    uint v1Edge = e1v1;
                    uint v2Edge = e2v1;
                    if(k == 1)
                    {
                        v1Idx = e2.vertex1Idx;
                        v2Idx = e1.vertex2Idx;
                        v1Edge = e2v1;
                        v2Edge = e1v2;
                    }

                    Edge e;
                    e.vertex1Idx = v1Idx;
                    e.vertex2Idx = v2Idx;
                    EdgePosInfo epi;
                    epi.v1Edge = v1Edge;
                    epi.v2Edge = v2Edge;
                    // make sure v1Edge and v2Edge are recorded respect to the cube where it contains the triangle in the first entry of this->iV2Tri
                    if(cIDList[0].x != x || cIDList[0].y != y || cIDList[0].z != z)
                    {
                        epi.v1Edge = transformEdgePos[faceIdx][epi.v1Edge];
                        epi.v2Edge = transformEdgePos[faceIdx][epi.v2Edge];
                    }

                    epi.isV1First = true;
                    if(e.vertex1Idx > e.vertex2Idx) {
                        std::swap(e.vertex1Idx, e.vertex2Idx);
                        std::swap(epi.v1Edge, epi.v2Edge);
                        epi.isV1First = false;
                    }
        
                    uint newEdgeIdx = this->iNextUnusedEdgeId;
                    ++this->iNextUnusedEdgeId;
                    epi.edgeIdx = newEdgeIdx;
                    this->iEdgeList.insert(ID2EDGE::value_type(newEdgeIdx, e));
        
                    VPAIR vp;
                    vp.first = e.vertex1Idx;
                    vp.second = e.vertex2Idx;
                    this->iVPair2E.insert(VPAIRTOE::value_type(vp, newEdgeIdx));
        
                    // add this->iV2E references        
                    this->iV2E[e.vertex1Idx].push_back(newEdgeIdx);
                    this->iV2E[e.vertex2Idx].push_back(newEdgeIdx);
        
                    // add this->iV2Tri references
                    std::vector<uint> adjTriList(1,this->iTriangleVec.size());
                    this->iV2Tri.insert(ETOTRI::value_type(newEdgeIdx, adjTriList));
        
                    // add this->iEonF references
                    uint onFaceIdx = this->iE2F[e1Info.edgeIdx];
                    this->iEonF[onFaceIdx].push_back(epi);
                    this->iE2F.insert(ETOFACE::value_type(newEdgeIdx, onFaceIdx));

                    if(k == 1)
                        tocheckOverlapStiching = epi;
                }
    
                // add triangle to triangle list
                this->iTriangleVec.push_back(triangle1);

                // add tri-to-cube reference
                this->iTri2CubeId.push_back(cIDList);
                this->iTri2Patch.push_back(pNoList);

                // save the face index for later use
                uint saveOnFaceIdx = this->iE2F[e1Info.edgeIdx];

                stitchOverlappingEdges(tocheckOverlapStiching, x, y, z, faceIdx, polygonNeighbourList);

                //----------- begin triangle 2---------------
                // ====================================================================================================================
                // make sure we get the most updated vIdx from the edges; note vIdx may changed due to stitchOverlappingEdges(), so don't use a copied version
                // ====================================================================================================================
                std::vector<EdgePosInfo>::iterator iter = find(this->iEonF[saveOnFaceIdx].begin(), this->iEonF[saveOnFaceIdx].end(), e1Info);
                if(iter != this->iEonF[saveOnFaceIdx].end())
                    e1Info = *iter;
                iter = find(this->iEonF[saveOnFaceIdx].begin(), this->iEonF[saveOnFaceIdx].end(), e2Info);
                if(iter != this->iEonF[saveOnFaceIdx].end())
                    e2Info = *iter;
                Edge e1 = this->iEdgeList[e1Info.edgeIdx];    
                Edge e2 = this->iEdgeList[e2Info.edgeIdx];
                if(!e1Info.isV1First) {
                    std::swap(e1Info.v1Edge, e1Info.v2Edge);
                    std::swap(e1.vertex1Idx, e1.vertex2Idx);
                }
                if(!e2Info.isV1First) {
                    std::swap(e2Info.v1Edge, e2Info.v2Edge);
                    std::swap(e2.vertex1Idx, e2.vertex2Idx);
                }
                e1v1 = e1Info.v1Edge;
                e1v2 = e1Info.v2Edge;
                e2v1 = e2Info.v1Edge;
                e2v2 = e2Info.v2Edge;
        
                // flip v1Edge and v2Edge if edge was recorded at the adjacent cube
                CubeID c = this->iTri2CubeId[this->iV2Tri[e1Info.edgeIdx][0]][0];
                if(c.x != x || c.y != y || c.z != z)
                {
                    e1v1 = transformEdgePos[faceIdx][e1v1];
                    e1v2 = transformEdgePos[faceIdx][e1v2];
                }
                c = this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]][0];
                if(c.x != x || c.y != y || c.z != z)
                {
                    e2v1 = transformEdgePos[faceIdx][e2v1];
                    e2v2 = transformEdgePos[faceIdx][e2v2];
                }
                // ====================================================================================================================
                // ====================================================================================================================

                // record info for the new triangle
    //             cID = this->iTri2CubeId[this->iV2Tri[e2Info.edgeIdx][0]];
    //             pNo = this->iTri2Patch[this->iV2Tri[e2Info.edgeIdx][0]];
            
                // add 2nd triangle
                TRIANGLE triangle2;
                triangle2.pointID[0] = e2.vertex2Idx;
                triangle2.pointID[1] = e2.vertex1Idx;
                triangle2.pointID[2] = e1.vertex1Idx;
            
                for(uint j = 0; j < 3; ++j)
                {
                    // add triangle reference to vertices
                    this->iV2Tri[triangle2.pointID[j]].push_back(this->iTriangleVec.size());
    
                    // add e-to-tri references
                    VPAIR vp;
                    vp.first = triangle2.pointID[j];
                    vp.second = triangle2.pointID[(j+1)%3];
                    if(vp.first > vp.second)
                        std::swap(vp.first, vp.second);
    
                    VPAIRTOE::iterator iter = this->iVPair2E.find(vp);
                    if(iter != this->iVPair2E.end())
                    {
                        uint currentEdgeID = iter->second;
                        this->iV2Tri[currentEdgeID].push_back(this->iTriangleVec.size());
                    }
                }
    
                // add the new edge
                uint v1Idx = e1.vertex1Idx;
                uint v2Idx = e2.vertex2Idx;
                uint v1Edge = e1v1;
                uint v2Edge = e2v2;

                Edge e;
                e.vertex1Idx = v1Idx;
                e.vertex2Idx = v2Idx;
                EdgePosInfo epi;
                epi.v1Edge = v1Edge;
                epi.v2Edge = v2Edge;
                // make sure v1Edge and v2Edge are recorded respect to the cube where it contains the triangle in the first entry of this->iV2Tri
                if(cIDList[0].x != x || cIDList[0].y != y || cIDList[0].z != z)
                {
                    epi.v1Edge = transformEdgePos[faceIdx][epi.v1Edge];
                    epi.v2Edge = transformEdgePos[faceIdx][epi.v2Edge];
                }

                epi.isV1First = true;
                if(e.vertex1Idx > e.vertex2Idx) {
                    std::swap(e.vertex1Idx, e.vertex2Idx);
                    std::swap(epi.v1Edge, epi.v2Edge);
                    epi.isV1First = false;
                }
    
                uint newEdgeIdx = this->iNextUnusedEdgeId;
                ++this->iNextUnusedEdgeId;
                epi.edgeIdx = newEdgeIdx;
                this->iEdgeList.insert(ID2EDGE::value_type(newEdgeIdx, e));
    
                VPAIR vp;
                vp.first = e.vertex1Idx;
                vp.second = e.vertex2Idx;
                this->iVPair2E.insert(VPAIRTOE::value_type(vp, newEdgeIdx));
    
                // add this->iV2E references        
                this->iV2E[e.vertex1Idx].push_back(newEdgeIdx);
                this->iV2E[e.vertex2Idx].push_back(newEdgeIdx);
    
                // add this->iV2Tri references
                std::vector<uint> adjTriList(1,this->iTriangleVec.size());
                this->iV2Tri.insert(ETOTRI::value_type(newEdgeIdx, adjTriList));
    
                // add this->iEonF references
                uint onFaceIdx = this->iE2F[e1Info.edgeIdx];
                this->iEonF[onFaceIdx].push_back(epi);
                this->iE2F.insert(ETOFACE::value_type(newEdgeIdx, onFaceIdx));

                // add triangle to triangle list
                this->iTriangleVec.push_back(triangle2);

                // add tri-to-cube reference
                this->iTri2CubeId.push_back(cIDList);
                this->iTri2Patch.push_back(pNoList);

                stitchOverlappingEdges(epi, x, y, z, faceIdx, polygonNeighbourList);
            }
             else
            {
    //             std::cout << "WARNING: TilingNonobtuseMC::stitch() - degenerate cases in stitching" << std::endl;
                return false;
            }
        }
        else        // degenerate cases
        {
    //         std::cout << "WARNING: TilingNonobtuseMC::stitch() - degenerate cases in stitching" << std::endl;
            return false;
        }
    
        return true;
    }

    // Stitch overlapping edges; only call from stitch() to ensure we dont' introduce many overlapping vertices and run into infinite loops
    //
    // eInfo (in): info of edge that we want to stitch up with
    // x,y,z (in):    index of cube where stitching was invoked
    // faceIdx (in): face index of where stitching occurs on cube
    // polygonNeighbourList (in): polygon neighbour information for source mesh
    // return value (out): true if edge is stitched
    template <class T> bool TilingNonobtuseMC<T>::stitchOverlappingEdges(EdgePosInfo eInfo, uint x, uint y, uint z, uint faceIdx, const std::vector<int>* polygonNeighbourList)
    {
        uint transformEdgePos[6][4] = {{2,1,0,3},{2,1,0,3},{2,1,0,3},{2,1,0,3},{0,3,2,1},{0,3,2,1}};
        std::vector<EdgePosInfo> &edgesOnFace = this->iEonF[GetFaceID(x, y, z, faceIdx)];

        for(uint j = 0; j < edgesOnFace.size() - 1; ++j)    // last one is eInfo, so no need to check
        {
            // check if edge is open, if not, skip to next edge
            if(this->iV2Tri[edgesOnFace[j].edgeIdx].size() >= 2)
            {
                continue;
            }

            int eiv1 = eInfo.v1Edge;
            int eiv2 = eInfo.v2Edge;
            if(!eInfo.isV1First)
                std::swap(eiv1,eiv2);
            int ejv1 = edgesOnFace[j].v1Edge;
            int ejv2 = edgesOnFace[j].v2Edge;
            if(!edgesOnFace[j].isV1First)
                std::swap(ejv1,ejv2);


    //         // flip v1Edge and v2Edge if edge was recorded at the adjacent cube
    //         CubeID c = this->iTri2CubeId[this->iV2Tri[eInfo.edgeIdx][0]];
    //         if(c.x != x || c.y != y || c.z != z)
    //         {
    //             eiv1 = transformEdgePos[faceIdx][eiv1];
    //             eiv2 = transformEdgePos[faceIdx][eiv2];
    //         }
    //         c = this->iTri2CubeId[this->iV2Tri[edgesOnFace[j].edgeIdx][0]];
    //         if(c.x != x || c.y != y || c.z != z)
    //         {
    //             ejv1 = transformEdgePos[faceIdx][ejv1];
    //             ejv2 = transformEdgePos[faceIdx][ejv2];
    //         }
    //         
    //         if(!(eiv1 == ejv2 && eiv2 == ejv1))    // only consider edges that are overlapping
    //             continue;

            std::vector<CubeID> &cID1List = this->iTri2CubeId[this->iV2Tri[eInfo.edgeIdx][0]];
            std::vector<CubeID> &cID2List = this->iTri2CubeId[this->iV2Tri[edgesOnFace[j].edgeIdx][0]];

            // both edges are generated from stitching, they shouldn't need to be stitched together
            if(cID1List.size() > 1 && cID2List.size() > 1)
                continue;

            for(uint i = 0; i < cID1List.size(); ++i)
            {
                CubeID c1 = cID1List[i];
                if(c1.x != x || c1.y != y || c1.z != z)
                {
                    eiv1 = transformEdgePos[faceIdx][eiv1];
                    eiv2 = transformEdgePos[faceIdx][eiv2];
                }

                for(uint k = 0; k < cID2List.size(); ++k)
                {
                    CubeID c2 = cID2List[k];
                    if(c2.x != x || c2.y != y || c2.z != z)
                    {
                        ejv1 = transformEdgePos[faceIdx][ejv1];
                        ejv2 = transformEdgePos[faceIdx][ejv2];
                    }

                    if(eiv1 == ejv2 && eiv2 == ejv1)    // only consider edges that are overlapping
                    {
                        if(shouldStitch(eInfo.edgeIdx, edgesOnFace[j].edgeIdx, x, y, z, faceIdx, polygonNeighbourList))
                        {
                            if(stitch(eInfo, edgesOnFace[j], x, y, z, faceIdx, polygonNeighbourList))
                            {
                                return true;
                            }
                        }
                    }
                }
            }
        }

        return false;
    }

    // join vertex v1Idx and v2Idx together
    //
    // v1Idx (in): index of vertex 1
    // v2Idx (in): index of vertex 2
    // return value (out): vertex ID of the joined vertex
    template <class T>
    uint TilingNonobtuseMC<T>::stitchVertices(uint v1Idx, uint v2Idx)
    {
        uint newvIdx = v1Idx;
        if(v1Idx != v2Idx)
        {
            if(!this->canVerticesJoin(v1Idx, v2Idx))
            {
                return -1;
            }
            Point3dId pt = this->iId2Point3dId[v1Idx];
            // erase v1
            this->iId2Point3dId.erase(v1Idx);
            // erase v2
            this->iId2Point3dId.erase(v2Idx);
            // add merged vertex with new vId
            uint vertexId = this->iNextUnusedVertexId;
            ++this->iNextUnusedVertexId;
            newvIdx = vertexId;
            this->iId2Point3dId.insert(Id2Point3dId::value_type(vertexId, pt));
            std::vector<uint> adjTriList;
            // update v1 reference in triangle
            for(std::vector<uint>::iterator iter = this->iV2Tri[v1Idx].begin(); iter != this->iV2Tri[v1Idx].end(); ++iter)
            {
                uint triId = *iter;
                adjTriList.push_back(triId);
                for(uint i = 0; i < 3; ++i)
                {
                    if(this->iTriangleVec[triID].pointID[i] == v1Idx)
                    {
                        this->iTriangleVec[triID].pointID[i] = vertexId;
                        break;
                    }
                }
            }
            this->iV2Tri.erase(v1Idx);

            // update v2 reference in triangle
            for(vector<uint>::iterator iter = this->iV2Tri[v2Idx].begin(); iter != this->iV2Tri[v2Idx].end(); iter++)
            {
                uint triID = *iter;
                if(find(adjTriList.begin(), adjTriList.end(), triID) == adjTriList.end())
                    adjTriList.push_back(triID);
                for(uint i = 0; i < 3; ++i) {
                    if(this->iTriangleVec[triID].pointID[i] == v2Idx) {
                        this->iTriangleVec[triID].pointID[i] = vertexId;
                        break;
                    }
                }
            }
            this->iV2Tri.erase(v2Idx);

            this->iV2Tri.insert(VTOTRI::value_type(vertexId, adjTriList));

            // update v1_to_e references
            std::vector<uint> adjEdgeList;
            for(vector<uint>::iterator iter = this->iV2E[v1Idx].begin(); iter != this->iV2E[v1Idx].end(); iter++)
            {
                // update edges
                Edge &e = this->iEdgeList[*iter];
                VPAIR vp;
                vp.first = e.vertex1Idx;
                vp.second = e.vertex2Idx;
                this->iVPair2E.erase(vp);

                // do not add duplicate edges
                if(find(adjEdgeList.begin(), adjEdgeList.end(), *iter) == adjEdgeList.end())
                    adjEdgeList.push_back(*iter);

                if(e.vertex1Idx == (int)v1Idx) 
                    e.vertex1Idx = vertexId;
                else if(e.vertex2Idx == (int)v1Idx) 
                    e.vertex2Idx = vertexId;
            
                EdgePosInfo eInfo;
                eInfo.edgeIdx = *iter;
                std::vector<EdgePosInfo>::iterator iter2 = find(this->iEonF[this->iE2F[*iter]].begin(), this->iEonF[this->iE2F[*iter]].end(), eInfo);
        
                if(e.vertex1Idx > e.vertex2Idx) {
                    std::swap(e.vertex1Idx, e.vertex2Idx);
                    std::swap(iter2->v1Edge, iter2->v2Edge);
                    iter2->isV1First = !iter2->isV1First;
                }

                vp.first = e.vertex1Idx;
                vp.second = e.vertex2Idx;
                this->iVPair2E.insert(VPAIRTOE::value_type(vp,*iter));
            }
            this->iV2E.erase(v1Idx);

            // update v2_to_e references
            for(vector<uint>::iterator iter = this->iV2E[v2Idx].begin(); iter != this->iV2E[v2Idx].end(); iter++)
            {
                // update edges
                Edge &e = this->iEdgeList[*iter];
                VPAIR vp;
                vp.first = e.vertex1Idx;
                vp.second = e.vertex2Idx;
                this->iVPair2E.erase(vp);

                // do not add duplicate edges
                if(find(adjEdgeList.begin(), adjEdgeList.end(), *iter) == adjEdgeList.end())
                    adjEdgeList.push_back(*iter);

                if(e.vertex1Idx == (int)v2Idx) 
                    e.vertex1Idx = vertexId;
                else if(e.vertex2Idx == (int)v2Idx) 
                    e.vertex2Idx = vertexId;
            
                EdgePosInfo eInfo;
                eInfo.edgeIdx = *iter;
                std::vector<EdgePosInfo>::iterator iter2 = find(this->iEonF[this->iE2F[*iter]].begin(), this->iEonF[this->iE2F[*iter]].end(), eInfo);
        
                if(e.vertex1Idx > e.vertex2Idx) {
                    std::swap(e.vertex1Idx, e.vertex2Idx);
                    std::swap(iter2->v1Edge, iter2->v2Edge);
                    iter2->isV1First = !iter2->isV1First;
                }

                vp.first = e.vertex1Idx;
                vp.second = e.vertex2Idx;
                this->iVPair2E.insert(VPAIRTOE::value_type(vp,*iter));
            }
            this->iV2E.erase(v2Idx);
            this->iV2E.insert(VTOE::value_type(vertexId, adjEdgeList));

            uint edgeID = this->iV2EOfCube[v1Idx];
            std::vector<int>::iterator iter = find(this->iVonE[edgeID].begin(), this->iVonE[edgeID].end(), (int)v1Idx);
            if(iter != this->iVonE[edgeID].end())
                this->iVonE[edgeID].erase(iter);
            iter = find(this->iVonE[edgeID].begin(), this->iVonE[edgeID].end(), (int)v2Idx);
            if(iter != this->iVonE[edgeID].end())
                this->iVonE[edgeID].erase(iter);

            this->iV2EOfCube.erase(v1Idx);
            this->iV2EOfCube.erase(v2Idx);

            this->iVonE[edgeID].push_back(vertexId);
            this->iV2EOfCube.insert(VTOEOFCUBE::value_type(vertexId, edgeID));
        }

        return newvIdx;
    }

    // check if vertex v1Idx and v2Idx can be joined together
    //
    // v1Idx (in): index of vertex 1
    // v2Idx (in): index of vertex 2
    // return value (out): true if can join
    template <class T>
    uint TilingNonobtuseMC<T>::canVerticesJoin(uint v1Idx, uint v2Idx)
    {
        std::vector<uint>& v1EdgeList = this->iV2E[v1Idx];
        std::vector<uint>& v2EdgeList = this->iV2E[v2Idx];
        for(uint i = 0; i < v1EdgeList.size(); ++i)
        {
            bool checkClosedEdges = false;
            if(this->iV2Tri[v1EdgeList[i]].size() < 2)
            {
                checkClosedEdges = true;
            }
            uint u1Idx = this->iEdgeList[v1EdgeList[i]].iV1Idx;
            if(u1Idx == v1Idx)
            {
                u1Idx = this->iEdgeList[v1EdgeList[i]].iV2Idx;
            }
            // search if v2Idx has an edge connected v1Idx
            for(uint j = 0; j < v2EdgeList.size(); ++j)
            {
                uint u2Idx = this->iEdgeList[v2EdgeList[j]].iV1Idx;
                if(u2Idx == v2Idx)
                {
                    u2Idx = this->iEdgeList[v2EdgeList[j]].iV2Idx;
                }
                if(u1Idx != u2Idx)
                {
                    continue;
                }
                // u1Idx is connected to a closed edge, and v2Idx is connected to u1Idx, so joining v1Idx + v2Idx will result in nonmanifold edge
                if(!checkClosedEdges)
                {
                    return false;
                }
                else if(this->iV2Tri[v2EdgeList[j]].size() >= 2)
                {
                    return false;
                }
            }
        }
        return true;
    }

    template class TilingNonobtuseMC<short>;
    template class TilingNonobtuseMC<unsigned short>;
    template class TilingNonobtuseMC<int>;
    template class TilingNonobtuseMC<unsigned int>;
    template class TilingNonobtuseMC<float>;
    template class TilingNonobtuseMC<double>;
}
